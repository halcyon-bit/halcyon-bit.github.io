<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基础-枚举与模式匹配⭐(Rust)</title>
      <link href="/2023/03/30/18735.html"/>
      <url>/2023/03/30/18735.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、枚举"><a href="#一、枚举" class="headerlink" title="一、枚举"></a>一、枚举</h1><p>枚举允许列举所有可能的值来定义一个类型。</p><h2 id="1-定义与使用枚举"><a href="#1-定义与使用枚举" class="headerlink" title="1. 定义与使用枚举"></a>1. 定义与使用枚举</h2><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">IpAddrKind</span> <span class="token punctuation">{</span>    <span class="token constant">V4</span><span class="token punctuation">,</span>    <span class="token constant">V6</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">let</span> ip4 <span class="token operator">=</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">::</span><span class="token constant">V4</span><span class="token punctuation">;</span><span class="token keyword">let</span> ip6 <span class="token operator">=</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">::</span><span class="token constant">V6</span><span class="token punctuation">;</span><span class="token keyword">fn</span> <span class="token function-definition function">route</span><span class="token punctuation">(</span>ip_kind<span class="token punctuation">:</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>枚举的变体都位于标识符的命名空间下，使用两个冒号 :: 进行分隔。</p><h2 id="2-与结构体结合"><a href="#2-与结构体结合" class="headerlink" title="2. 与结构体结合"></a>2. 与结构体结合</h2><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">IpAddr</span> <span class="token punctuation">{</span>    kind<span class="token punctuation">:</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">,</span>    address<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> home <span class="token operator">=</span> <span class="token class-name">IpAddr</span> <span class="token punctuation">{</span>        kind<span class="token punctuation">:</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">::</span><span class="token constant">V4</span><span class="token punctuation">,</span>        address<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> loopback <span class="token operator">=</span> <span class="token class-name">IpAddr</span> <span class="token punctuation">{</span>        kind<span class="token punctuation">:</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">::</span><span class="token constant">V6</span><span class="token punctuation">,</span>        address<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"::1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-将数据附加到枚举的变体中"><a href="#3-将数据附加到枚举的变体中" class="headerlink" title="3. 将数据附加到枚举的变体中"></a>3. 将数据附加到枚举的变体中</h2><p>可以在枚举的变体中嵌入任意的数据类型。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">IpAddr</span> <span class="token punctuation">{</span>    <span class="token constant">V4</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token constant">V6</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">enum</span> <span class="token type-definition class-name">IpAddr</span> <span class="token punctuation">{</span>    <span class="token constant">V4</span><span class="token punctuation">(</span><span class="token keyword">u8</span><span class="token punctuation">,</span> <span class="token keyword">u8</span><span class="token punctuation">,</span> <span class="token keyword">u8</span><span class="token punctuation">,</span> <span class="token keyword">u8</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token constant">V6</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> home <span class="token operator">=</span> <span class="token class-name">IpAddr</span><span class="token punctuation">::</span><span class="token constant">V4</span><span class="token punctuation">(</span><span class="token number">127</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> loopback <span class="token operator">=</span> <span class="token class-name">IpAddr</span><span class="token punctuation">::</span><span class="token constant">V6</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"::1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>不需要额外使用 struct；</li><li>每个变体可以拥有不同的类型以及关联的数据量。</li></ul><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">Message</span> <span class="token punctuation">{</span>    <span class="token class-name">Quit</span><span class="token punctuation">,</span>  <span class="token comment">// 无任何数据</span>    <span class="token class-name">Move</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span><span class="token keyword">i32</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span><span class="token keyword">i32</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 匿名结构体</span>    <span class="token class-name">Write</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// 字符串</span>    <span class="token class-name">ChangeColor</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// i32</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> q <span class="token operator">=</span> <span class="token class-name">Message</span><span class="token punctuation">::</span><span class="token class-name">Quit</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token class-name">Message</span><span class="token punctuation">::</span><span class="token class-name">Move</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> w <span class="token operator">=</span> <span class="token class-name">Message</span><span class="token punctuation">::</span><span class="token class-name">Write</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token class-name">Message</span><span class="token punctuation">::</span><span class="token class-name">ChangeColor</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-定义方法"><a href="#4-定义方法" class="headerlink" title="4. 定义方法"></a>4. 定义方法</h2><p>使用 impl 关键字。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">Message</span> <span class="token punctuation">{</span>    <span class="token class-name">Quit</span><span class="token punctuation">,</span>  <span class="token comment">// 无任何数据</span>    <span class="token class-name">Move</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span><span class="token keyword">i32</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span><span class="token keyword">i32</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 匿名结构体</span>    <span class="token class-name">Write</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// 字符串</span>    <span class="token class-name">ChangeColor</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// i32</span><span class="token punctuation">}</span><span class="token keyword">impl</span> <span class="token class-name">Message</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">call</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> q <span class="token operator">=</span> <span class="token class-name">Message</span><span class="token punctuation">::</span><span class="token class-name">Quit</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token class-name">Message</span><span class="token punctuation">::</span><span class="token class-name">Move</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> w <span class="token operator">=</span> <span class="token class-name">Message</span><span class="token punctuation">::</span><span class="token class-name">Write</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token class-name">Message</span><span class="token punctuation">::</span><span class="token class-name">ChangeColor</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    m<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、Option-枚举"><a href="#二、Option-枚举" class="headerlink" title="二、Option 枚举"></a>二、Option 枚举</h1><p>定义于标准库中，表示某个值可能存在（某种类型）或不存在的情况。因为 Rust 没有 Null，所以提供了类似与 Null 概念的枚举：Option&lt;T&gt;。</p><p>标准库中的定义为：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>    <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token class-name">None</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token comment">// 使用</span><span class="token keyword">let</span> some_number <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 类型：Option&lt;i32&gt;</span><span class="token keyword">let</span> some_string <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 类型：Option&lt;&amp;str&gt;</span><span class="token keyword">let</span> number<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token class-name">None</span><span class="token punctuation">;</span>  <span class="token comment">// 需要显示指定类型，None 无法推导出类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相较于 Null，使用 Option&lt;T&gt; 使用上更加安全。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> a<span class="token punctuation">:</span> <span class="token keyword">i32</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">let</span> b<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>  <span class="token comment">// error: i32 无法与 Option&lt;i32&gt; 相加</span><span class="token comment">// 在其他语言中</span><span class="token comment">// String a = Null;</span><span class="token comment">// String b = a + "world";  // 可以编译通过，只有在运行期间才可能发现该错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、match-运算符⭐"><a href="#三、match-运算符⭐" class="headerlink" title="三、match 运算符⭐"></a>三、match 运算符⭐</h1><h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h2><p>允许一个值与一系列模式进行匹配，并执行匹配的模式对应的代码，模式可以是字面值、变量名、通配符等。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">Coin</span> <span class="token punctuation">{</span>    <span class="token class-name">Penny</span><span class="token punctuation">,</span>    <span class="token class-name">Nickel</span><span class="token punctuation">,</span>    <span class="token class-name">Dime</span><span class="token punctuation">,</span>    <span class="token class-name">Quarter</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">value_in_cents</span><span class="token punctuation">(</span>coin<span class="token punctuation">:</span> <span class="token class-name">Coin</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u8</span> <span class="token punctuation">{</span>    <span class="token keyword">match</span> coin <span class="token punctuation">{</span>        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Penny</span> <span class="token operator">=&gt;</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token comment">// 匹配到对应的值后，执行 =&gt; 后的代码</span>        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Nickel</span> <span class="token operator">=&gt;</span> <span class="token number">5</span><span class="token punctuation">,</span>        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Dime</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token comment">// 多行代码需要使用 {}</span>            <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Dime"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token number">10</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Quarter</span> <span class="token operator">=&gt;</span> <span class="token number">25</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>匹配的分支可以绑定到被匹配对象的部分值，可以从 enum 变体中提取值。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><span class="token keyword">enum</span> <span class="token type-definition class-name">UsState</span> <span class="token punctuation">{</span>    <span class="token class-name">Alabama</span><span class="token punctuation">,</span>    <span class="token class-name">Alaska</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">enum</span> <span class="token type-definition class-name">Coin</span> <span class="token punctuation">{</span>    <span class="token class-name">Penny</span><span class="token punctuation">,</span>    <span class="token class-name">Nickel</span><span class="token punctuation">,</span>    <span class="token class-name">Dime</span><span class="token punctuation">,</span>    <span class="token class-name">Quarter</span><span class="token punctuation">(</span><span class="token class-name">UsState</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">value_in_cents</span><span class="token punctuation">(</span>coin<span class="token punctuation">:</span> <span class="token class-name">Coin</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u8</span> <span class="token punctuation">{</span>    <span class="token keyword">match</span> coin <span class="token punctuation">{</span>        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Penny</span> <span class="token operator">=&gt;</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Nickel</span> <span class="token operator">=&gt;</span> <span class="token number">5</span><span class="token punctuation">,</span>        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Dime</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>            <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Dime"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token number">10</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Quarter</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>            <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"State quarter from {:?}"</span><span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token number">25</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> ss <span class="token operator">=</span> <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Quarter</span><span class="token punctuation">(</span><span class="token class-name">UsState</span><span class="token punctuation">::</span><span class="token class-name">Alaska</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token function">value_in_cents</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-匹配-Option-lt-T-gt"><a href="#2-匹配-Option-lt-T-gt" class="headerlink" title="2. 匹配 Option<T>"></a>2. 匹配 Option&lt;T&gt;</h2><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">test</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">match</span> x <span class="token punctuation">{</span>        <span class="token class-name">None</span> <span class="token operator">=&gt;</span> <span class="token class-name">None</span><span class="token punctuation">,</span>        <span class="token class-name">Some</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> five <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> six <span class="token operator">=</span> <span class="token function">test</span><span class="token punctuation">(</span>five<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> none <span class="token operator">=</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">None</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-必须穷举所有的可能"><a href="#3-必须穷举所有的可能" class="headerlink" title="3. 必须穷举所有的可能"></a>3. 必须穷举所有的可能</h2><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">test</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">match</span> x <span class="token punctuation">{</span>        <span class="token class-name">Some</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码会编译失败，因为没有对 None 进行处理。解决方案为：<strong>使用“ _”通配符，替代其余没列出的可能值。</strong>通配符必须要放在最后。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token number">1u8</span><span class="token punctuation">;</span><span class="token keyword">match</span> v <span class="token punctuation">{</span>    <span class="token number">1</span> <span class="token operator">=&gt;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token number">3</span> <span class="token operator">=&gt;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token number">5</span> <span class="token operator">=&gt;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"five"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token number">7</span> <span class="token operator">=&gt;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"seven"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    _ <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// 放在最后，无操作</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、if-let"><a href="#四、if-let" class="headerlink" title="四、if let"></a>四、if let</h1><p>match 的语法糖，只关心一种匹配而忽略其它匹配的情况。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">0u8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">match</span> v <span class="token punctuation">{</span>    <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    _ <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token comment">// 等价的 if let</span><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> v <span class="token punctuation">{</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"other"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础-结构体(Rust)</title>
      <link href="/2023/03/29/48131.html"/>
      <url>/2023/03/29/48131.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>结构体是自定义的数据类型，使用 <strong>struct</strong> 关键字。</p><pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">struct User {    name: String,    age: u64,    sex: u8,    email: String,    active: bool,  // 最后一个字段的 ',' 可有可无}  // 注意：最后无分号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><ul><li>必须为每个字段指定具体值；</li><li>无需按声明的顺序进行指定；</li></ul><pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">let user1 = User {    name: String::from("bob"),    active: false,    email: String::from("bob@gmail.com"),    age: 25,    sex: 1  // 最后一个的 ',' 可有可无};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>获取/修改 struct 里面的某个值，使用点标记法；</li></ul><pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">fn main() {    // 可变实例    let mut user1 = User {        name: String::from("bob"),        active: false,        email: String::from("bob@gmail.com"),        age: 25,        sex: 1    };    // 读    println!("{}, {}, {}, {}, {}", user1.name, user1.email, user1.age, user1.sex, user1.active);    // 写    user1.age = 30;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>作为函数的返回值；</li></ul><pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">fn get_user(name: &amp;str) -&gt; User {  User {        email: String::from("test@test.com"),        age: 18,        name: name.to_string(),        active: false,        sex: 0,    }}// 当字段名和字段值对应变量名相同时，就可以使用字段初始化简写的方式fn get_user(name: &amp;str, email: String, age: u64) -&gt; User {  User {        email,        age,        name: name.to_string(),        active: false,        sex: 0,    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>更新语法</li></ul><p>基于某个 struct 实例来创建一个新实例的时候，可以使用更新语法。<strong>但会导致旧实例中部分值失效</strong>。</p><pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">fn main() {    let user1 = User {        name: String::from("bob"),        active: false,        email: String::from("bob@bob.com"),        age: 35,        sex: 1    };        let user2 = User {        name: String::from("alice"),        ..user1  // 更新语法，此时 user1 的 email 被 move，访问 user1 该字段报错    };}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、tuple-struct"><a href="#三、tuple-struct" class="headerlink" title="三、tuple struct"></a>三、tuple struct</h2><p>定义类似 tuple 的 struct，该 struct 整体有名，但内部字段没名，只有类型，使用小括号，使用点索引进行访问。</p><pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">struct Color(i32, i32, i32);struct Point(i32, i32, i32);let white = Color(255, 255, 255);let point = Point(100, 0, 23);println!("{}, {}, {}", point.0, point.1, point.2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、Unit-Like-Struct"><a href="#四、Unit-Like-Struct" class="headerlink" title="四、Unit-Like Struct"></a>四、Unit-Like Struct</h2><p>没有任何字段的 struct。适用于在某个类型上实现某个 trait，但是又没有想要存储的数据。（空的 tuple struct）</p><h2 id="五、struct-数据的所有权"><a href="#五、struct-数据的所有权" class="headerlink" title="五、struct 数据的所有权"></a>五、struct 数据的所有权</h2><p>User.name 使用了 String 而不是 &amp;str：</p><ul><li>该 struct 实例拥有其所有的数据；</li><li>只要 struct 实例是有效的，那么里面的字段数据也是有效的。</li></ul><p>User.name 也可以是引用，但需要使用生命周期：</p><ul><li>生命周期保证只要 struct 实例是有效的，那么引用也是有效的；</li><li>如果不使用生命周期，则报错。</li></ul><p>生命周期在后面。</p><h2 id="六、方法"><a href="#六、方法" class="headerlink" title="六、方法"></a>六、方法</h2><p>与函数类似：</p><ul><li>方法是在 struct（或 enum、trait 对象）的上下文中定义；</li><li>第一个参数是 &amp;self，表示方法被调用的 struct 实例，也可以获得其所有权或可变借用；</li><li>使用关键字 impl，后跟结构体名；</li><li>可以有多个 impl 块。</li></ul><pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">impl User {    fn display(&amp;self) {  // self 可以是可变的，也可以获取所有权        println!("name: {}, age: {}, sex: {}, email: {}", self.name,            self.age, self.sex, self.email);    }    fn is_user(&amp;self, name: &amp;str) -&gt; bool {        self.name == name    }    fn is_active(&amp;self) -&gt; bool {        self.active    }}impl User {    fn set_active(&amp;mut self, active: bool) {  // self 可变的        self.active = active    }    fn change_age(&amp;mut self, age: u64) {        self.age = age    }}user1.display();if user1.is_active() {    println!("active");} else {    println!("not active");}user1.change_age(100);user1.display();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、关联函数"><a href="#七、关联函数" class="headerlink" title="七、关联函数"></a>七、关联函数</h2><p>在 impl 块内，第一个参数不是 self 的函数，像 String::from。</p><pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">impl User {    fn create_user(name: &amp;str, email: &amp;str) -&gt; User {        User {            name: name.to_string(),            email: email.to_string(),            active: true,            age: 20,            sex: 1        }    }}let user1 = User::create_user("bob", "bob@gmail.com");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础-切片⭐(Rust)</title>
      <link href="/2023/03/23/25258.html"/>
      <url>/2023/03/23/25258.html</url>
      
        <content type="html"><![CDATA[<p>另一个没有所有权的数据类型是 slice（切片）。slice 允许引用集合中一段连续的元素序列，而不用引用整个集合。</p><h2 id="字符串-slice"><a href="#字符串-slice" class="headerlink" title="字符串 slice"></a>字符串 slice</h2><p><strong>字符串 slice</strong> 是 <code>String</code> 中一部分值的引用。“字符串 slice” 的类型声明写作 <code>&amp;str</code>。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test for string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 也可写作 &amp;s[..4]</span><span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">..</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 也可写作 &amp;s[9..]</span><span class="token keyword">let</span> s3 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 也可写作 &amp;s[0..15]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用一个由中括号中的 <code>[starting_index..ending_index]</code> 指定的 range 创建一个 slice，其中 <code>starting_index</code> 是 slice 的第一个位置，<code>ending_index</code> 则是 slice 最后一个位置的后一个值。<strong>编译器会确保指向 String 的引用持续有效</strong>。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>  <span class="token comment">// s1 的类型就是字符串切片</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test for string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">first_world</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// error: 下面使用了 result</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ok</span><span class="token punctuation">}</span><span class="token comment">// 使用 &amp;str 作为函数参数，可以同时接收 String 和 &amp;str 类型的参数</span><span class="token keyword">fn</span> <span class="token function-definition function">first_world</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> bytes <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>item<span class="token punctuation">)</span> <span class="token keyword">in</span> bytes<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> item <span class="token operator">==</span> <span class="token char">b' '</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符串字面值就是 slice。</p><h2 id="其他类型的-slice"><a href="#其他类型的-slice" class="headerlink" title="其他类型的 slice"></a>其他类型的 slice</h2><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础-引用与借用⭐(Rust)</title>
      <link href="/2023/03/22/11818.html"/>
      <url>/2023/03/22/11818.html</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token punctuation">(</span>s1<span class="token punctuation">,</span> len<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">calculate_length</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> length <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span>s<span class="token punctuation">,</span> length<span class="token punctuation">)</span>  <span class="token comment">// 使用元组来返回多个值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的代码中有这样一个问题：必须将 <code>String</code> 返回给调用函数，以便在调用 <code>calculate_length</code> 后仍能使用 <code>String</code>，因为 <code>String</code> 被移动到了 <code>calculate_length</code> 内。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> len <span class="token operator">=</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 参数类型声明为 String 的引用，这样不会使 s1 失效</span><span class="token keyword">fn</span> <span class="token function-definition function">calculate_length</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">usize</span> <span class="token punctuation">{</span>    s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>  <span class="token comment">// 当引用停止使用时并不丢弃它指向的数据，因为没有所有权</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&amp; 符号就是<strong>引用</strong>，它们允许使用值但不获取其所有权；将创建一个引用的行为称为<strong>借用</strong>。</p><p>正如变量默认是不可变的，引用也一样。（默认）<strong>不允许修改引用的值</strong>。</p><p><img src="/pic%5C11818_001.png"></p><h2 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h2><p>在引用类型前加 mut 关键字，则变为可变引用。</p><p>可变引用的限制：<strong>在特定作用域内，只能有一个对某一特定数据的可变引用</strong>。这样做的好处是在编译时防止数据竞争。</p><p>以下三种行为下会发生数据竞争：</p><ul><li>两个或多个指针同时访问同一个数据</li><li>至少有一个指针用于写入数据</li><li>没有使用任何机制来同步对数据的访问</li></ul><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">change</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 可变引用</span>        <span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span>    <span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span>  <span class="token comment">// error：同时有两个可变引用</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}, {}"</span><span class="token punctuation">,</span> r1<span class="token punctuation">,</span> r2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">change</span><span class="token punctuation">(</span>some_string<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 声明为可变引用</span>    some_string<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">", world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>不可以同时拥有一个可变引用和一个不变的引用</strong>。多个不变的引用是可以的。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span> <span class="token comment">// ok</span><span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span> <span class="token comment">// ok</span><span class="token keyword">let</span> r3 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span> <span class="token comment">// error</span><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{} {} {}"</span><span class="token punctuation">,</span> r1<span class="token punctuation">,</span> r2<span class="token punctuation">,</span> r3<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span> <span class="token comment">// 没问题</span><span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span> <span class="token comment">// 没问题</span><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{} and {}"</span><span class="token punctuation">,</span> r1<span class="token punctuation">,</span> r2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 此位置之后 r1 和 r2 不再使用</span><span class="token keyword">let</span> r3 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span> <span class="token comment">// 没问题</span><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> r3<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译器在作用域结束之前判断不再使用的引用的能力被称为非词法作用域生命周期（Non-Lexical Lifetimes，简称NLL）。</p><h2 id="悬空引用"><a href="#悬空引用" class="headerlink" title="悬空引用"></a>悬空引用</h2><p>悬空指针：一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其它人使用了。</p><p>在 Rust 里，编译器可保证<strong>引用永远都不是悬空引用</strong>：如果你引用了某些数据，编译器将保证在引用离开作用域之前数据不会离开作用域。示例会编译失败。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> r <span class="token operator">=</span> <span class="token function">dangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">dangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token class-name">String</span> <span class="token punctuation">{</span>  <span class="token comment">// error: missing lifetime specifier</span>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>s<span class="token punctuation">}</span>  <span class="token comment">// s 被销毁，但返回了 s 的引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="引用的规则"><a href="#引用的规则" class="headerlink" title="引用的规则"></a>引用的规则</h2><ul><li>在任意给定时间，<strong>要么</strong>只能有一个可变引用，<strong>要么</strong>只能有多个不可变引用</li><li>引用必须总是有效的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础-所有权⭐(Rust)</title>
      <link href="/2023/03/15/32876.html"/>
      <url>/2023/03/15/32876.html</url>
      
        <content type="html"><![CDATA[<p>所有权（系统）是 Rust 最为与众不同的特性，它让 Rust 无需垃圾回收（garbage collector）即可保障内存安全。</p><p>Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。</p><h2 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h2><ul><li>Rust 中的每一个值都有一个被称为其<strong>所有者</strong>（<em>owner</em>）的变量</li><li>值在任一时刻有且只有一个所有者</li><li>当所有者（变量）离开作用域，这个值将被丢弃（调用 drop 函数）</li></ul><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token punctuation">{</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>  <span class="token comment">// 字符串字面值，即被硬编码进程序里的字符串值，不可变</span>    <span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>  <span class="token comment">// s1 还是有效的</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> s3 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// String，这个类型管理被分配到堆上的数据，可变</span>    s3<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">", world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// "hello, world"</span><span class="token punctuation">}</span>  <span class="token comment">// s3 申请的内存会被释放</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数据交互方式"><a href="#数据交互方式" class="headerlink" title="数据交互方式"></a>数据交互方式</h2><ul><li>移动</li></ul><p>栈上的数据就是简单的拷贝；而堆上的数据则采用移动的方式。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>  <span class="token comment">// 赋值后，s1 失效</span><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}, {}"</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// error s1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Rust 永远不会自动创建数据的“深拷贝”。因此，任何<strong>自动</strong>的复制可以被认为对运行时性能影响较小。</p><ul><li>克隆</li></ul><p>当需要深度复制 <code>String</code> 中堆上的数据时，使用 clone 方法。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}, {}"</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// OK</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>Rust 有一个叫做 Copy trait 的特殊方法，可以用在类似整型这样的存储在栈上的类型。如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。</p><p>如果一个类型或者该类型的一部分实现了 Drop trait，那么 Rust 不允许让它再去实现 Copy trait。</p><p>任何简单标量的组合类型都可以实现 Copy；任何不需要分配内存或某种资源的类型都可以实现 Copy 。如下是一些 Copy 的类型：</p><ul><li>所有整数类型</li><li>布尔类型</li><li>所有浮点数类型</li><li>字符类型</li><li>元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，<code>(i32, i32)</code> 实现了 Copy，但 <code>(i32, String)</code> 就没有。</li></ul><h2 id="所有权与函数"><a href="#所有权与函数" class="headerlink" title="所有权与函数"></a>所有权与函数</h2><p>将值传递给函数在语义上与给变量赋值相似，向函数传递值可能会移动或者复制，就像赋值语句一样。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">takes_ownership</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// s 的值移动到函数里</span>    <span class="token comment">// s 失效</span>        <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token function">makes_copy</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// x 任然有效</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">takes_ownership</span><span class="token punctuation">(</span>some<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> some<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment">// some 失效，调用 'drop' 方法，释放内存</span><span class="token keyword">fn</span> <span class="token function-definition function">makes_copy</span><span class="token punctuation">(</span>some<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> some<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment">// 无任何操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="所有权与返回值"><a href="#所有权与返回值" class="headerlink" title="所有权与返回值"></a>所有权与返回值</h2><p>返回值也可以转移所有权。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// gives_ownership 将返回值的所有权移给 s1</span>    <span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> s3 <span class="token operator">=</span> <span class="token function">takes_and_gives_back</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// s2 被移动到 takes_and_gives_back 中,</span>                                        <span class="token comment">// 返回值移给 s3</span><span class="token punctuation">}</span> <span class="token comment">// s1, s3 会释放内存，s2 已被移走，无操作</span><span class="token keyword">fn</span> <span class="token function-definition function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> some_string <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    some_string  <span class="token comment">// 返回 some_string 并移出给调用的函数</span><span class="token punctuation">}</span>  <span class="token comment">// 无内存的释放</span><span class="token keyword">fn</span> <span class="token function-definition function">takes_and_gives_back</span><span class="token punctuation">(</span>a_string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>    a_string  <span class="token comment">// 返回 a_string 并移出给调用的函数</span><span class="token punctuation">}</span>  <span class="token comment">// 无内存的释放</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>变量的所有权总是遵循相同的模式：</p><ul><li>将一个值赋给另一个变量时就会发生移动。</li><li>当持有堆数据的变量离开作用域时，其值将通过 <code>drop</code> 函数被清理掉，除非数据的所有权移动到另一个变量上。</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>函数参数传递时，如何不改变实参的所有权？</p><p>答：详见引用</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础-类型、控制(Rust)</title>
      <link href="/2023/03/09/28274.html"/>
      <url>/2023/03/09/28274.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、习惯"><a href="#一、习惯" class="headerlink" title="一、习惯"></a>一、习惯</h2><p>Rust 代码中的函数和变量名使用 snake case 规范风格，所有字母都是小写并使用下划线分隔单词。</p><p>Rust 常量使用全大写字母，每个单词之间用下划线分开。</p><h2 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h2><p><strong>Rust 是强类型语言，但具有自动判断变量类型的能力，可以省略变量的类型</strong>。</p><p>语法：<code>let [mut] name [: type] = value;</code></p><p>声明变量使用 <code>let</code> 关键字，默认情况下，<strong>变量是不可变的</strong>。声明时，在变量前面加上 <code>mut</code> 关键字，就可以使变量可变。</p><p><strong>注释</strong>使用 “//“。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment">// 变量 a 不可变</span>a <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>  <span class="token comment">// error：不允许修改</span><span class="token keyword">let</span> <span class="token keyword">mut</span> b <span class="token punctuation">:</span> <span class="token keyword">u32</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment">// 变量 b 可变</span>b <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>  <span class="token comment">// ok</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、常量"><a href="#三、常量" class="headerlink" title="三、常量"></a>三、常量</h2><p>常量在绑定值以后也是<strong>不可变</strong>的，但是它与不可变的变量有很多区别：</p><ul><li>不可以使用 <code>mut</code> 关键字，常量永远都是不可变的</li><li>声明常量使用 <code>const</code> 关键字，常量的<strong>类型必须被标注</strong></li><li>常量可以在任何作用域内进行声明，包括全局作用域</li><li><strong>常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值</strong></li></ul><p>在程序运行期间，常量在其声明的作用域内一直有效。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">const</span> <span class="token constant">MAX_POINTS</span><span class="token punctuation">:</span> <span class="token keyword">u32</span> <span class="token operator">=</span> <span class="token number">100_000</span><span class="token punctuation">;</span>  <span class="token comment">// _ 是分隔符</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The value is {}"</span><span class="token punctuation">,</span> <span class="token constant">MAX_POINTS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// The value is 123.123</span>    <span class="token keyword">const</span> <span class="token constant">MAX_POINTS</span><span class="token punctuation">:</span> <span class="token keyword">f32</span> <span class="token operator">=</span> <span class="token number">123.123</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The value is {}"</span><span class="token punctuation">,</span> <span class="token constant">MAX_POINTS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// The value is 123.123</span>    <span class="token comment">// let MAX_POINTS = 123;  // error</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><input disabled="" type="checkbox"> 疑问1：全局作用域中的 MAX_POINTS(u32) 并没有被使用到，难道常量有效性从所在作用域的起始位置生效，不论在该作用域内何处声明该常量？小作用域的常量会覆盖大作用域的常量？（测试结果是小作用域的常量覆盖了大作用域的常量）</li><li><input disabled="" type="checkbox"> 疑问2：若已定义常量，则不可定义同名变量？（测试结果是编译失败，报错）</li></ul><h2 id="四、隐藏-shadow"><a href="#四、隐藏-shadow" class="headerlink" title="四、隐藏(shadow)"></a>四、隐藏(shadow)</h2><p>可以使用相同的名字声明新的变量，新的变量就会 shadow（隐藏）之前声明的同名变量，在后续的代码中这个变量名代表的就是新的变量。</p><p>shadow 和变量标记为 <code>mut</code> 是不一样的：</p><ul><li>如果不使用 <code>let</code> 关键字，那么重新给非 <code>mut</code> 的变量赋值会导致编译错误</li></ul><p>使用 <code>let</code> 声明的同名新变量，也是不可变的，但是<strong>类型可以与之前不同</strong>。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello variables shadow"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 类型 字符串</span>    <span class="token keyword">let</span> name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 类型 usize(整数)</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"length is {}"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// length is 22</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、数据类型"><a href="#五、数据类型" class="headerlink" title="五、数据类型"></a>五、数据类型</h2><p>标量和复合类型</p><ul><li>Rust 是静态编译语言，在编译时必须知道所有变量的类型</li><li>基于使用的值，编译器通常能够推断出它的具体类型</li><li>如果可能的类型比较多，就必须添加类型的标注，否则编译会报错</li></ul><h3 id="1-标量类型"><a href="#1-标量类型" class="headerlink" title="1. 标量类型"></a>1. 标量类型</h3><p>一个标量类型代表一个单个的值，Rust 有四个主要的标量类型：</p><ul><li>整数类型：i8, u8, i16, u16, i32, u32, i64, u64, i128, u128, isize, usize<ul><li>无符号整数类型以 u 开头</li><li>有符号整数类型以 i 开头</li><li>isize 和 usize 类型的位数由程序运行的计算机的架构所决定</li><li>允许使用<code>_</code>做为分隔符以方便读数</li></ul></li><li>浮点类型：f32，32 位，单精度；f64，64 位，双精度</li><li>布尔类型：bool，有两个值 true 和 false，一个字节大小</li><li>字符类型：char，字面值使用单引号，占用 4 字节大小<ul><li>Unicode 标量值，可以表示比 ASCII 多得多的字符内容：拼音、中日韩文、零<br>长度空白字符、emoji 表情等</li></ul></li></ul><h3 id="2-复合类型"><a href="#2-复合类型" class="headerlink" title="2. 复合类型"></a>2. 复合类型</h3><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组是一个将多个其他类型的值组合进一个复合类型的主要方式。元组长度固定：一旦声明，其长度不会增大或缩小。</p><p>使用包含在<strong>圆括号中的逗号分隔</strong>的值列表来创建一个元组。元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> tup<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">f64</span><span class="token punctuation">,</span> <span class="token keyword">u8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">6.4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6.6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 在小括号里，将值用逗号分开</span>    <span class="token comment">// 获取 Tuple 的元素值</span>    <span class="token comment">// 模式匹配</span>    <span class="token keyword">let</span> <span class="token punctuation">(</span>x1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> x3<span class="token punctuation">,</span> x4<span class="token punctuation">,</span> x5<span class="token punctuation">)</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}, {}, {}, {}, {}"</span><span class="token punctuation">,</span> x1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> x3<span class="token punctuation">,</span> x4<span class="token punctuation">,</span> x5<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 在 tuple 变量使用点标记法，后接元素的索引号</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}, {}, {}, {}, {}"</span><span class="token punctuation">,</span> t<span class="token number">.0</span><span class="token punctuation">,</span> t<span class="token number">.1</span><span class="token punctuation">,</span> t<span class="token number">.2</span><span class="token punctuation">,</span> t<span class="token number">.3</span><span class="token punctuation">,</span> t<span class="token number">.4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不带任何值的元组有个特殊的名称，被称为<strong>单元元组</strong>，这种值以及对应的类型都写作 <code>()</code>，表示空值或空的返回类型。如果表达式不返回任何其他值，则会隐式返回单元值。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组也可以将多个值放在一个类型里，但每个元素的类型必须相同，长度也是固定的。</p><p>将数组的值写成在<strong>方括号内</strong>，用逗号分隔。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> month <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Jan."</span><span class="token punctuation">,</span> <span class="token string">"Feb."</span><span class="token punctuation">,</span> <span class="token string">"Mar."</span><span class="token punctuation">,</span> <span class="token string">"Apr."</span><span class="token punctuation">,</span> <span class="token string">"May."</span><span class="token punctuation">,</span> <span class="token string">"Jun."</span><span class="token punctuation">,</span> <span class="token string">"Jul."</span><span class="token punctuation">,</span>        <span class="token string">"Aug."</span><span class="token punctuation">,</span> <span class="token string">"Sep."</span><span class="token punctuation">,</span> <span class="token string">"Oct."</span><span class="token punctuation">,</span> <span class="token string">"Nov."</span><span class="token punctuation">,</span> <span class="token string">"Dec."</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> a<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">i32</span><span class="token punctuation">;</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// let a = [3, 3, 3, 3, 3];</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}, {}"</span><span class="token punctuation">,</span> month<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> month<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h2><p>声明函数使用 <code>fn</code> 关键字，Rust 不关心函数定义于何处，只要定义了就行。</p><p><strong>参数</strong>：在函数签名里，必须声明每个参数的类型。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"main"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">test</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"x is {}, y is {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>函数体中的语句与表达式</strong>，函数体由一系列的语句和一个可选的结尾表达式构成。</p><p>Rust 是一个基于表达式的语言。</p><ul><li><strong>语句</strong>（<em>Statements</em>）：执行一些操作但不返回值的指令，所以不可以使用 let 将一个语句赋给一个变量</li><li><strong>表达式</strong>（<em>Expressions</em>）：计算并产生一个值，表达式可以是语句的一部分</li></ul><p>表达式的结尾没有分号。如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token comment">// 语句</span>    <span class="token comment">// let x = (let y = 6);  // error, 即 rust 不允许 x = y = 6</span>    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        x <span class="token operator">+</span> <span class="token number">3</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 函数调用是一个表达式。宏调用是一个表达式。用大括号创建的一个新的块作用域也是一个表达式。</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The value of y is {}"</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 6</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>函数的返回值</strong></p><p>在 -&gt; 符号后边声明函数返回值的类型，但是不可以为返回值命名。</p><p>在 Rust 里面，函数的返回值等同于函数体最后一个表达式的值。使用 <code>return</code> 关键字，可从函数中提前返回；但大部分函数隐式的返回最后的表达式。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token function">test2</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The value of x is {}, y is {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token punctuation">{</span>    <span class="token number">10</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">test2</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">100</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">500</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        x <span class="token operator">+</span> <span class="token number">5</span>  <span class="token comment">// 加上 ';', 编译会报错</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、控制流"><a href="#七、控制流" class="headerlink" title="七、控制流"></a>七、控制流</h2><h3 id="1-if-表达式"><a href="#1-if-表达式" class="headerlink" title="1. if 表达式"></a>1. if 表达式</h3><p>if 表达式允许根据条件来执行不同的代码分支，<strong>这个条件必须是 bool 值</strong>。可选的，在后边可以加上一个 else 表达式或 else if 表达式。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> number <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> number <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"number is divisible by 4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> number <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"number is divisible by 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> number <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"number is divisible by 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"number is not divisible by 4, 3 or 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为 if 是一个表达式，所以可以在 let 语句的右侧使用它。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> condition <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> number <span class="token operator">=</span> <span class="token keyword">if</span> condition <span class="token punctuation">{</span> <span class="token number">5</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"number val is {}"</span><span class="token punctuation">,</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// number val is 5</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><ul><li>代码块的值是其最后一个表达式的值</li><li>if 表达式返回的类型必须是一样的</li></ul><h3 id="2-loop-表达式"><a href="#2-loop-表达式" class="headerlink" title="2. loop 表达式"></a>2. loop 表达式</h3><p>反复的执行一块代码，<code>break</code> 关键字停止循环。<code>continue</code> 关键字告诉程序跳过这个循环迭代中的任何剩余代码，并转到下一个迭代。</p><p>如果存在嵌套循环，<code>break</code> 和 <code>continue</code> 应用于此时最内层的循环。可以选择在一个循环上指定一个<strong>循环标签</strong>（<em>loop label</em>），然后将标签与 <code>break</code> 或 <code>continue</code> 一起使用，使这些关键字应用于已标记的循环而不是最内层的循环。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token lifetime-annotation symbol">'counting_up</span><span class="token punctuation">:</span> <span class="token keyword">loop</span> <span class="token punctuation">{</span>   <span class="token comment">// 该 loop 循环有标签</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"count = {}"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> remaining <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">loop</span> <span class="token punctuation">{</span>            <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"remaining = {}"</span><span class="token punctuation">,</span> remaining<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> remaining <span class="token operator">==</span> <span class="token number">9</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment">// 中止内层的 loop</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> count <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span> <span class="token lifetime-annotation symbol">'counting_up</span><span class="token punctuation">;</span>  <span class="token comment">// 中止最外层的 loop</span>            <span class="token punctuation">}</span>            remaining <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        count <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"End count = {}"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为 loop 也是一个表达式，所以也可以在 let 语句的右侧使用它。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">loop</span> <span class="token punctuation">{</span>        counter <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> counter <span class="token operator">==</span> <span class="token number">10</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span> counter <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The result is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// The result is 20</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-while-循环语句"><a href="#3-while-循环语句" class="headerlink" title="3. while 循环语句"></a>3. while 循环语句</h3><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> number <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> number <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span>        number <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"over"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-for-循环语句"><a href="#4-for-循环语句" class="headerlink" title="4. for 循环语句"></a>4. for 循环语句</h3><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// for 非常方便的遍历集合</span>    <span class="token keyword">for</span> elem <span class="token keyword">in</span> a<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// elem: &amp;i32</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p>标准库提供的类型，用来生成从一个数字开始到另一个数字之前结束的所有数字的序列。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// rev 方法可以反转 range</span>    <span class="token keyword">for</span> number <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rev</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3  2  1</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础-环境(Rust)</title>
      <link href="/2023/03/08/54164.html"/>
      <url>/2023/03/08/54164.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、安装、运行相关"><a href="#一、安装、运行相关" class="headerlink" title="一、安装、运行相关"></a>一、安装、运行相关</h1><ul><li><p>更新 Rust：rustup update</p></li><li><p>卸载 Rust：rustup self uninstall</p></li><li><p>版本：rustc –version</p></li><li><p>文档：rustup doc</p></li><li><p>编译：rustc main.rs</p></li></ul><h1 id="二、Cargo"><a href="#二、Cargo" class="headerlink" title="二、Cargo"></a>二、Cargo</h1><p>cargo 是 Rust 的构建系统和包管理工具，用于构建代码、下载依赖的库、构建库…</p><ul><li>版本：cargo –version</li><li>创建项目：cargo new 项目名称</li><li>构建 Cargo 项目：cargo build [–release]</li><li>构建和运行 Cargo 项目：cargo run</li><li>检查代码：cargo check</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2022/06/26/60251.html"/>
      <url>/2022/06/26/60251.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、NoSQL"><a href="#一、NoSQL" class="headerlink" title="一、NoSQL"></a>一、NoSQL</h2><p>NoSQL：一类新出现的数据库（not only sql）</p><ul><li>泛指非关系型数据库；</li><li>不支持 SQL 语法；</li><li>存储结构跟传统关系型数据库中的那种关系表完全不同，NoSQL 中存储的数据都是 KV 形式；</li><li>NoSQL 的世界中没有一种通用的语言，每种 NoSQL 数据库都有自己的 API 和语法，以及擅长的业务场景；</li><li>NoSQL 中的产品种类：Redis、Mongodb 等。</li></ul><h2 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h2><ul><li>Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用；</li><li>Redis 不仅仅支持简单的 key-value 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储；</li><li>Redis 支持数据的备份，即 master-slave 模式的数据备份。</li></ul><h2 id="三、数据类型"><a href="#三、数据类型" class="headerlink" title="三、数据类型"></a>三、数据类型</h2><p>Redis 默认有 16 个数据库，通过 0-15 标识，默认选择第一个数据库。<code>select 10</code></p><ul><li>字符串 string</li><li>哈希 hash</li><li>列表 list</li><li>集合 set</li><li>有序集合 zset</li></ul><p>key 不能重复</p><h3 id="3-1-string"><a href="#3-1-string" class="headerlink" title="3.1 string"></a>3.1 string</h3><p>字符串类型是 Redis 中最基础的数据存储类型，它在 Redis 中是二进制安全的，这意味着该类型可以接受任何格式的数据，如 JPEG 图像数据或 json 数据等。在 Redis 中字符串类型的 Value 最多可以容纳的数据长度是 512M。</p><h4 id="3-1-1-添加、修改"><a href="#3-1-1-添加、修改" class="headerlink" title="3.1.1 添加、修改"></a>3.1.1 添加、修改</h4><p>如果设置的键不存在则为添加，如果已存在则为修改。</p><p><strong>语法</strong>：<code>set key value</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">set name helloset name world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Redis 的 key 可以设置过期时间，到期后该键值对失效。</p><p><strong>语法</strong>：<code>setex key seconds value</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">setex name 5 hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置多个键值对</p><p><strong>语法</strong>：<code>mset key1 value1 key2 value2 ...</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">mset name1 hello name2 world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-1-2-获取"><a href="#3-1-2-获取" class="headerlink" title="3.1.2 获取"></a>3.1.2 获取</h4><p>根据键获取值，如果不存在则返回 nil</p><p><strong>语法</strong>：<code>get key</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">set name helloget name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>根据多个键获取多个值</p><p><strong>语法</strong>：<code>mget key1 key2 ...</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">mset name1 hello name2 worldmget name1 name2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-1-3-删除"><a href="#3-1-3-删除" class="headerlink" title="3.1.3 删除"></a>3.1.3 删除</h4><p>删除键及对应的值</p><p><strong>语法</strong>：<code>del key1 key2 ...</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">set name hellodel name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-2-hash"><a href="#3-2-hash" class="headerlink" title="3.2 hash"></a>3.2 hash</h3><p>hash 是一个 string 类型的 field（字段）和 value（值）的映射表，hash 特别适合用于存储对象。</p><h4 id="3-2-1-添加、修改"><a href="#3-2-1-添加、修改" class="headerlink" title="3.2.1 添加、修改"></a>3.2.1 添加、修改</h4><p><strong>语法</strong>：<code>hset key field1 value1 field2 value2 ...</code></p><p><code>hmset key field1 value1 field2 value2 ... </code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">hset name a 1 b 2 c 3 d 4hset name a 5 b 2 c 3 d 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-2-2-获取"><a href="#3-2-2-获取" class="headerlink" title="3.2.2 获取"></a>3.2.2 获取</h4><p>获取指定键的所有属性</p><p><strong>语法</strong>：<code>hkeys key</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">hkeys name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取指定键的一个属性的值</p><p><strong>语法</strong>：<code>hget key field</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">hget name a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取指定键的多个属性的多个值</p><p><strong>语法</strong>：<code>hmget key field1 field2</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">hmget name a b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取指定键的所有属性的值</p><p><strong>语法</strong>：<code>hvals key</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">hvals name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-2-3-删除"><a href="#3-2-3-删除" class="headerlink" title="3.2.3 删除"></a>3.2.3 删除</h4><p>删除整个键值对，使用 del 命令。</p><p>删除指定键的某些属性</p><p><strong>语法</strong>：<code>hdel key field1 field2</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">hdel name a b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-3-list"><a href="#3-3-list" class="headerlink" title="3.3 list"></a>3.3 list</h3><p>list 是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><h4 id="3-3-1-增加"><a href="#3-3-1-增加" class="headerlink" title="3.3.1 增加"></a>3.3.1 增加</h4><p>左侧插入数据</p><p><strong>语法</strong>：<code>lpush key value1 value2 ...</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">lpush name 1 2 3内存中：3 2 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>右侧插入数据</p><p><strong>语法</strong>：<code>rpush key value1 value2 ...</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">rpush name 4 5 6内存中 4 5 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-3-2-获取"><a href="#3-3-2-获取" class="headerlink" title="3.3.2 获取"></a>3.3.2 获取</h4><p>返回列表里指定范围内的元素</p><p><strong>语法</strong>：<code>lrange key start stop</code></p><p>start、stop 为元素的下标索引，索引从左侧开始，第一个元素为 0；索引可以是负数，表示从尾部开始计数，如 -1 表示最后⼀个元素。</p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">lrange name 0 -1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-3-3-删除"><a href="#3-3-3-删除" class="headerlink" title="3.3.3 删除"></a>3.3.3 删除</h4><p>删除整个键值对，使用 del 命令。</p><p>删除指定键的某些元素。</p><p><strong>语法</strong>：<code>lrem key count value</code></p><p>根据参数 count 的值，移除列表中与参数 value 相等的元素。</p><ul><li>count &gt; 0：从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count </li><li>count &lt; 0：从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值</li><li>count = 0：移除表中所有与 value 相等的值</li></ul><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">lpush name 1 2 3 4 5 6 1 2 3 1 1 1内存：1 1 1 3 2 1 6 5 4 3 2 1lrem name 3 1内存：3 2 1 6 5 4 3 2 1lrem name -1 2内存：3 2 1 6 5 4 3 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-set"><a href="#3-4-set" class="headerlink" title="3.4 set"></a>3.4 set</h3><p>set 是 string 类型的无序集合，集合成员是唯一的。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><h4 id="3-4-1-增加"><a href="#3-4-1-增加" class="headerlink" title="3.4.1 增加"></a>3.4.1 增加</h4><p><strong>语法</strong>：<code>sadd key member1 member2</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">sadd name 1 2 3 1 4 2内存：1 2 3 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-4-2-获取"><a href="#3-4-2-获取" class="headerlink" title="3.4.2 获取"></a>3.4.2 获取</h4><p>获取所有元素</p><p><strong>语法</strong>：<code>smembers key</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">smembers name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-4-3-删除"><a href="#3-4-3-删除" class="headerlink" title="3.4.3 删除"></a>3.4.3 删除</h4><p>删除整个键值对，使用 del 命令。</p><p>删除指定键的某些元素。</p><p><strong>语法</strong>：<code>srem key member1 member2 ...</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">srem name 1 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-5-zset"><a href="#3-5-zset" class="headerlink" title="3.5 zset"></a>3.5 zset</h3><p>zset 是 string 类型的有序集合，集合成员是唯一的。每个元素都会关联一个 double 类型的分数。redis 是通过分数来为集合中的成员进行从小到大的排序。分数(score)是可以重复。</p><h4 id="3-5-1-增加"><a href="#3-5-1-增加" class="headerlink" title="3.5.1 增加"></a>3.5.1 增加</h4><p><strong>语法</strong>：<code>zadd key score1 member1 score2 member2 ...</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">zadd name 1 a 2 b 3 c 1 d内存 a d b c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-5-2-获取"><a href="#3-5-2-获取" class="headerlink" title="3.5.2 获取"></a>3.5.2 获取</h4><p><strong>语法</strong>：<code>zrange key start stop</code></p><p>start、stop 的使用与 list 相同。</p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">zrange name 0 -1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-5-3-删除"><a href="#3-5-3-删除" class="headerlink" title="3.5.3 删除"></a>3.5.3 删除</h4><p>删除整个键值对，使用 del 命令。</p><p>删除指定键的某些元素。</p><p><strong>语法</strong>：<code>zrem key member1 member2</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">zrem name a b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-6-其他命令"><a href="#3-6-其他命令" class="headerlink" title="3.6 其他命令"></a>3.6 其他命令</h3><h4 id="3-6-1-查找键"><a href="#3-6-1-查找键" class="headerlink" title="3.6.1 查找键"></a>3.6.1 查找键</h4><p>支持正则表达式</p><p><strong>语法</strong>：<code>keys pattern</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">keys *keys na*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-6-2-判断键是否存在"><a href="#3-6-2-判断键是否存在" class="headerlink" title="3.6.2 判断键是否存在"></a>3.6.2 判断键是否存在</h4><p><strong>语法</strong>：<code>exists key1 key2 key3</code></p><p>若 key 存在返回 1，否则返回 0。</p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">exists name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-6-3-查看键对应-value-的类型"><a href="#3-6-3-查看键对应-value-的类型" class="headerlink" title="3.6.3 查看键对应 value 的类型"></a>3.6.3 查看键对应 value 的类型</h4><p><strong>语法</strong>：<code>type key</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">type name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-6-4-键的过期时间"><a href="#3-6-4-键的过期时间" class="headerlink" title="3.6.4 键的过期时间"></a>3.6.4 键的过期时间</h4><p>设置过期时间，以秒为单位。</p><p><strong>语法</strong>：<code>expire key seconds</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">expire name 10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看有效时间，以秒为单位。</p><p><strong>语法</strong>：<code>ttl key</code></p><pre class="line-numbers language-redis" data-language="redis"><code class="language-redis">ttl name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语句的执行过程(MySQL)</title>
      <link href="/2021/07/29/37346.html"/>
      <url>/2021/07/29/37346.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本架构"><a href="#一、基本架构" class="headerlink" title="一、基本架构"></a>一、基本架构</h2><p><img src="/pic/37346_001.png"></p><p>MySQL 可以分为 Server 层和存储引擎层两部分。</p><p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p><h2 id="二、查询语句流程"><a href="#二、查询语句流程" class="headerlink" title="二、查询语句流程"></a>二、查询语句流程</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> customers <span class="token keyword">WHERE</span> cust_id <span class="token operator">=</span> <span class="token number">10001</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1. 连接器"></a>1. 连接器</h3><p>执行 SQL 语句，需要先连接到数据库上。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接器会进行身份认证，需要输入用户名和密码：</p><ul><li>如果用户名或密码不对，会收到一个”Access denied for user”的错误，然后客户端程序结束执行；</li><li>如果用户名密码认证通过，连接器会到权限表里面查出拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>所以，一个用户成功建立连接后，即使用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有重新建立的连接才会使用新的权限。</p><p>可以通过 <code>show processlist</code> 命令看见已存在的连接状态。</p><p><img src="/pic/37346_002.png"></p><p>客户端如果长时间没操作，连接器会自动将它断开。这个时间是由参数 <strong>wait_timeout</strong> 控制，默认值是 8 小时。</p><h3 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2. 查询缓存"></a>2. 查询缓存</h3><p>连接建立后，执行 <strong>SELECT</strong> 语句。</p><p>MySQL 收到查询请求后，会查询缓存，看之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果存在，那么 value 就会被直接返回给客户端。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。</p><p>但是，<strong>查询缓存往往弊大于利。</strong></p><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。</p><p>可以将参数 <strong>query_cache_type</strong> 设置成 <strong>DEMAND</strong>，这样对于默认的 SQL 语句都不使用查询缓存。而对于明确要使用查询缓存的语句，可以用 <strong>SQL_CACHE</strong> 显式指定。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> SQL_CACHE <span class="token operator">*</span> <span class="token keyword">FROM</span> customers <span class="token keyword">WHERE</span> cust_id <span class="token operator">=</span> <span class="token number">10001</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>MySQL 8.0 版本不在支持查询缓存，直接将查询缓存的整块功能删掉了。</p><h3 id="3-分析器"><a href="#3-分析器" class="headerlink" title="3. 分析器"></a>3. 分析器</h3><p>如果没有命中查询缓存，就要开始执行语句，会对 SQL 语句进行解析。</p><p>分析器会进行”词法分析“和”语法分析“，判断 SQL 语句是否符合规范。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ELECT <span class="token operator">*</span> <span class="token keyword">FROM</span> customers <span class="token keyword">WHERE</span> cust_id <span class="token operator">=</span> <span class="token number">10001</span><span class="token punctuation">;</span><span class="token comment"># ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'ELECT SQL_CACHE * FROM customers WHERE cust_id = 10001' at line 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>分析器会判断语句是否正确，表是否存在，列是否存在等问题。</strong></p><p>如果 SQL 语句中使用了不存在的列，则在此阶段报错：Unknown column ‘id’ in ‘where clause’。</p><h3 id="4-优化器"><a href="#4-优化器" class="headerlink" title="4. 优化器"></a>4. 优化器</h3><p>语句分析完成后，在执行 SQL 语句之前，会进行优化器的处理。</p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p><h3 id="5-执行器"><a href="#5-执行器" class="headerlink" title="5. 执行器"></a>5. 执行器</h3><p>开始执行的时候，要先判断一下用户对这个表 customers 有没有执行查询的权限，如果没有，就会返回没有权限的错误（如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限）。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> customers <span class="token keyword">WHERE</span> cust_id <span class="token operator">=</span> <span class="token number">10001</span><span class="token punctuation">;</span><span class="token comment"># ERROR 1142 (42000): SELECT command denied to user 'test'@'localhost' for table 'customers'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>如果表没有索引：</p><ol><li>调用 InnoDB 引擎接口取这个表的第一行，判断 cust_id 值是不是 10001，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行；</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>至此，这个语句就执行完成了。</p><p>如果表中有索引，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口。</p><h2 id="三、更新语句流程"><a href="#三、更新语句流程" class="headerlink" title="三、更新语句流程"></a>三、更新语句流程</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> customers <span class="token keyword">SET</span> cust_country <span class="token operator">=</span> <span class="token string">'GBR'</span> <span class="token keyword">WHERE</span> cust_id <span class="token operator">=</span> <span class="token number">10001</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>与查询流程类似。但是这个更新语句会把表 customers 上所有缓存结果都清空。</p><p>更新流程还有两个重要的日志模块：<strong>redo log（重做日志）和 bin log（归档日志）</strong>。</p><h3 id="1-redo-log"><a href="#1-redo-log" class="headerlink" title="1. redo log"></a>1. redo log</h3><p>如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。</p><p>MySQL 的设计者使用 WAL（Write-Ahead Logging）技术，即先写日志，再写磁盘。</p><p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新是在系统比较空闲的时候做。</p><p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p><p><img src="/pic/37346_003.png"></p><p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos 和 checkpoint 之间的如果还有空闲位置，可以用来记录新的操作。如果没有空闲位置，表示已写满了，这时候不能再执行新的更新，需要先将记录更新到数据文件中，把 checkpoint 推进。</p><p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p><h3 id="2-bin-log"><a href="#2-bin-log" class="headerlink" title="2. bin log"></a>2. bin log</h3><ul><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用；</li><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“修改 cust_id = 10001 这行的 cust_country 字段”；</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的，文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ul><h3 id="3-执行流程"><a href="#3-执行流程" class="headerlink" title="3. 执行流程"></a>3. 执行流程</h3><ol><li>执行器通过引擎获取 cust_id = 10001 这一行数据。cust_id 是主键，引擎直接用树搜索找到这一行。如果这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回；</li><li>执行器拿到行数据后，修改 cust_country 的值，再调用引擎接口写入这行新数据；</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务；</li><li>执行器生成这个操作的 bin log，并把 bin log 写入磁盘；</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li></ol><p><img src="/pic/37346_004.png"></p><h3 id="4-两阶段提交"><a href="#4-两阶段提交" class="headerlink" title="4. 两阶段提交"></a>4. 两阶段提交</h3><p>redo log 操作被拆分成两个步骤了，这是为了让两份日志之间的逻辑一致。这样才能放心地使用 redo log 将数据库中的状态恢复成 crash 之前的状态，使用 bin log 实现数据备份、恢复、以及主从复制。而<strong>两阶段提交的机制可以保证这两个日志文件的逻辑是高度一致的</strong>，没有错误、没有冲突。</p><p>如果只有 prepare，那么恢复的时候，所有不一致的 redo log，都要去查看 bin log 中有没有，再决定是否重做，而两阶段的话，不一致的 redo log 里，commit 状态的可以直接重做，而 prepare 状态的再去跟 bin log 比对，减少了跟 bin log 的交互。</p><h2 id="四、设置"><a href="#四、设置" class="headerlink" title="四、设置"></a>四、设置</h2><p>redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。</p><p>sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。</p><h2 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h2><p>使用长连接后，有时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的，这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉。</p><ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2021/04/25/19514.html"/>
      <url>/2021/04/25/19514.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础命令"><a href="#一、基础命令" class="headerlink" title="一、基础命令"></a>一、基础命令</h2><p><strong>注意</strong>：对所有 SQL 关键字使用大写，而对所有列和表名使用小写，这样做使代码更易于阅读和调试。</p><h3 id="1-登录命令"><a href="#1-登录命令" class="headerlink" title="1. 登录命令"></a>1. 登录命令</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql <span class="token operator">-</span>h ip <span class="token operator">-</span>P 端口 <span class="token operator">-</span>u 用户名 <span class="token operator">-</span>p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-查看数据库版本"><a href="#2-查看数据库版本" class="headerlink" title="2. 查看数据库版本"></a>2. 查看数据库版本</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 未登录状态下</span>mysql <span class="token operator">-</span>V 或 mysql <span class="token comment">--version</span><span class="token comment"># 登录后</span><span class="token keyword">SELECT</span> version<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-显示数据库中的一些信息"><a href="#3-显示数据库中的一些信息" class="headerlink" title="3. 显示数据库中的一些信息"></a>3. 显示数据库中的一些信息</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">DATABASES</span><span class="token punctuation">;</span>  <span class="token comment"># 显示 MySQL 现有的数据库</span><span class="token keyword">SELECT</span> <span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment"># 查看当前所在库</span><span class="token keyword">SHOW</span> <span class="token keyword">TABLES</span><span class="token punctuation">;</span>  <span class="token comment"># 获得一个数据库内的表的列表</span><span class="token keyword">SHOW</span> <span class="token keyword">TABLES</span> <span class="token keyword">FROM</span> 库名<span class="token punctuation">;</span>  <span class="token comment"># 显示其他库中所有表</span><span class="token keyword">SHOW</span> <span class="token keyword">COLUMNS</span> <span class="token keyword">FROM</span> 表名<span class="token punctuation">;</span>  <span class="token comment"># 显示表列</span><span class="token keyword">DESCRIBE</span> 表名<span class="token punctuation">;</span>  <span class="token comment"># 显示表列的快捷方式</span><span class="token keyword">DESC</span> 表名<span class="token punctuation">;</span>  <span class="token comment"># 显示表列的快捷方式</span><span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> 库名<span class="token punctuation">;</span><span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 表名<span class="token punctuation">;</span><span class="token comment"># 分别用来显示创建特定数据库或表的 MySQL 语句</span><span class="token keyword">SHOW</span> <span class="token keyword">STATUS</span><span class="token punctuation">;</span>  <span class="token comment"># 用于显示广泛的服务器状态信息</span><span class="token keyword">SHOW</span> GRANTS<span class="token punctuation">;</span>  <span class="token comment"># 用来显示授予用户（所有用户或特定用户）的安 全权限</span><span class="token keyword">SHOW</span> <span class="token keyword">ERRORS</span><span class="token punctuation">;</span><span class="token keyword">SHOW</span> <span class="token keyword">WARNINGS</span><span class="token punctuation">;</span><span class="token comment"># 用来显示服务器错误或警告消息</span><span class="token keyword">SHOW</span> ENGINES<span class="token punctuation">;</span>  <span class="token comment"># 查看当前 mysql 支持的存储引擎</span><span class="token keyword">SHOW</span> VARIABLES<span class="token punctuation">;</span>  <span class="token comment"># 查看系统变量及其值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-进入指定的库"><a href="#4-进入指定的库" class="headerlink" title="4. 进入指定的库"></a>4. 进入指定的库</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> 库名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="二、SELECE-语句"><a href="#二、SELECE-语句" class="headerlink" title="二、SELECE 语句"></a>二、SELECE 语句</h2><p><strong>SELECT</strong> 语句从一个或多个表中检索信息。</p><h3 id="1-检索单个列"><a href="#1-检索单个列" class="headerlink" title="1. 检索单个列"></a>1. 检索单个列</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> 列名 <span class="token keyword">FROM</span> 表名<span class="token punctuation">;</span><span class="token keyword">SELECT</span> prod_name <span class="token keyword">FROM</span> products<span class="token punctuation">;</span><span class="token keyword">SELECT</span> products<span class="token punctuation">.</span>prod_name <span class="token keyword">FROM</span> products<span class="token punctuation">;</span>  <span class="token comment"># 使用完全限定的表名</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-检索多个列"><a href="#2-检索多个列" class="headerlink" title="2. 检索多个列"></a>2. 检索多个列</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> 列名<span class="token punctuation">,</span> 列名<span class="token punctuation">,</span> 列名<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FROM</span> 表名<span class="token punctuation">;</span>  <span class="token comment"># 列名之间必须以逗号分隔</span><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price <span class="token keyword">FROM</span> products<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-检索所有列"><a href="#3-检索所有列" class="headerlink" title="3. 检索所有列"></a>3. 检索所有列</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> 表名<span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> products<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意</strong>：除非确实需要表中的每个列，否则最好别使用*通配符。检索不需要的列通常会降低检索和应用程序的性能。</p><h3 id="4-检索不同的行"><a href="#4-检索不同的行" class="headerlink" title="4. 检索不同的行"></a>4. 检索不同的行</h3><p>相同的数据只出现一次，使用 <strong>DISTINCT</strong> 关键字，指示 MySQL 只返回不同的值。它必须直接放在列名的前面。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> vend_id <span class="token keyword">FROM</span> products<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意</strong>：不能部分使用 <strong>DISTINCT</strong> 关键字，该关键字应用于所有列而不仅是前置它的列。如果给出 <code>SELECT DISTINCT vend_id, prod_price</code>，除非指定的两个列都不同，否则所有行都将被检索出来。</p><h3 id="5-限制结果（LIMIT）"><a href="#5-限制结果（LIMIT）" class="headerlink" title="5. 限制结果（LIMIT）"></a>5. 限制结果（LIMIT）</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_name <span class="token keyword">FROM</span> products <span class="token keyword">LIMIT</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token comment"># LIMIT 5 指示 MySQL 返回不多于 5 行</span><span class="token keyword">SELECT</span> prod_name <span class="token keyword">FROM</span> products <span class="token keyword">LIMIT</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token comment"># LIMIT 5, 5 指示 MySQL 返回从行 5 开始的 5 行。第一个数为开始位置，第二个数为要检索的行数。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意</strong>：MySQL 行数从 0 开始。</p><p>MySQL 5 支持 <strong>LIMIT</strong> 的另一种替代语法。<code>LIMIT 4 OFFSET 3</code> 意为从行 3 开始取 4 行，就像 <code>LIMIT 3, 4</code> 一样。</p><h3 id="6-排序数据（ORDER-BY）"><a href="#6-排序数据（ORDER-BY）" class="headerlink" title="6. 排序数据（ORDER BY）"></a>6. 排序数据（ORDER BY）</h3><p>使用 <strong>ORDER BY</strong> 子句。<strong>ORDER BY</strong> 子句取一个或多个列的名字，据此对输出进行排序。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_name <span class="token keyword">FROM</span> products <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_name<span class="token punctuation">;</span><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_price<span class="token punctuation">,</span> prod_name <span class="token keyword">FROM</span> products <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_price<span class="token punctuation">,</span> prod_name<span class="token punctuation">;</span>  <span class="token comment"># 首先按价格，然后再按名称排序。如果价格的所有的值都是唯一的，则不会按照名称排序。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>排序方向</strong>：</p><ul><li>降序排序：<strong>DESC</strong></li><li>升序排序：<strong>ASC</strong>（升序是默认的）</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_price<span class="token punctuation">,</span> prod_name <span class="token keyword">FROM</span> products <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_price <span class="token keyword">DESC</span><span class="token punctuation">,</span> prod_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意</strong>：关键字只能应用到直接位于其前面的列名。如果想在多个列上进行降序排序，必须对每个列指定 <strong>DESC</strong> 关键字。</p><h2 id="三、WHERE-子句"><a href="#三、WHERE-子句" class="headerlink" title="三、WHERE 子句"></a>三、WHERE 子句</h2><h3 id="1-过滤数据"><a href="#1-过滤数据" class="headerlink" title="1. 过滤数据"></a>1. 过滤数据</h3><p>在 <strong>SELECT</strong> 语句中，数据根据 <strong>WHERE</strong> 子句中指定的搜索条件进行过滤。<strong>WHERE</strong> 子句在表名（<strong>FROM</strong> 子句）之后给出。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_name<span class="token punctuation">,</span> prod_price <span class="token keyword">FROM</span> products <span class="token keyword">WHERE</span> prod_price <span class="token operator">=</span> <span class="token number">2.50</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意</strong>：在同时使用 <strong>ORDER BY</strong> 和 <strong>WHERE</strong> 子句时，应该让 <strong>ORDER BY</strong> 位于 <strong>WHERE 之后</strong>，否则将会产生错误。</p><p>MySQL 在执行匹配时默认<strong>不区分大小写</strong>。</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于</td></tr><tr><td>!=</td><td>不等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>BETWEEN</td><td>在指定的两个值之间</td></tr></tbody></table><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_name<span class="token punctuation">,</span> prod_price <span class="token keyword">FROM</span> products <span class="token keyword">WHERE</span> prod_price <span class="token operator">BETWEEN</span> <span class="token number">5</span> <span class="token operator">AND</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在使用 <strong>BETWEEN</strong> 时，必须指定两个值——所需范围的低端值和高端值。这两个值必须用 <strong>AND</strong> 关键字分隔。<strong>BETWEEN</strong> 匹配范围中所有的值，包括指定的开始值和结束值。</p><h3 id="2-空值检查"><a href="#2-空值检查" class="headerlink" title="2. 空值检查"></a>2. 空值检查</h3><p>在创建表时，表设计人员可以指定其中的列是否可以不包含值。在一个列不包含值时，称其为包含空值 <strong>NULL</strong>。</p><p><strong>SELECT</strong> 语句有一个特殊的 <strong>WHERE</strong> 子句，可用来检查具有 <strong>NULL</strong> 值的列。 这个 <strong>WHERE</strong> 子句就是 <strong>IS NULL</strong> 子句。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_name <span class="token keyword">FROM</span> products <span class="token keyword">WHERE</span> prod_price <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span class="token comment"># 这条语句返回没有价格（空 prod_price 字段，不是价格为 0）的所有产品。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-组合-WHERE-子句"><a href="#3-组合-WHERE-子句" class="headerlink" title="3. 组合 WHERE 子句"></a>3. 组合 WHERE 子句</h3><p>MySQL 允许给出多个 <strong>WHERE</strong> 子句。这些子句以两种方式使用：以 <strong>AND</strong> 子句或 <strong>OR</strong> 子句的方式使用。</p><ul><li><strong>AND</strong>：用在 <strong>WHERE</strong> 子句中的关键字，用来指示检索满足所有给定条件的行</li><li><strong>OR</strong>：用在 <strong>WHERE</strong> 子句中的关键字，用来表示检索匹配任一给定条件的行</li></ul><p><strong>注意</strong>：SQL 在处理 <strong>OR</strong> 操作符前，优先处理 <strong>AND</strong> 操作符。任何时候使用具有 <strong>AND</strong> 和 <strong>OR</strong> 操作符的 <strong>WHERE</strong> 子句，都应该使用圆括号明确地分组操作符。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_name<span class="token punctuation">,</span> prod_price <span class="token keyword">FROM</span> products <span class="token keyword">WHERE</span> <span class="token punctuation">(</span>vend_id <span class="token operator">=</span> <span class="token number">1002</span> <span class="token operator">OR</span> vend_id <span class="token operator">=</span> <span class="token number">1003</span><span class="token punctuation">)</span> <span class="token operator">AND</span> prod_price <span class="token operator">&gt;=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-IN-操作符"><a href="#4-IN-操作符" class="headerlink" title="4. IN 操作符"></a>4. IN 操作符</h3><p>用来指定条件范围，范围中的每个条件都可以进行匹配，功能与 <strong>OR</strong> 相当。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_name<span class="token punctuation">,</span> prod_price <span class="token keyword">FROM</span> products <span class="token keyword">WHERE</span> vend_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1002</span><span class="token punctuation">,</span> <span class="token number">1003</span><span class="token punctuation">)</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在使用长的合法选项清单时，<strong>IN</strong> 操作符的语法更清楚且更直观。</p><p>优点：</p><ul><li>计算的次序更容易管理（因为使用的操作符更少）</li><li>一般比 <strong>OR</strong> 操作符清单执行更快</li><li>可以包含其他 <strong>SELECT</strong> 语句，使得能够更动态地建立 <strong>WHERE</strong> 子句</li></ul><h3 id="5-NOT-操作符"><a href="#5-NOT-操作符" class="headerlink" title="5. NOT 操作符"></a>5. NOT 操作符</h3><p>功能是否定它之后所跟的任何条件。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_name<span class="token punctuation">,</span> prod_price <span class="token keyword">FROM</span> products <span class="token keyword">WHERE</span> vend_id <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1002</span><span class="token punctuation">,</span> <span class="token number">1003</span><span class="token punctuation">)</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-用通配符进行过滤（LIKE）"><a href="#6-用通配符进行过滤（LIKE）" class="headerlink" title="6. 用通配符进行过滤（LIKE）"></a>6. 用通配符进行过滤（LIKE）</h3><p>通配符（wildcard）用来匹配值的一部分的特殊字符。</p><p>在搜索子句中使用通配符，必须使用 <strong>LIKE</strong> 操作符。<strong>LIKE</strong> 指示 MySQL，后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。</p><h4 id="百分号（-）通配符"><a href="#百分号（-）通配符" class="headerlink" title="百分号（%）通配符"></a>百分号（%）通配符</h4><p>最常使用的通配符是百分号（%）。在搜索串中，% 表示任何字符出现任意次数。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name <span class="token keyword">FROM</span> products <span class="token keyword">WHERE</span> prod_name <span class="token operator">LIKE</span> <span class="token string">'jet%'</span><span class="token punctuation">;</span><span class="token comment"># 使用了搜索模式'jet%'。在执行这条子句时，将检索任意以 jet 起头的词。% 告诉 MySQL 接受 jet 之后的任意字符，不管它有多少字符。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通配符可在搜索模式中任意位置使用，并且可以使用多个通配符。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name <span class="token keyword">FROM</span> products <span class="token keyword">WHERE</span> prod_name <span class="token operator">LIKE</span> <span class="token string">'%anvil%'</span><span class="token punctuation">;</span><span class="token comment"># 搜索模式'%anvil%' 表示匹配任何位置包含文本 anvil 的值，而不论它之前或之后出现什么字符。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意</strong>：</p><ul><li>% 通配符有一个例外，无法匹配空值，即 <strong>NULL</strong></li><li>尾空格可能会干扰通配符匹配</li></ul><h4 id="下划线（-）通配符"><a href="#下划线（-）通配符" class="headerlink" title="下划线（_）通配符"></a>下划线（_）通配符</h4><p>下划线的用途与 % 一样，但下划线只匹配单个字符而不是多个字符。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name <span class="token keyword">FROM</span> products <span class="token keyword">WHERE</span> prod_name <span class="token operator">LIKE</span> <span class="token string">'_ ton anvil'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-正则表达式"><a href="#7-正则表达式" class="headerlink" title="7. 正则表达式"></a>7. 正则表达式</h3><p>使用关键字 <strong>REGEXP</strong>。</p><h2 id="四、计算字段"><a href="#四、计算字段" class="headerlink" title="四、计算字段"></a>四、计算字段</h2><p><strong>字段</strong>（field）：基本上与列（column）的意思相同，经常互换使用，不过数据库列一般称为列，而术语字段通常用在计算字段的连接上。</p><p>计算字段并不实际存在于数据库表中。计算字段是运行时在SELECT语句内创建的。</p><p><strong>注意</strong>：只有数据库知道 SELECT 语句中哪些列是实际的表列，哪些列是计算字段。从客户机（如应用程序）的角度来看，计算字段的数据是以与其他列的数据相同的方式返回的。</p><h3 id="1-拼接字段"><a href="#1-拼接字段" class="headerlink" title="1. 拼接字段"></a>1. 拼接字段</h3><p><strong>拼接</strong>（concatenate）：将值联结到一起构成单个值。可使用 Concat() 函数来拼接两个列。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Concat<span class="token punctuation">(</span>vend_name<span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> vend_country<span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> vendors <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> vend_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-使用别名"><a href="#2-使用别名" class="headerlink" title="2. 使用别名"></a>2. 使用别名</h3><p>别名（alias）是一个字段或值的替换名。别名用 <strong>AS</strong> 关键字赋予。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Concat<span class="token punctuation">(</span>vend_name<span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> vend_country<span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> vend_title <span class="token keyword">FROM</span> vendors <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> vend_name<span class="token punctuation">;</span><span class="token comment"># 给表起别名</span><span class="token keyword">SELECT</span> p<span class="token punctuation">.</span>prod_id<span class="token punctuation">,</span> p<span class="token punctuation">.</span>prod_name <span class="token keyword">FROM</span> products <span class="token keyword">as</span> p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-算术计算"><a href="#3-算术计算" class="headerlink" title="3. 算术计算"></a>3. 算术计算</h3><p>计算字段的另一常见用途是对检索出的数据进行算术计算（加减乘除）。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> quantity<span class="token punctuation">,</span> item_price<span class="token punctuation">,</span> quantity<span class="token operator">*</span>item_price <span class="token keyword">AS</span> expanded_price <span class="token keyword">FROM</span> orderitems <span class="token keyword">WHERE</span> order_num <span class="token operator">=</span> <span class="token number">20005</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h3><p><strong>常用的文本处理函数</strong></p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>Left()</td><td>返回串左边的字符</td></tr><tr><td>Length()</td><td>返回串的长度</td></tr><tr><td>Locate()</td><td>找出串的一个字串</td></tr><tr><td>Lower()</td><td>将串转换为小写</td></tr><tr><td>LTrim()</td><td>去掉串左边的空格</td></tr><tr><td>Right()</td><td>返回串右边的字符</td></tr><tr><td>RTrim()</td><td>去掉串右边的空格</td></tr><tr><td>Soundex()</td><td>返回串的SOUNDEX值</td></tr><tr><td>SubString()</td><td>返回字串的字符</td></tr><tr><td>Upper()</td><td>将串转换为大写</td></tr></tbody></table><p><strong>常用日期和时间处理函数</strong></p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>AddDate()</td><td>增加一个日期</td></tr><tr><td>AddTime()</td><td>增加一个时间</td></tr><tr><td>CurDate()</td><td>返回当前日期</td></tr><tr><td>CurTime()</td><td>返回当前时间</td></tr><tr><td>Date()</td><td>返回日期时间的日期部分</td></tr><tr><td>DateDiff()</td><td>计算两个日期之差</td></tr><tr><td>Date_Add()</td><td>高度灵活的日期运算函数</td></tr><tr><td>Date_Format()</td><td>返回一个格式化的日期或时间串</td></tr><tr><td>Day()</td><td>返回一个日期的天数部分</td></tr><tr><td>DayOfWeek()</td><td>对于一个日期，返回对应的星期几</td></tr><tr><td>Hour()</td><td>返回一个时间的小时部分</td></tr><tr><td>Minute()</td><td>返回一个时间的分钟部分</td></tr><tr><td>Month()</td><td>返回一个日期的月份部分</td></tr><tr><td>Now()</td><td>返回当前日期和时间</td></tr><tr><td>Second()</td><td>返回一个时间的秒部分</td></tr><tr><td>Time()</td><td>返回一个日期时间的时间部分</td></tr><tr><td>Year()</td><td>返回一个日期的年份部分</td></tr></tbody></table><p><strong>常用数值处理函数</strong></p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>Abs()</td><td>返回一个数的绝对值</td></tr><tr><td>Cos()</td><td>返回一个角度的余弦</td></tr><tr><td>Exp()</td><td>返回一个数的指数值</td></tr><tr><td>Mod()</td><td>返回除操作的余数</td></tr><tr><td>Pi()</td><td>返回圆周率</td></tr><tr><td>Rand()</td><td>返回一个随机数</td></tr><tr><td>Sin()</td><td>返回一个角度的正弦</td></tr><tr><td>Sqrt()</td><td>返回一个数的平方根</td></tr><tr><td>Tan()</td><td>返回一个角度的正切</td></tr></tbody></table><p><strong>聚集函数</strong></p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>AVG()</td><td>返回某列的平均值</td></tr><tr><td>COUNT()</td><td>返回某列的行数</td></tr><tr><td>MAX()</td><td>返回某列的最大值</td></tr><tr><td>MIN()</td><td>返回某列的最小值</td></tr><tr><td>SUM()</td><td>返回某列值之和</td></tr></tbody></table><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num_items<span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>prod_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> price_min<span class="token punctuation">,</span> <span class="token function">MAX</span><span class="token punctuation">(</span>prod_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> price_max<span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>prod_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> price_avg <span class="token keyword">FROM</span> products<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/pic/19514_001.png"></p><h2 id="五、分组数据"><a href="#五、分组数据" class="headerlink" title="五、分组数据"></a>五、分组数据</h2><h3 id="1-创建分组"><a href="#1-创建分组" class="headerlink" title="1. 创建分组"></a>1. 创建分组</h3><p>使用 <strong>GROUP BY</strong>，将查询结果按照1个或多个字段进行分组，字段值相同的为一组。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> vend_id<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num_prods <span class="token keyword">FROM</span> products <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> vend_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/pic/19514_002.png"></p><p><strong>注意</strong>：</p><ul><li><strong>GROUP BY</strong> 子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制；</li><li>如果在 <strong>GROUP BY</strong> 子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）；</li><li><strong>GROUP BY</strong> 子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在 <strong>SELECT</strong> 中使用表达式，则必须在 <strong>GROUP BY</strong> 子句中指定相同的表达式。不能使用别名；</li><li>除聚集计算语句外，<strong>SELECT</strong> 语句中的每个列都必须在 <strong>GROUP BY</strong> 子句中给出；</li><li>如果分组列中具有 <strong>NULL</strong> 值，则 <strong>NULL</strong> 将作为一个分组返回。如果列中有多行 <strong>NULL</strong> 值，它们将分为一组；</li><li><strong>GROUP BY</strong> 子句必须出现在 <strong>WHERE</strong> 子句之后，<strong>ORDER BY</strong> 子句之前。</li></ul><h3 id="2-过滤分组"><a href="#2-过滤分组" class="headerlink" title="2. 过滤分组"></a>2. 过滤分组</h3><p>MySQL 允许过滤分组，规定包括哪些分组，排除哪些分组。使用 <strong>HAVING</strong> 子句，<strong>HAVING</strong> 支持所有 <strong>WHERE</strong> 操作符。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> vend_id<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num_prods <span class="token keyword">FROM</span> products <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> vend_id <span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/pic/19514_003.png"></p><blockquote><p>HAVING 和 WHERE 的差别：WHERE 在数据分组前进行过滤，HAVING 在数据分组后进行过滤。WHERE 排除的行不包括在分组中。</p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> vend_id<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num_prods <span class="token keyword">FROM</span> products <span class="token keyword">WHERE</span> prod_price <span class="token operator">&gt;=</span> <span class="token number">10</span> <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> vend_id <span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/pic/19514_004.png"></p><h3 id="3-分组和排序"><a href="#3-分组和排序" class="headerlink" title="3. 分组和排序"></a>3. 分组和排序</h3><table><thead><tr><th>ORDER BY</th><th>GROUP BY</th></tr></thead><tbody><tr><td>排序产生的输出</td><td>分组行。但输出可能不是分组的顺序</td></tr><tr><td>任意列都可以使用（甚至 非选择的列也可以使用）</td><td>只可能使用选择列或表达式列，而且必须使用每个选择 列表达式</td></tr><tr><td>不一定需要</td><td>如果与聚集函数一起使用列（或表达式），则必须使用</td></tr></tbody></table><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> order_num<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>quantity<span class="token operator">*</span>item_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> ordertotal <span class="token keyword">FROM</span> orderitems <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> order_num <span class="token keyword">HAVING</span> <span class="token function">SUM</span><span class="token punctuation">(</span>quantity<span class="token operator">*</span>item_price<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">50</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> ordertotal<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/pic/19514_005.png"></p><h3 id="4-SELECT-子句顺序"><a href="#4-SELECT-子句顺序" class="headerlink" title="4. SELECT 子句顺序"></a>4. SELECT 子句顺序</h3><table><thead><tr><th>子句</th><th>说明</th><th>是否必须使用</th></tr></thead><tbody><tr><td>SELECT</td><td>要返回的列或表达式</td><td>是</td></tr><tr><td>FROM</td><td>从中检索数据的表</td><td>仅在从表选择数据时使用</td></tr><tr><td>WHERE</td><td>行级过滤</td><td>否</td></tr><tr><td>GROUP BY</td><td>分组说明</td><td>仅在按组计算聚集时使用</td></tr><tr><td>HAVING</td><td>组级过滤</td><td>否</td></tr><tr><td>ORDER BY</td><td>输出排序顺序</td><td>否</td></tr><tr><td>LIMIT</td><td>要检索的行数</td><td>否</td></tr></tbody></table><h2 id="六、插入数据"><a href="#六、插入数据" class="headerlink" title="六、插入数据"></a>六、插入数据</h2><p><strong>INSERT</strong> 语句，是用来插入（或添加）行到数据库表的。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 插入单行</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> 表名 <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment"># 这种方法不安全，应尽量避免，使用下面的。</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> 表明<span class="token punctuation">(</span>列<span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment"># 输入对应列名和值</span><span class="token comment"># 插入多行数据</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> 表名 <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> 表名<span class="token punctuation">(</span>列<span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>省略列</strong></p><p>如果表的定义允许，则可以在 <strong>INSERT</strong> 操作中省略某些列。省略的列必须满足以下某个条件：</p><ul><li>该列定义为允许 <strong>NULL</strong> 值（无值或空值）；</li><li>在表定义中给出默认值。这表示如果不给出值，将使用默 认值。</li></ul><p><strong>提高性能</strong></p><p>如果数据检索是最重要的，则可以通过在 <strong>INSERT</strong> 和 <strong>INTO</strong> 之间添加关键字 <strong>LOW_PRIORITY</strong>，指示 MySQL 降低 <strong>INSERT</strong> 语句的优先级，如：<code>INSERT LOW_PRIORITY INTO</code>，这也适用于 <strong>UPDATE</strong> 和 <strong>DELETE</strong> 语句。</p><p>MySQL 用单条 <strong>INSERT</strong> 语句处理多个插入比使用多条 <strong>INSERT</strong> 语句快。</p><h2 id="七、更新和删除数据"><a href="#七、更新和删除数据" class="headerlink" title="七、更新和删除数据"></a>七、更新和删除数据</h2><h3 id="1-update"><a href="#1-update" class="headerlink" title="1. update"></a>1. update</h3><p>更新表中的数据，可使用 <strong>UPDATE</strong> 语句。</p><p><strong>注意</strong>：在使用 <strong>UPDATE</strong> 时一定要注意。因为稍不注意，就会更新表中所有行。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> 表名 <span class="token keyword">SET</span> 列<span class="token number">1</span><span class="token operator">=</span>值<span class="token number">1</span><span class="token punctuation">,</span>列<span class="token number">2</span><span class="token operator">=</span>值<span class="token number">2.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">WHERE</span> 条件<span class="token punctuation">;</span><span class="token keyword">UPDATE</span> customers <span class="token keyword">SET</span> cust_email<span class="token operator">=</span><span class="token string">"elmer@fudd.com"</span> <span class="token keyword">WHERE</span> cust_id<span class="token operator">=</span><span class="token number">10005</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果用 <strong>UPDATE</strong> 语句更新多行，并且在更新这些行中的一行或多行时出现一个错误，则整个 <strong>UPDATE</strong> 操作被取消（错误发生前更新的所有行被恢复到它们原来的值）。要想即使是发生错误，也继续进行更新，可使用 <strong>IGNORE</strong> 关键字，如下所示：<code>UPDATE IGNORE customers…</code>。</p><h3 id="2-delete"><a href="#2-delete" class="headerlink" title="2. delete"></a>2. delete</h3><p>删除表中的数据，可使用 <strong>DELETE</strong> 语句。</p><p><strong>注意</strong>：在使用 <strong>DELETE</strong> 时一定要注意。因为稍不注意，就会错误地删除表中所有行。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 条件<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>提高性能</strong></p><p>如果想从表中删除所有行，不要使用 <strong>DELETE</strong>。可使用 <code>TRUNCATE TABLE</code> 语句，它完成相同的工作，但速度更快（<strong>TRUNCATE</strong> 实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）。</p><h2 id="八、数据表"><a href="#八、数据表" class="headerlink" title="八、数据表"></a>八、数据表</h2><h3 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1. 创建表"></a>1. 创建表</h3><p>使用 <strong>CREATE TABLE</strong> 语句创建表。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> customers<span class="token punctuation">(</span>  cust_id      <span class="token keyword">int</span>       <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  cust_name    <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>  <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token punctuation">,</span>  cust_address <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>  <span class="token boolean">NULL</span> <span class="token punctuation">,</span>  cust_city    <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>  <span class="token boolean">NULL</span> <span class="token punctuation">,</span>  cust_state   <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>   <span class="token boolean">NULL</span> <span class="token punctuation">,</span>  cust_zip     <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>  <span class="token boolean">NULL</span> <span class="token punctuation">,</span>  cust_country <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>  <span class="token boolean">NULL</span> <span class="token punctuation">,</span>  cust_contact <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>  <span class="token boolean">NULL</span> <span class="token punctuation">,</span>  cust_email   <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token boolean">NULL</span> <span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>cust_id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="PRIMARY-KEY"><a href="#PRIMARY-KEY" class="headerlink" title="PRIMARY KEY"></a>PRIMARY KEY</h4><p>表的主键（主键唯一）在创建表时用 <strong>PRIMARY KEY</strong> 关键字指定。表中的每个行必须具有唯一的主键值。如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一。</p><h4 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h4><p><strong>NULL</strong> 值就是没有值或缺值。允许 <strong>NULL</strong> 值的列也允许在插入行时不给出该列的值。不允许 <strong>NULL</strong> 值的列不接受该列没有值的行，在插入或更新行时，该列必须有值。</p><p><strong>注意</strong>：主键中只能使用不允许 <strong>NULL</strong> 值的列，允许 <strong>NULL</strong> 值的列不能作为唯一标识。</p><h4 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h4><p><strong>AUTO_INCREMENT</strong> 告诉 MySQL，本列每当增加一行时自动增量。每个表只允许一个 <strong>AUTO_INCREMENT</strong> 列，而且它必须被索引。</p><p>可使用 <code>last_insert_id()</code> 函数获取最后一个 <strong>AUTO_INCREMENT</strong> 值（<code>SELECT last_insert_id()</code>）。</p><h4 id="DEFAULT"><a href="#DEFAULT" class="headerlink" title="DEFAULT"></a>DEFAULT</h4><p>如果在插入行时没有给出值，MySQL 允许指定使用默认值。 默认值用 <strong>CREATE TABLE</strong> 语句的列定义中的 <strong>DEFAULT</strong> 关键字指定。</p><h3 id="2-更新表"><a href="#2-更新表" class="headerlink" title="2. 更新表"></a>2. 更新表</h3><p>使用 <strong>ALTER TABLE</strong> 语句更新表定义。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">ADD</span> column_name datatype<span class="token punctuation">;</span><span class="token comment"># 给表添加一个列</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> vendors <span class="token keyword">ADD</span> vend_phone <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">MODIFY</span> <span class="token keyword">COLUMN</span> column_name datatype<span class="token punctuation">;</span><span class="token comment"># 修改表的列</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> vendors <span class="token keyword">MODIFY</span> <span class="token keyword">COLUMN</span> vend_phone <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> column_name<span class="token punctuation">;</span><span class="token comment"># 删除列</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> vendors <span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> vend_phone<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ALTER TABLE</strong> 的常见用途是定义外键。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> orderitems <span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> fk_orderitems_orders <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>order_num<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> orders <span class="token punctuation">(</span>order_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-删除表"><a href="#3-删除表" class="headerlink" title="3. 删除表"></a>3. 删除表</h3><p>使用 <strong>DROP TABLE</strong> 语句删除表。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> table_name<span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> customers<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-重命名表"><a href="#4-重命名表" class="headerlink" title="4. 重命名表"></a>4. 重命名表</h3><p>使用 <strong>RENAME TABLE</strong> 语句重命名一个表。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">RENAME</span> <span class="token keyword">TABLE</span> customers2 <span class="token keyword">TO</span> customers<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="九、数据库"><a href="#九、数据库" class="headerlink" title="九、数据库"></a>九、数据库</h2><p>创建数据库</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE DATABASE [IF NOT EXISTS] 数据库名称 [charset=utf8];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除数据库</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DROP DATABASE [IF EXISTS] 数据库名称;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态库与静态库(Linux)</title>
      <link href="/2021/01/15/31396.html"/>
      <url>/2021/01/15/31396.html</url>
      
        <content type="html"><![CDATA[<p>共享库的好处是，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例。</p><h2 id="一、库的分类"><a href="#一、库的分类" class="headerlink" title="一、库的分类"></a>一、库的分类</h2><p>库有两种：<strong>静态库和共享库（动态库）</strong>。</p><ul><li>windows 平台下，静态库通常后缀为 .lib，动态库为 .dll；</li><li>linux 平台下，静态库通常后缀为 .a，动态库为 .so。</li></ul><p>二者均以文件的形式存在，其本质上是一种可执行代码的二进制格式，可以被载入内存中执行。无论是动态链接库还是静态链接库，它们无非是向其调用者提供变量、函数和类。</p><h3 id="1-静态库"><a href="#1-静态库" class="headerlink" title="1. 静态库"></a>1. 静态库</h3><p>在静态编译时由编译器到指定目录寻找并且进行链接，一旦链接完成，最终的可执行程序中就包含了该库文件中的所有有用信息，包括代码段、数据段等。</p><h3 id="2-动态库"><a href="#2-动态库" class="headerlink" title="2. 动态库"></a>2. 动态库</h3><p>在应用程序运行时，由操作系统根据应用程序的请求，动态到指定目录下寻找并装载入内存中，同时需要进行地址重定向。</p><h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3. 区别"></a>3. 区别</h3><h4 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h4><p>静态库在程序编译时会被链接到目标代码中，目标程序运行时将不再需要该库，移植方便，体积较大，浪费空间和资源，因为所有相关的对象文件与牵涉到库都被链接合成一个可执行文件，这样导致可执行文件的体积较大。</p><p>动态库在程序编译时并不会被链接到目标代码中，而是在程序运行时才被载入，因此可执行文件体积较小。有了动态库，程序的升级会相对比较简单，比如某个动态库升级了，只需要更换这个动态库的文件，而不需要去更换可执行文件。但要注意的是，可执行程序在运行时需要能找到动态库文件。</p><p><img src="/%5Cpic%5C31396_001.png"></p><h4 id="载入时刻"><a href="#载入时刻" class="headerlink" title="载入时刻"></a>载入时刻</h4><p>静态库的代码在编译过程中已经被载入可执行程序，因此体积较大。共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。</p><h3 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4. 优缺点"></a>4. 优缺点</h3><p>相对于动态库，静态库的优点在于直接被链接进可执行程序中，之后，该可执行程序就不再依赖于运行环境的设置了（仍然会依赖于 CPU 指令集和操作系统支持的可执行文件格式等硬性限制）。</p><p>而动态库的优点在于，用户可以在程序运行时随时替换该动态库，这就构成了动态插件系统的基础。</p><h2 id="三、库文件的制作"><a href="#三、库文件的制作" class="headerlink" title="三、库文件的制作"></a>三、库文件的制作</h2><h3 id="1-库文件命名"><a href="#1-库文件命名" class="headerlink" title="1. 库文件命名"></a>1. 库文件命名</h3><p>静态库的名字一般为 libxxxx.a，其中 xxxx 是该 lib 的名称；动态库的名字一般为 libxxxx.so.x.y.z，含义如下图所示：</p><p><img src="/%5Cpic%5C31396_002.png"></p><h3 id="2-制作库文件常用参数"><a href="#2-制作库文件常用参数" class="headerlink" title="2. 制作库文件常用参数"></a>2. 制作库文件常用参数</h3><p>需要了解 gcc 编译库要用到一些参数。</p><table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">-shared</td><td align="left">指定生成动态链接库</td></tr><tr><td align="left">-static</td><td align="left">指定生成静态链接库</td></tr><tr><td align="left">-fPIC</td><td align="left">表示编译为位置独立的代码，用于编译共享库。目标文件需要创建成位置无关码，概念上就是在可执行程序装载它们的时候，它们可以放在可执行程序的内存里的任何地方</td></tr><tr><td align="left">-L</td><td align="left">表示要连接的库在当前目录中</td></tr><tr><td align="left">-l</td><td align="left">指定链接时需要的动态库。编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上 lib，后面加上 .so 来确定库的名称</td></tr><tr><td align="left">-Wall</td><td align="left">生成所有警告信息</td></tr><tr><td align="left">-ggdb</td><td align="left">此选项将尽可能的生成 gdb 的可以使用的调试信息</td></tr><tr><td align="left">-g</td><td align="left">编译器在编译的时候产生调试信息</td></tr><tr><td align="left">-c</td><td align="left">只激活预处理、编译和汇编，也就是把程序做成目标文件（.o 文件）</td></tr><tr><td align="left">-Wl,options</td><td align="left">把参数（options）传递给链接器ld。如果 options 中间有逗号，就将 options 分成多个选项，然后传递给链接程序</td></tr></tbody></table><h3 id="3-库源文件"><a href="#3-库源文件" class="headerlink" title="3. 库源文件"></a>3. 库源文件</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// add.cpp</span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token operator">-</span>y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//add.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-制作静态库并使用"><a href="#4-制作静态库并使用" class="headerlink" title="4. 制作静态库并使用"></a>4. 制作静态库并使用</h3><ol><li>需要把 add.cpp 编译成 .o 文件；</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ <span class="token parameter variable">-c</span> add.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>使用 ar 命令生成静态库 libadd.a；</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 遵循静态库命名的规则 lib + 名字 + .a</span>ar <span class="token parameter variable">-rc</span> libadd.a add.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li>使用静态库，要是用静态库 libadd.a，只需要包含 add.h，就可以使用函数 add()、sub()。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// test.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"add.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"add(5, 4) is "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sub(5, 4) is "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>静态库的文件可以放在任意的位置，编译时只需要找到该库文件即可。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ test.cpp <span class="token parameter variable">-o</span> run libadd.a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>库和头文件如果在其他目录下，使用以下命令编译：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ <span class="token parameter variable">-c</span> <span class="token parameter variable">-I</span> /home/xxxx/include test.cppg++ <span class="token parameter variable">-o</span> <span class="token builtin class-name">test</span> <span class="token parameter variable">-L</span> /home/xxxx/lib test.o libadd.a<span class="token comment"># 或者</span>gcc <span class="token parameter variable">-c</span> <span class="token parameter variable">-I</span> /home/xxxx/include <span class="token parameter variable">-L</span> /home/xxxx/lib libadd.a test.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>通过 -I 指定对应的头文件；</li><li>通过 -L 制定库文件的路径，libadd.a 就是要用的静态库。</li></ul><h3 id="5-制作动态库并使用"><a href="#5-制作动态库并使用" class="headerlink" title="5. 制作动态库并使用"></a>5. 制作动态库并使用</h3><ol><li>把 add.cpp 编译成动态链接库 libadd.so；</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ <span class="token parameter variable">-fPIC</span> <span class="token parameter variable">-o</span> libadd.o <span class="token parameter variable">-c</span> add.cppg++ <span class="token parameter variable">-shared</span> <span class="token parameter variable">-o</span> libadd.so libadd.o<span class="token comment"># 或者</span>g++ <span class="token parameter variable">-fPIC</span> <span class="token parameter variable">-shared</span> <span class="token parameter variable">-o</span> libadd.so add.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>动态库的安装，通常动态库拷贝到 /lib 目录下即可；</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">cp</span> libadd.so /lib<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>使用动态库</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// test.cpp</span><span class="token comment">// ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>编译：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc static <span class="token parameter variable">-o</span> run <span class="token parameter variable">-ladd</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-动态加载的函数库"><a href="#6-动态加载的函数库" class="headerlink" title="6. 动态加载的函数库"></a>6. 动态加载的函数库</h3><p>动态加载的函数库 Dynamically loaded (DL) libraries 是一类函数库，它可以在程序运行过程中的任何时间加载。它们特别适合在函数中加载一些模块和 plugin 扩展模块的场合，因为它可以在当程序需要某个 plugin 模块时才动态的加载。</p><p>Linux 系统下，DL 函数库与其他函数库在格式上没有特殊的区别，它们创建的时候是标准的 object 格式。主要的区别就是这些函数库不是在程序链接的时候或者启动的时候加载，而是通过一个 API 来打开一个函数库，寻找符号表，处理错误和关闭函数库。</p><h4 id="6-1-dlopen"><a href="#6-1-dlopen" class="headerlink" title="6.1 dlopen"></a>6.1 dlopen</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">dlopen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// filename</span><span class="token comment">// 如果文件名 filename 是以“/”开头，也就是使用绝对路径，那么 dlopen 就直接使用它，而不去查找某些环境变量或者系统设置的函数库所在的目录了。否则 dlopen 就会按照下面的次序查找函数库文件：</span><span class="token comment">// 1. 环境变量 LD_LIBRARY 指明的路径；</span><span class="token comment">// 2. /etc/ld.so.cache 中的函数库列表；</span><span class="token comment">// 3. /lib 目录，然后 /usr/lib。</span><span class="token comment">// flag </span><span class="token comment">// 值必须是 RTLD_LAZY 或者 RTLD_NOW，</span><span class="token comment">// RTLD_LAZY：resolve undefined symbols as code from the dynamic library is executed，</span><span class="token comment">// RTLD_NOW：resolve all undefined symbols before dlopen() returns and fail if this cannot be done。</span><span class="token comment">// return</span><span class="token comment">// dlopen 函数的返回值是一个句柄，然后后面的函数就通过使用这个句柄来做进一步的操作。如果打开失败dlopen()就返回一个NULL。如果一个函数库被多次打开，它会返回同样的句柄。 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dlopen 函数打开一个函数库然后为后面的使用做准备。</p><p>如果有好几个函数库，它们之间有一些依赖关系的话，例如X依赖Y，那么你就要先加载那些被依赖的函数。例如先加载Y，然后加载X。</p><h4 id="6-2-dlerror"><a href="#6-2-dlerror" class="headerlink" title="6.2 dlerror"></a>6.2 dlerror</h4><p>通过调用 dlerror 函数，可以获得最后一次调用 dlopen，dlsym，或者 dlclose 的错误信息。</p><h4 id="6-3-dlsym"><a href="#6-3-dlsym" class="headerlink" title="6.3 dlsym"></a>6.3 dlsym</h4><p>如果加载了一个 DL 函数库而不去使用当然是不可能的了，使用一个 DL 函数库的最主要的一个函数就是 dlsym，这个函数在一个已经打开的函数库里面查找给定的符号。这个函数定义如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">dlsym</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>handle<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>symbol<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// handle：就是由 dlopen 打开后返回的句柄</span><span class="token comment">// symbol：是一个以 NIL 结尾的字符串</span><span class="token comment">// 功能：</span><span class="token comment">// 如果 dlsym 函数没有找到需要查找的 symbol，则返回 NULL。如果知道某个 symbol 的值不可能是 NULL 或者 0，就可以根据这个返回结果判断查找的 symbol 是否存在了；不过，如果某个 symbol 的值就是 NULL，那么这个判断就有问题了。标准的判断方法是先调用 dlerror，清除以前可能存在的错误，然后调用 dlsym 来访问一个 symbol，然后再调用 dlerror 来判断是否出现了错误。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-4-dlclose"><a href="#6-4-dlclose" class="headerlink" title="6.4 dlclose"></a>6.4 dlclose</h4><p>dlopen 函数的反过程就是 dlclose 函数，dlclose 函数用于关闭一个 DL 函数库。Dl 函数库维持一个资源利用的计数器，当调用 dlclose 的时候，就把这个计数器的计数减一，如果计数器为 0，则真正的释放掉。真正释放的时候，如果函数库里面有 _fini 这个函数，则自动调用 _fini 这个函数，做一些必要的处理。dlclose 返回 0 表示成功，其他非 0 值表示错误。</p><h4 id="6-5-举例"><a href="#6-5-举例" class="headerlink" title="6.5 举例"></a>6.5 举例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;dlfcn.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>add<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>sub<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token operator">*</span>libptr<span class="token punctuation">;</span>    libptr <span class="token operator">=</span> <span class="token function">dlopen</span><span class="token punctuation">(</span><span class="token string">"./libadd.so"</span><span class="token punctuation">,</span> RTLD_LAZY<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 加载动态库</span>    add <span class="token operator">=</span> <span class="token function">dlsym</span><span class="token punctuation">(</span>libptr<span class="token punctuation">,</span> <span class="token string">"add"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 获取函数地址</span>    sub <span class="token operator">=</span> <span class="token function">dlsym</span><span class="token punctuation">(</span>libptr<span class="token punctuation">,</span> <span class="token string">"sub"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"add(5,4) is %d\n"</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sub(5,4) is %d\n"</span><span class="token punctuation">,</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dlclose</span><span class="token punctuation">(</span>libptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、库的两个查看命令"><a href="#四、库的两个查看命令" class="headerlink" title="四、库的两个查看命令"></a>四、库的两个查看命令</h2><ul><li><p><strong>ldd</strong>：可以查看一个可执行程序依赖哪些库；</p></li><li><p><strong>nm</strong>：可以打印出库中的涉及到的所有符号。</p></li></ul><h2 id="五、库的安装"><a href="#五、库的安装" class="headerlink" title="五、库的安装"></a>五、库的安装</h2><p>在新安装一个库之后如何让系统能够找到它，有以下几种方法：</p><ol><li><strong>拷贝到 /lib 或者 /usr/lib 下</strong></li></ol><p>如果安装在 /lib 或者 /usr/lib 下，那么 ld 默认能够找到，无需其他操作。如果安装在其他目录，需要将其添加到 /etc/ld.so.cache 文件中，如下：</p><ol start="2"><li><strong>通过配置文件 /etc/profile</strong></li></ol><p>永久生效的环境变量设置，编辑 /etc/profile 即可。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vi</span> /etc/profile<span class="token comment"># 在文件里末尾加上对应的环境变量信息，动态库环境变量设置：</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span>/home/xxxx/mylib/<span class="token comment"># /home/xxxx/mylib/ 指的是动态库文件夹所在位置，即 .so 等文件在 /home/xxxx/mylib/ 下。</span><span class="token comment"># 编辑完成，保存编辑并退出；使配置即时生效：</span><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>通过配置文件 /etc/ld.so.conf</strong></li></ol><p>编辑 /etc/ld.so.conf 文件，加入库文件所在目录的路径。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/ld.so.conf<span class="token comment"># 添加动态库所在路径即可</span>/usr/local/lib/<span class="token comment"># 运行 ldconfig，该命令会重建 /etc/ld.so.cache 文件</span>ldconfig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打包压缩命令(Linux)</title>
      <link href="/2020/12/22/36090.html"/>
      <url>/2020/12/22/36090.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-tar-命令"><a href="#1-tar-命令" class="headerlink" title="1. tar 命令"></a>1. tar 命令</h2><p><strong>tar</strong> 命令用于对文件进行压缩或解压，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span><span class="token punctuation">[</span>文件<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>创建压缩文件</td></tr><tr><td>-x</td><td>解开压缩文件</td></tr><tr><td>-t</td><td>查看压缩包内有哪些文件</td></tr><tr><td>-z</td><td>用 Gzip 压缩或解压</td></tr><tr><td>-j</td><td>用 bzip2 压缩或解压</td></tr><tr><td>-v</td><td>显示压缩或解压的过程</td></tr><tr><td>-f</td><td>目标文件名</td></tr><tr><td>-p</td><td>保留原始的权限与属性</td></tr><tr><td>-P</td><td>使用绝对路径来压缩</td></tr><tr><td>-C</td><td>指定解压到的目录</td></tr></tbody></table><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-czvf</span> 压缩包名称.tar.gz 要打包的目录  <span class="token comment"># 把指定的文件进行打包压缩</span><span class="token function">tar</span> <span class="token parameter variable">-xzvf</span> 压缩包名称.tar.gz  <span class="token comment"># 解压</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统状态检测命令(Linux)</title>
      <link href="/2020/12/21/24227.html"/>
      <url>/2020/12/21/24227.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-ifconfig-命令"><a href="#1-ifconfig-命令" class="headerlink" title="1. ifconfig 命令"></a>1. ifconfig 命令</h2><p><strong>ifconfig</strong> 命令用于获取网卡配置与网络状态等信息，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ifconfig</span> <span class="token punctuation">[</span>网络设备<span class="token punctuation">]</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 ifconfig 命令来查看本机当前的网卡配置与网络状态等信息时，其实主要查看的就是网卡名称、inet 参数后面的 IP 地址、ether 参数后面的网卡物理地址（又称为 MAC 地址），以及 RX、TX 的接收数据包与发送数据包的个数及累计流量。</p><h2 id="2-uname-命令"><a href="#2-uname-命令" class="headerlink" title="2. uname 命令"></a>2. uname 命令</h2><p><strong>uname</strong> 命令用于查看系统内核与系统版本等信息，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">uname</span> <span class="token punctuation">[</span>-a<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在使用 uname 命令时，会固定搭配上 -a 参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息。</p><p>如果要查看当前系统版本的详细信息，则需要查看 …-release 文件，其命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /etc/system-release<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-uptime-命令"><a href="#3-uptime-命令" class="headerlink" title="3. uptime 命令"></a>3. uptime 命令</h2><p><strong>uptime</strong> 用于查看系统的负载信息，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">uptime</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息。平均负载值指的是系统在最近 1 分钟、5 分钟、15 分钟内的压力情况；负载值越低越好，尽量不要长期超过 1，在生产环境中不要超过 5。</p><h2 id="4-free-命令"><a href="#4-free-命令" class="headerlink" title="4. free 命令"></a>4. free 命令</h2><p><strong>free</strong> 用于显示当前系统中内存的使用量信息，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">free</span> <span class="token punctuation">[</span>-h<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-who-命令"><a href="#5-who-命令" class="headerlink" title="5. who 命令"></a>5. who 命令</h2><p><strong>who</strong> 用于查看当前登入主机的用户终端信息，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">who</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="6-last-命令"><a href="#6-last-命令" class="headerlink" title="6. last 命令"></a>6. last 命令</h2><p><strong>last</strong> 命令用于查看系统的所有登录记录，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">last <span class="token punctuation">[</span>参数<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="7-history-命令"><a href="#7-history-命令" class="headerlink" title="7. history 命令"></a>7. history 命令</h2><p><strong>history</strong> 命令用于显示历史执行过的命令，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">history</span> <span class="token punctuation">[</span>-c<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>能显示出当前用户在本地计算机中执行过的最近 1000 条命令记录。</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>清空所有的命令历史记录</td></tr></tbody></table><h2 id="8-sosreport-命令"><a href="#8-sosreport-命令" class="headerlink" title="8. sosreport 命令"></a>8. sosreport 命令</h2><p><strong>sosreport</strong> 命令用于收集系统配置及架构信息并输出诊断文档，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sosreport<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="9-ping-命令"><a href="#9-ping-命令" class="headerlink" title="9. ping 命令"></a>9. ping 命令</h2><p><strong>ping</strong> 命令用于验证某台主机是否在线，Linux 系统中的 ping 命令不像 Windows 一样尝试 4 次就结束，会一直验证。格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ping</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span> <span class="token punctuation">[</span>IP地址<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th><strong>参数</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>-c</td><td>规定尝试次数</td></tr><tr><td>-i</td><td>每个数据包的发送间隔</td></tr><tr><td>-W</td><td>定义等待超时时间</td></tr></tbody></table><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ping</span> <span class="token parameter variable">-c</span> <span class="token number">3</span> <span class="token parameter variable">-i</span> <span class="token number">0.2</span> <span class="token parameter variable">-W</span> <span class="token number">3</span> <span class="token number">127.0</span>.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="10-netstat-命令"><a href="#10-netstat-命令" class="headerlink" title="10. netstat 命令"></a>10. netstat 命令</h2><p><strong>netstat</strong> 命令用于显示网络连接、路由表和网络接口信息，可以让用户得知有哪些网络连接正在运作。使用时如果不带参数，netstat 显示活动的 TCP 连接。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有选项</td></tr><tr><td>-t</td><td>(tcp)仅显示tcp相关选项</td></tr><tr><td>-u</td><td>(udp)仅显示udp相关选项</td></tr><tr><td>-n</td><td>拒绝显示别名，能显示数字的全部转化成数字</td></tr><tr><td>-p</td><td>显示建立相关链接的程序名</td></tr></tbody></table><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看 8080 端口被哪个进程占用</span><span class="token function">netstat</span> <span class="token parameter variable">-anp</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">8080</span><span class="token comment"># 查看进程名为 python 的进程都有哪些连接</span><span class="token function">netstat</span> <span class="token parameter variable">-anp</span> <span class="token operator">|</span> <span class="token function">grep</span> python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-查看-CPU-信息"><a href="#11-查看-CPU-信息" class="headerlink" title="11. 查看 CPU 信息"></a>11. 查看 CPU 信息</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /proc/cpuinfo<span class="token function">top</span> <span class="token operator">&amp;&amp;</span> dstat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="12-查看内存信息"><a href="#12-查看内存信息" class="headerlink" title="12. 查看内存信息"></a>12. 查看内存信息</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /proc/meminfo<span class="token function">free</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文本文件编辑命令(Linux)</title>
      <link href="/2020/12/20/49725.html"/>
      <url>/2020/12/20/49725.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-cat-命令"><a href="#1-cat-命令" class="headerlink" title="1. cat 命令"></a>1. cat 命令</h2><p><strong>cat</strong> 命令用于查看纯文本文件（内容较少的），格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>文件<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-n</td><td>显示行号</td></tr></tbody></table><h2 id="2-more-命令"><a href="#2-more-命令" class="headerlink" title="2. more 命令"></a>2. more 命令</h2><p><strong>more</strong> 命令用于查看纯文本文件（内容较多的），格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">more</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> 文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用空格键或回车键向下翻页</p><h2 id="3-head-命令"><a href="#3-head-命令" class="headerlink" title="3. head 命令"></a>3. head 命令</h2><p><strong>head</strong> 命令用于查看纯文本文档的前 N 行，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">head</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>文件<span class="token punctuation">]</span><span class="token function">head</span> <span class="token parameter variable">-n</span> <span class="token number">20</span> main.cpp  <span class="token comment"># 查看文本中前20行的内容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="4-tail-命令"><a href="#4-tail-命令" class="headerlink" title="4. tail 命令"></a>4. tail 命令</h2><p><strong>tail</strong> 命令用于查看纯文本文档的后 N 行或持续刷新内容，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tail</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>文件<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-f</td><td>持续刷新文件</td></tr></tbody></table><h2 id="5-tr-命令"><a href="#5-tr-命令" class="headerlink" title="5. tr 命令"></a>5. tr 命令</h2><p><strong>tr</strong> 命令用于替换文本文件中的字符，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tr</span> <span class="token punctuation">[</span>原始字符<span class="token punctuation">]</span> <span class="token punctuation">[</span>目标字符<span class="token punctuation">]</span><span class="token function">cat</span> main.cpp <span class="token operator">|</span> <span class="token function">tr</span> <span class="token punctuation">[</span>a-z<span class="token punctuation">]</span> <span class="token punctuation">[</span>A-Z<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="6-wc-命令"><a href="#6-wc-命令" class="headerlink" title="6. wc 命令"></a>6. wc 命令</h2><p><strong>wc</strong> 命令用于统计指定文本的行数、字数、字节数，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wc</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span> 文本<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-l</td><td>只显示行数</td></tr><tr><td>-w</td><td>只显示单词数</td></tr><tr><td>-c</td><td>只显示字节数</td></tr></tbody></table><h2 id="7-stat-命令"><a href="#7-stat-命令" class="headerlink" title="7. stat 命令"></a>7. stat 命令</h2><p><strong>stat</strong> 命令用于查看文件的具体存储信息和时间等信息，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">stat</span> 文件名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="8-cut-命令"><a href="#8-cut-命令" class="headerlink" title="8. cut 命令"></a>8. cut 命令</h2><p><strong>cut</strong> 命令用于按”列”提取文本字符，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cut</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span> 文本<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-f</td><td>设置需要看的列数</td></tr><tr><td>-d</td><td>设置间隔符号</td></tr></tbody></table><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cut</span> -d: <span class="token parameter variable">-f1</span> /etc/passwd  <span class="token comment"># 提取出 passwd 文件中的用户名信息，即提取以冒号（:）为间隔符号的第一列内容</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="9-diff-命令"><a href="#9-diff-命令" class="headerlink" title="9. diff 命令"></a>9. diff 命令</h2><p><strong>diff</strong> 命令用于比较多个文本文件的差异，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">diff</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span> 文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>–brief</td><td>确认两个文件是否不同</td></tr><tr><td>-c</td><td>详细比较出多个文件的差异之处</td></tr></tbody></table><h2 id="10-grep-命令"><a href="#10-grep-命令" class="headerlink" title="10. grep 命令"></a>10. grep 命令</h2><p><strong>grep</strong> 命令用于在文本中执行关键词搜索，并显示匹配的结果，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span><span class="token punctuation">[</span>文件<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>将可执行文件（binary）当作文本文件（text）来搜索</td></tr><tr><td>-c</td><td>仅显示找到的行数</td></tr><tr><td>-i</td><td>忽略大小写</td></tr><tr><td>-n</td><td>显示行号</td></tr><tr><td>-v</td><td>反向选择——仅列出没有“关键字”的行</td></tr><tr><td>-r</td><td>递归搜索</td></tr><tr><td>-E</td><td>支持扩展正则表达式</td></tr><tr><td>-F</td><td>不按正则表达式匹配，按字符串字面意思匹配</td></tr><tr><td>-o</td><td>只显示模式匹配到的字符串</td></tr></tbody></table><p><strong>形式一</strong>：从指定的文件中找出匹配 pattern 的行，<code>grep [option] pattern [file1,file2,...]</code>；</p><p><strong>形式二</strong>：从管道中找出匹配 pattern 的行，<code>cmd | grep [option] pattern</code>。</p><p>说明：pattern 是由正则表达式字符及文本字符所编写的过滤条件。</p><h2 id="11-find-命令"><a href="#11-find-命令" class="headerlink" title="11. find 命令"></a>11. find 命令</h2><p><strong>find</strong> 命令用于按照指定条件来查找文件，任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件，并且将查找到的子目录和文件全部进行显示。格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> <span class="token punctuation">[</span>查找路径<span class="token punctuation">]</span> 寻找条件 操作<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-name filename</td><td>文件名称符合 filename 的文件 , 大小写敏感</td></tr><tr><td>-iname filname</td><td>文件名称符合 name 的文件，忽略大小写</td></tr><tr><td>-empty</td><td>空文件</td></tr><tr><td>-size</td><td>指定文件大小</td></tr></tbody></table><ul><li>find [path] -name [filename]：在 path 目录下查找文件名为 filename 的文件，大小写敏感；</li><li>find [path] -iname [filename]：在 path 目录下查找文件名为 filename 的文件，大小写不敏感；</li><li>find [path] -empty：在 path 目录下查找文件大小为空的文件；</li><li>find [path] -size [fileszie]：查找定长的文件；</li><li>find [path] -size +[filesize]：查找大于 filesize 的文件；</li><li>find [path] -size -[filesize]：查找小于 filesize 的文件；</li><li>find [path] -size +[filesize1] -size -[filesize2]：查找大于 filesize1 的文件并且小于 filesize2 的文件。</li></ul><h2 id="12-uniq-命令"><a href="#12-uniq-命令" class="headerlink" title="12. uniq 命令"></a>12. uniq 命令</h2><p><strong>uniq</strong> 命令用于检查及删除文本文件中重复出现的行列；如果使用该命令不加任何命令行参数，则视为删除指定文本文件当中重复的行之后进行输出；如果指定输出文件，则输出到指定文件当中。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">uniq</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span> <span class="token punctuation">[</span>输入文件<span class="token punctuation">]</span> <span class="token punctuation">[</span>输出文件<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>在每列旁边显示该行重复出现的次数</td></tr><tr><td>-u</td><td>仅显示出现一次的行</td></tr><tr><td>-d</td><td>仅显示重复出现的行列</td></tr></tbody></table><p>[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据。</p><p>[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。</p><ul><li>uniq [filename]：去除文件当中重复的行，输出到标准输出设备；</li><li>uniq [filename1][filename2]：删除文件当中重复的行，输出到指定文件当中；</li><li>uniq -c [filename]：在每列旁边显示该行重复的次数；</li><li>uniq -u [filename]：显示只出现一次的行。</li></ul><h2 id="13-sed-命令"><a href="#13-sed-命令" class="headerlink" title="13. sed 命令"></a>13. sed 命令</h2><p><strong>sed</strong> 是一个精简的、非交互式的流式编辑器，它在命令行中输入编辑命令和指定文件名，然后在屏幕上查看输出。</p><p><strong>sed 的工作方式</strong>：逐行读取文件内容存储在临时缓冲区中，称为“模式空间”（pattern space），接着用 sed 命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。原文件内容并没有改变。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span> <span class="token string">"pattern command"</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-n</td><td>只打印模式匹配的行</td></tr><tr><td>-e</td><td>直接在命令行进行 sed 编辑，默认选项</td></tr><tr><td>-f</td><td>编辑动作保存在文件中，指定文件执行</td></tr><tr><td>-r</td><td>支持扩展正则表达式</td></tr><tr><td>-i</td><td>直接修改文件内容</td></tr></tbody></table><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> <span class="token function">passwd</span><span class="token comment"># root:x:0:0:root:/root:/bin/bash</span><span class="token comment"># bin:x:1:1:bin:/bin:/sbin/nologin</span><span class="token comment"># daemon:x:2:2:ROOT:/sbin:/sbin/nologin</span><span class="token comment"># adm:x:3:4:Root:/var/adm:/sbin/nologin</span><span class="token comment"># lp:x:4:7:lp:/var/spool/lpd:</span><span class="token function">sed</span> <span class="token parameter variable">-n</span> <span class="token string">'/root/p'</span> <span class="token function">passwd</span> <span class="token comment"># root:x:0:0:root:/root:/bin/bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-sort-命令"><a href="#14-sort-命令" class="headerlink" title="14. sort 命令"></a>14. sort 命令</h2><p><strong>sort</strong> 命令可以针对文本文件的内容，按行进行排序。在排序的时候以指定分隔符对文本文件进行内容分列。对指定列进行升序或降序排列，并且在排序的同时可以指定是否忽略大小写。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sort</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span><span class="token punctuation">[</span>-o<span class="token operator">&lt;</span>输出文件<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-t<span class="token operator">&lt;</span>分隔字符<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>+<span class="token operator">&lt;</span>起始栏位<span class="token operator">&gt;</span>-<span class="token operator">&lt;</span>结束栏位<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>文件<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>忽略每行前面开始的空格字符,空格数量不固定时,该选项几乎是必须要使用的</td></tr><tr><td>-f</td><td>将小写字母视为大写字母</td></tr><tr><td>-n</td><td>依照数值的大小排序</td></tr><tr><td>-r</td><td>降序</td></tr><tr><td>-o&lt;输出文件&gt;</td><td>将排序后的结果存入指定的文件</td></tr><tr><td>-t&lt;分隔字符&gt;</td><td>指定分隔符，默认的分隔符为空白字符和非空白字符之间的空字符</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件目录管理命令(Linux)</title>
      <link href="/2020/12/18/38559.html"/>
      <url>/2020/12/18/38559.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-pwd-命令"><a href="#1-pwd-命令" class="headerlink" title="1. pwd 命令"></a>1. pwd 命令</h2><p><strong>pwd</strong> 命令用于显示用户当前所处的工作目录，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">pwd</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-cd-命令"><a href="#2-cd-命令" class="headerlink" title="2. cd 命令"></a>2. cd 命令</h2><p><strong>cd</strong> 命令用于切换工作路径，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token punctuation">[</span>目录名称<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一些常用的搭配：</p><ul><li><code>cd -</code>：返回到上次所处的目录</li><li><code>cd ..</code>：进入上级目录</li><li><code>cd ~</code>：切换到当前用户的家目录</li><li><code>cd ~username</code>：切换到其他用户的家目录</li></ul><h2 id="3-ls-命令"><a href="#3-ls-命令" class="headerlink" title="3. ls 命令"></a>3. ls 命令</h2><p><strong>ls</strong> 命令用于显示目录中的文件信息，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>文件<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>查看全部文件（包括隐藏文件）</td></tr><tr><td>-l</td><td>查看文件的属性、大小等详细信息，缩写 ll(ls -l)</td></tr><tr><td>-d</td><td>查看目录属性信息</td></tr></tbody></table><h2 id="4-touch-命令"><a href="#4-touch-命令" class="headerlink" title="4. touch 命令"></a>4. touch 命令</h2><p><strong>touch</strong> 命令用于创建空白文件或设置文件的时间，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>文件<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>仅修改”读取时间”(atime)</td></tr><tr><td>-m</td><td>仅修改”修改时间”(mtime)</td></tr><tr><td>-d</td><td>同时修改 atime 与 mtime</td></tr></tbody></table><h2 id="5-mkdir-命令"><a href="#5-mkdir-命令" class="headerlink" title="5. mkdir 命令"></a>5. mkdir 命令</h2><p><strong>mkdir</strong> 命令用于创建空白的目录，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> 目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-p</td><td>递归创建出具有嵌套层关系的文件目录</td></tr></tbody></table><h2 id="6-cp-命令"><a href="#6-cp-命令" class="headerlink" title="6. cp 命令"></a>6. cp 命令</h2><p><strong>cp</strong> 命令用于复制文件或目录，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> 源文件 目标文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Linux 系统中，复制操作具体分为 3 种情况：</p><ul><li>如果目标文件是目录，则会把源文件复制到该目录中；</li><li>如果目标文件也是普通文件，则会询问是否要覆盖它；</li><li>如果目标文件不存在，则执行正常的复制操作。</li></ul><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-p</td><td>保留原始文件的属性</td></tr><tr><td>-d</td><td>若对象为“链接文件”，则保留该“链接文件”的属性</td></tr><tr><td>-r</td><td>递归持续复制（用于目录）</td></tr><tr><td>-i</td><td>若目标文件存在则询问是否覆盖</td></tr><tr><td>-a</td><td>相当于-pdr（p、d、r 为上述参数）</td></tr></tbody></table><h2 id="7-mv-命令"><a href="#7-mv-命令" class="headerlink" title="7. mv 命令"></a>7. mv 命令</h2><p><strong>mv</strong> 命令用于剪切文件或将文件重命名，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> 源文件 <span class="token punctuation">[</span>目标路径<span class="token operator">|</span>目标文件名<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>剪切操作不同于复制操作，因为它会默认把源文件删除掉，只保留剪切后的文件。如果在同一个目录中对一个文件进行剪切操作，其实也就是对其进行重命名。</p><h2 id="8-rm-命令"><a href="#8-rm-命令" class="headerlink" title="8. rm 命令"></a>8. rm 命令</h2><p><strong>rm</strong> 命令用于删除文件或目录，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> 文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-f</td><td>强制删除</td></tr><tr><td>-r</td><td>删除一个目录</td></tr></tbody></table><h2 id="9-dd-命令"><a href="#9-dd-命令" class="headerlink" title="9. dd 命令"></a>9. dd 命令</h2><p><strong>dd</strong> 命令用于按照指定大小和个数的数据块来复制文件或转换文件，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">dd</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>if</td><td>输入的文件名称</td></tr><tr><td>or</td><td>输出的文件名称</td></tr><tr><td>bs</td><td>设置每个“块”的大小</td></tr><tr><td>count</td><td>设置要复制“块”的个数</td></tr></tbody></table><h2 id="10-file-命令"><a href="#10-file-命令" class="headerlink" title="10. file 命令"></a>10. file 命令</h2><p><strong>file</strong> 命令用于查看文件的类型，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">file</span> 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用系统工作命令(Linux)</title>
      <link href="/2020/12/16/61325.html"/>
      <url>/2020/12/16/61325.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-echo-命令"><a href="#1-echo-命令" class="headerlink" title="1. echo 命令"></a>1. echo 命令</h2><p><strong>echo</strong> 命令用于在终端输出字符串或变量提取后的值。格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token punctuation">[</span>字符串<span class="token operator">|</span>$变量<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Linux 系统中变量名一般大写。</p><h2 id="2-date-命令"><a href="#2-date-命令" class="headerlink" title="2. date 命令"></a>2. date 命令</h2><p><strong>date</strong> 命令用于显示及设置系统的时间或日期，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">date</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span><span class="token punctuation">[</span>+指定的格式<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>%t</td><td>跳格[Tab键]</td></tr><tr><td>%H</td><td>小时（00~23）</td></tr><tr><td>%I</td><td>小时（00~12）</td></tr><tr><td>%M</td><td>分钟</td></tr><tr><td>%S</td><td>秒</td></tr><tr><td>%i</td><td>今年中的第几天</td></tr><tr><td>%Y</td><td>年</td></tr><tr><td>%m</td><td>月</td></tr><tr><td>%d</td><td>日</td></tr></tbody></table><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">date</span> <span class="token string">"+%Y-%m-%d %H:%M:%S"</span>  <span class="token comment"># 2020-07-07 09:21:30</span><span class="token function">date</span> <span class="token parameter variable">-s</span> <span class="token string">"20200808 08:30:00"</span>  <span class="token comment"># 设置系统时间</span><span class="token function">date</span> <span class="token string">"+%j"</span>  <span class="token comment"># 查看今天是当年中的第几天</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3-reboot-命令"><a href="#3-reboot-命令" class="headerlink" title="3. reboot 命令"></a>3. reboot 命令</h2><p><strong>reboot</strong> 命令用于重启系统，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">reboot</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-poweroff-命令"><a href="#4-poweroff-命令" class="headerlink" title="4. poweroff 命令"></a>4. poweroff 命令</h2><p><strong>poweroff</strong> 命令用于关闭系统，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">poweroff<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-wget-命令"><a href="#5-wget-命令" class="headerlink" title="5. wget 命令"></a>5. wget 命令</h2><p><strong>wget</strong> 命令用于在终端中下载网络文件，格式为</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span> 下载地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>后台下载模式</td></tr><tr><td>-P</td><td>下载到指定目录</td></tr><tr><td>-t</td><td>最大尝试次数</td></tr><tr><td>-c</td><td>断点续传</td></tr><tr><td>-p</td><td>下载页面内所有资源，包括图片、视频等</td></tr><tr><td>-r</td><td>递归下载（下载某个目录下的所有文件）</td></tr></tbody></table><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> <span class="token parameter variable">-r</span> <span class="token parameter variable">-p</span> https://ww.baidu.com  <span class="token comment"># 递归下载 www.baidu.com 网站内的所有页面数据以及文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="6-ps-命令"><a href="#6-ps-命令" class="headerlink" title="6. ps 命令"></a>6. ps 命令</h2><p><strong>ps</strong> 命令用于查看系统中进程状态，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程（包括其他用户的进程）</td></tr><tr><td>-u</td><td>用户以及其他详细信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>在 linux 系统中，有 5 种常见的进程状态，分别为运行、中断、不可中断、僵死和停止。</p><ul><li>R（运行）：进程正在运行或在运行队列中等待；</li><li>S（中断）：进程处于休眠中，当某个条件形成后或者接受到信号时，则脱离该状态；</li><li>D（不可中断）：进程不响应系统异步信号，即便用 kill 命令也不能将其中断；</li><li>Z（僵死）：进程已经终止，但进程描述符依然存在，直到父进程调用 wait() 系统函数后将进程释放；</li><li>T（停止）：进程收到停止信号后停止运行。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> <span class="token parameter variable">-aux</span> <span class="token comment"># 命令参数有长短格式之分，短格式和短格式之间是可以合并的，合并后仅保留一个-(减号)即可。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="7-top-命令"><a href="#7-top-命令" class="headerlink" title="7. top 命令"></a>7. top 命令</h2><p><strong>top</strong> 命令用于动态地监视进程活动与系统负载等信息，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">top</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>top 命令相当强大，能够动态地查看系统运维状态，完全将它看作 Linux 中的“强化版的 Windows 任务管理器”。</p><p><img src="/pic/61325_001.jpg" alt="top"></p><p>前 5 行是统计信息区：</p><p>第一行是任务队列信息，同 uptime 命令的执行结果。其中 load 表示系统负载(任务队列的平均长度)，值越大表示当前系统就越繁忙。</p><p>第二、三行是进程和 CPU 的信息。当有多个 CPU 时，这些内容可能会超过两行。</p><p>第四、五行是内存信息，</p><p>第四行（Mem）：total 物理内存总量，used 使用的物理内存总量，free 空闲内存总量，buffers 用作内核缓存的内存量；</p><p>第五行（Swap）：分区的使用情况。</p><p>接下来是进程列表，默认按照 CPU 占用情况降序排序（第一行就是当前占用 CPU 最多的进程）</p><p>常用列解释:</p><table><thead><tr><th>列名</th><th>说明</th></tr></thead><tbody><tr><td>PID</td><td>进程 id</td></tr><tr><td>USER</td><td>进程拥有者的用户 id</td></tr><tr><td>PR</td><td>进程优先级</td></tr><tr><td>NI</td><td>nice 值，和 PR 搭配使用</td></tr><tr><td>VIRT</td><td>虚拟内存使用情况</td></tr><tr><td>RES</td><td>物理内存使用情况(如果进程使用的物理内存的和接近机器的物理内存总量, 就会出现内存不够用的情况)</td></tr><tr><td>%CPU</td><td>该进程占用 CPU 的百分比(多核机器这个值可以超过 100%)</td></tr><tr><td>COMMAND</td><td>对应到这个进程启动的命令</td></tr></tbody></table><p>top 的一些常见用法：</p><ul><li>查看占用内存最多的前 N 个进程：先执行 top 命令, 再使用快捷键 M 即可按内存占用降序排序；</li><li>查看 CPU 占用最多的前 N 个进程：先执行 top 命令, 再使用快捷键 P 即可按照 CPU 占用降序排序；</li><li>查看某个进程中的线程情况：<code>top -p [pid]</code>，然后再使用快捷键 H 即可查看线程相关信息。</li></ul><h2 id="8-pidof-命令"><a href="#8-pidof-命令" class="headerlink" title="8. pidof 命令"></a>8. pidof 命令</h2><p><strong>pidof</strong> 命令用于查询某个指定服务进程的 PID 值，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pidof <span class="token punctuation">[</span>参数<span class="token punctuation">]</span><span class="token punctuation">[</span>服务名称<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="9-kill-命令"><a href="#9-kill-命令" class="headerlink" title="9. kill 命令"></a>9. kill 命令</h2><p><strong>kill</strong> 命令用于终止某个指定 PID 的服务进程，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span><span class="token punctuation">[</span>进程PID<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="10-killall-命令"><a href="#10-killall-命令" class="headerlink" title="10. killall 命令"></a>10. killall 命令</h2><p><strong>killall</strong> 命令用于终止某个指定名称的服务所对应的全部进程，格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">killall</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span><span class="token punctuation">[</span>进程名称<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>库特性(C++14)</title>
      <link href="/2020/10/23/15266.html"/>
      <url>/2020/10/23/15266.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、std-exchange-函数"><a href="#一、std-exchange-函数" class="headerlink" title="一、std::exchange 函数"></a>一、std::exchange 函数</h2><p>定义于头文件 <code>&lt;utility&gt;</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">U</span> <span class="token operator">=</span> T<span class="token operator">&gt;</span><span class="token keyword">constexpr</span> T <span class="token function">exchange</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> obj<span class="token punctuation">,</span> U<span class="token operator">&amp;&amp;</span> new_value<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>以 new_value 替换 obj 的值，并返回 obj 的旧值。</p><p><strong>注意：</strong>T 必须满足可移动构造的要求，而且必须能移动赋值 U 类型对象给 T 类型对象。</p><p><code>std::exchange</code> 的实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">U</span> <span class="token operator">=</span> T<span class="token operator">&gt;</span><span class="token keyword">constexpr</span> T <span class="token function">exchange</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> obj<span class="token punctuation">,</span> U<span class="token operator">&amp;&amp;</span> new_value<span class="token punctuation">)</span><span class="token punctuation">{</span>    T old_value <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    obj <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>U<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>new_value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> old_value<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般用在<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>中。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span>    <span class="token keyword">char</span><span class="token operator">*</span> val_<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Foo</span><span class="token punctuation">(</span>Foo<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>         <span class="token operator">:</span> val_<span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span><span class="token function">exchange</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>val_<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span>    Foo<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Foo<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>     <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token punctuation">{</span>            val_ <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">exchange</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>val_<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// move val_, while leaving zero in other.val_</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、std-make-unique-函数"><a href="#二、std-make-unique-函数" class="headerlink" title="二、std::make_unique 函数"></a>二、std::make_unique 函数</h2><p>C++11 中有 <strong>std::make_shared</strong>，却没有 <strong>std::make_unique</strong>，在 C++14 中已经改善。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ptr <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 100</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、std-quoted-函数"><a href="#三、std-quoted-函数" class="headerlink" title="三、std::quoted 函数"></a>三、std::quoted 函数</h2><p>默认用于给字符串添加或解除双引号。定义于头文件 <code>&lt;iomanip&gt;</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">CharT</span><span class="token operator">&gt;</span><span class="token comment">/* unspecified */</span> <span class="token function">quoted</span><span class="token punctuation">(</span><span class="token keyword">const</span> CharT<span class="token operator">*</span> s<span class="token punctuation">,</span> CharT delim <span class="token operator">=</span> <span class="token function">CharT</span><span class="token punctuation">(</span><span class="token char">'"'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> CharT escape <span class="token operator">=</span> <span class="token function">CharT</span><span class="token punctuation">(</span><span class="token char">'\\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">CharT</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Traits</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Allocator</span> <span class="token operator">&gt;</span><span class="token comment">/* unspecified */</span> <span class="token function">quoted</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>basic_string<span class="token operator">&lt;</span>CharT<span class="token punctuation">,</span> Traits<span class="token punctuation">,</span> Allocator<span class="token operator">&gt;</span><span class="token operator">&amp;</span> s<span class="token punctuation">,</span> CharT delim<span class="token operator">=</span><span class="token function">CharT</span><span class="token punctuation">(</span><span class="token char">'"'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> CharT escape<span class="token operator">=</span><span class="token function">CharT</span><span class="token punctuation">(</span><span class="token char">'\\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">CharT</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Traits</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Allocator</span> <span class="token operator">&gt;</span><span class="token comment">/* unspecified */</span> <span class="token function">quoted</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>basic_string<span class="token operator">&lt;</span>CharT<span class="token punctuation">,</span> Traits<span class="token punctuation">,</span> Allocator<span class="token operator">&gt;</span><span class="token operator">&amp;</span> s<span class="token punctuation">,</span> CharT delim<span class="token operator">=</span><span class="token function">CharT</span><span class="token punctuation">(</span><span class="token char">'"'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> CharT escape<span class="token operator">=</span><span class="token function">CharT</span><span class="token punctuation">(</span><span class="token char">'\\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-参数"><a href="#1-参数" class="headerlink" title="1. 参数"></a>1. 参数</h3><ul><li>s：要插入或输出的字符串；</li><li>delim：用作分隔符的字符，默认为”；</li><li>escape：用作转义字符的字符，默认为\ 。</li></ul><h3 id="2-流程"><a href="#2-流程" class="headerlink" title="2. 流程"></a>2. 流程</h3><ol><li>添加 delim 到序列中；</li><li>序列中添加每个来在 s 的字符，若下一个要添加的字符等于 delim 或等于 escape，首先附加 escape 到序列中；</li><li>添加 delim 到序列中。</li></ol><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>stringstream ss<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>string out<span class="token punctuation">,</span> in<span class="token punctuation">{</span> <span class="token string">"String with spaces, and embedded \"quotes\" too"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> show <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> what<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>what <span class="token operator">==</span> <span class="token operator">&amp;</span>in<span class="token punctuation">)</span> <span class="token punctuation">{</span>            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"in  ["</span> <span class="token operator">&lt;&lt;</span> in <span class="token operator">&lt;&lt;</span> <span class="token string">"]\n"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"ss  ["</span> <span class="token operator">&lt;&lt;</span> ss<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"]\n\n"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"out ["</span> <span class="token operator">&lt;&lt;</span> out <span class="token operator">&lt;&lt;</span> <span class="token string">"]\n\n"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    ss <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token function">quoted</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* 在字符串两端添加 "，并对字符串内部的 " 前增加 \ */</span>    <span class="token function">show</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>    ss <span class="token operator">&gt;&gt;</span> std<span class="token double-colon punctuation">::</span><span class="token function">quoted</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 解除字符串两端的 "</span>    <span class="token function">show</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    ss<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    in <span class="token operator">=</span> <span class="token string">"String with spaces, and embedded $quotes$ too"</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> delim<span class="token punctuation">{</span> <span class="token char">'$'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> escape<span class="token punctuation">{</span> <span class="token char">'%'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    ss <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token function">quoted</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> delim<span class="token punctuation">,</span> escape<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 字符串两端增加 $，对内部的 $ 前增加 %</span>    <span class="token function">show</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>    ss <span class="token operator">&gt;&gt;</span> std<span class="token double-colon punctuation">::</span><span class="token function">quoted</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> delim<span class="token punctuation">,</span> escape<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">show</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-结果"><a href="#4-结果" class="headerlink" title="4. 结果"></a>4. 结果</h3><p><img src="/%5Cpic%5C15266_001.png" alt="quoted"></p><h2 id="四、std-shared-timed-mutex-类与-std-shared-lock-类"><a href="#四、std-shared-timed-mutex-类与-std-shared-lock-类" class="headerlink" title="四、std::shared_timed_mutex 类与 std::shared_lock 类"></a>四、std::shared_timed_mutex 类与 std::shared_lock 类</h2><h3 id="1-std-shared-timed-mutex"><a href="#1-std-shared-timed-mutex" class="headerlink" title="1. std::shared_timed_mutex"></a>1. std::shared_timed_mutex</h3><p>定义于头文件 <code>&lt;shared_mutex&gt;</code>。</p><p><code>std::shared_timed_mutex</code> 类是能用于保护数据免受多个线程同时访问的同步原语。与其他促进排他性访问的互斥类型相反，拥有二个层次的访问：</p><ul><li>共享 - 多个线程能共享同一互斥的所有权</li><li>排他性 - 仅一个线程能占有互斥</li></ul><p>共享互斥通常用于多个读线程能同时访问同一资源而不导致数据竞争，但只有一个写线程能访问的情形。</p><h3 id="2-std-shared-lock"><a href="#2-std-shared-lock" class="headerlink" title="2. std::shared_lock"></a>2. std::shared_lock</h3><p>定位于头文件 <code>&lt;shared_mutex&gt;</code>。</p><p><code>std::shared_lock</code> 是通用共享互斥所有权包装器，允许延迟锁定、定时锁定和锁所有权的转移。会以共享模式锁定关联的共享互斥（<code>std::unique_lock</code> 可用于以排他性模式锁定）。</p><p><code>std::shared_lock</code> 类可移动，但不可复制——它满足<strong>可移动构造</strong>与<strong>可移动赋值</strong>的要求，但不满足<strong>可复制构造</strong>或<strong>可复制赋值</strong>。</p><h3 id="3-示例-1"><a href="#3-示例-1" class="headerlink" title="3. 示例"></a>3. 示例</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;shared_mutex&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">SharedTimedMutexCounter</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">SharedTimedMutexCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">SharedTimedMutexCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>shared_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>shared_timed_mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> m_value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>shared_timed_mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>m_value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">mutable</span> std<span class="token double-colon punctuation">::</span>shared_timed_mutex m_mutex<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> m_value<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、std-integer-sequence-类"><a href="#五、std-integer-sequence-类" class="headerlink" title="五、std::integer_sequence 类"></a>五、std::integer_sequence 类</h2><p>定义于头文件 <code>&lt;utility&gt;</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ints<span class="token operator">&gt;</span><span class="token keyword">struct</span> <span class="token class-name">integer_sequence</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>类模板 <code>std::integer_sequence</code> 表示一个编译时的整数序列。在用作<strong>函数模板</strong>的实参时，能推导参数包 <code>Ints</code> 并将它用于包展开。</p><h3 id="1-成员函数"><a href="#1-成员函数" class="headerlink" title="1. 成员函数"></a>1. 成员函数</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">constexpr</span> size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>Ints<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-辅助模板"><a href="#2-辅助模板" class="headerlink" title="2. 辅助模板"></a>2. 辅助模板</h3><ul><li><code>std::index_sequence</code>：T 为 <code>std::size_t</code> 的常用情况，定义别名模板；</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ints<span class="token operator">&gt;</span><span class="token keyword">using</span> index_sequence <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>integer_sequence<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">,</span> Ints<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>std::make_integer_sequence</code> 与 <code>std::make_index_sequence</code>：以简化以 0, 1, 2, …, N-1 为 <code>Ints</code> 创建 <code>std::integer_sequence</code> 与 <code>std::index_sequence</code>；</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> T N<span class="token operator">&gt;</span><span class="token keyword">using</span> make_integer_sequence <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>integer_sequence<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token comment">/* a sequence 0, 1, 2, ..., N-1 */</span> <span class="token operator">&gt;</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>size_t N<span class="token operator">&gt;</span> <span class="token keyword">using</span> make_index_sequence <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>make_integer_sequence<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">,</span> N<span class="token operator">&gt;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若 <code>N</code> 为负，则程序为谬构。若 <code>N</code> 为零，则指示类型为 <code>integer_sequence&lt;T&gt;</code> 。</p><ul><li>类模板 <code>std::index_sequence_for</code>：以转换任何类型参数包为同长度的下标序列；</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> T<span class="token operator">&gt;</span> <span class="token keyword">using</span> index_sequence_for <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>make_index_sequence<span class="token operator">&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-示例-2"><a href="#3-示例-2" class="headerlink" title="3. 示例"></a>3. 示例</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;tuple&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;array&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> ints<span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token function">printSequence</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>integer_sequence<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> ints<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span> int_seq<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The sequence of size "</span> <span class="token operator">&lt;&lt;</span> int_seq<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> _<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> ints <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 与 tuple 的结合</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Array</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> I<span class="token operator">&gt;</span><span class="token keyword">auto</span> <span class="token function">arry2tupleImpl</span><span class="token punctuation">(</span><span class="token keyword">const</span> Array<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>index_sequence<span class="token operator">&lt;</span>I<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">make_tuple</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>I<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t N<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Indices</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>make_index_sequence<span class="token operator">&lt;</span>N<span class="token operator">&gt;&gt;</span><span class="token keyword">auto</span> <span class="token function">arry2tuple</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>array<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> N<span class="token operator">&gt;</span><span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">arry2tupleImpl</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> Indices<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 打印 tuple</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Ch</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Tr</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Tuple</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Int<span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token function">printTupleImpl</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>basic_ostream<span class="token operator">&lt;</span>Ch<span class="token punctuation">,</span> Tr<span class="token operator">&gt;</span><span class="token operator">&amp;</span> os<span class="token punctuation">,</span> <span class="token keyword">const</span> Tuple<span class="token operator">&amp;</span> t<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>index_sequence<span class="token operator">&lt;</span>Int<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 使用逗号运算符，解包</span>    <span class="token keyword">int</span> _<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>os <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>Int <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">""</span> <span class="token operator">:</span> <span class="token string">","</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Ch</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Tr</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">&gt;</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>basic_ostream<span class="token operator">&lt;</span>Ch<span class="token punctuation">,</span> Tr<span class="token operator">&gt;</span><span class="token operator">&amp;</span> os<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    os <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span><span class="token punctuation">;</span>    <span class="token function">printTupleImpl</span><span class="token punctuation">(</span>os<span class="token punctuation">,</span> t<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>index_sequence_for<span class="token operator">&lt;</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> os <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// std::integer_sequence</span>    <span class="token function">printSequence</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>integer_sequence<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// std::index_sequence</span>    <span class="token function">printSequence</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>index_sequence<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">43</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// std::make_integer_sequence</span>    <span class="token function">printSequence</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>make_integer_sequence<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// std::make_index_sequence</span>    <span class="token function">printSequence</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>make_index_sequence<span class="token operator">&lt;</span><span class="token number">10</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// std::index_sequence_for</span>    <span class="token function">printSequence</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>index_sequence_for<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>iostream<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// printSequence(std::make_integer_sequence&lt;int, -5&gt;{});  // error</span>    std<span class="token double-colon punctuation">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token operator">&gt;</span> array <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> tuple <span class="token operator">=</span> <span class="token function">arry2tuple</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static_assert</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>tuple<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> tuple <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、用户定义字面量"><a href="#六、用户定义字面量" class="headerlink" title="六、用户定义字面量"></a>六、用户定义字面量</h2><h3 id="1-std-chrono-duration"><a href="#1-std-chrono-duration" class="headerlink" title="1. std::chrono::duration"></a>1. std::chrono::duration</h3><p>定义于内联命名空间 <code>std::literals::chrono_literals</code></p><table><thead><tr><th>字面量</th><th>含义</th></tr></thead><tbody><tr><td>operator””h</td><td>表示小时的 <strong>std::chrono::duration</strong> 字面量(函数)</td></tr><tr><td>operator””min</td><td>表示分钟的 <strong>std::chrono::duration</strong> 字面量(函数)</td></tr><tr><td>operator””s</td><td>表示秒的 <strong>std::chrono::duration</strong> 字面量(函数)</td></tr><tr><td>operator””ms</td><td>表示毫秒的 <strong>std::chrono::duration</strong> 字面量(函数)</td></tr><tr><td>operator””us</td><td>表示微秒的 <strong>std::chrono::duration</strong> 字面量(函数)</td></tr><tr><td>operator””ns</td><td>表示纳秒的 <strong>std::chrono::duration</strong> 字面量(函数)</td></tr></tbody></table><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token double-colon punctuation">::</span>chrono_literals<span class="token punctuation">;</span><span class="token keyword">auto</span> day <span class="token operator">=</span> <span class="token number">24</span>h<span class="token punctuation">;</span>day<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// == 24</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">duration_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>minutes<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>day<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// == 1440</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-std-basic-string"><a href="#2-std-basic-string" class="headerlink" title="2. std::basic_string"></a>2. std::basic_string</h3><p>定义于内联命名空间 <code>std::literals::string_literals</code></p><table><thead><tr><th>字面量</th><th>含义</th></tr></thead><tbody><tr><td>operator””s</td><td>转换字符数组字面量为 <code>basic_string</code> (函数)</td></tr></tbody></table><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;string&gt;#include &lt;iostream&gt;using namespace std::string_literals;int main(){    std::string s1 = "abc\0\0def";    std::string s2 = "abc\0\0def"s;    std::cout &lt;&lt; "s1: " &lt;&lt; s1.size() &lt;&lt; " \"" &lt;&lt; s1 &lt;&lt; "\"\n";    std::cout &lt;&lt; "s2: " &lt;&lt; s2.size() &lt;&lt; " \"" &lt;&lt; s2 &lt;&lt; "\"\n";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++14 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语言特性(C++14)</title>
      <link href="/2020/10/23/21834.html"/>
      <url>/2020/10/23/21834.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、二进制字面量与数位分隔符"><a href="#一、二进制字面量与数位分隔符" class="headerlink" title="一、二进制字面量与数位分隔符"></a>一、二进制字面量与数位分隔符</h2><p>C++14 引入了二进制字面量，也引入了分隔符<code>'</code>，防止眼花。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0b1111'1111</span><span class="token punctuation">;</span>  <span class="token comment">// 二进制字面量  255</span>    a <span class="token operator">=</span> <span class="token number">0b110</span><span class="token punctuation">;</span>  <span class="token comment">// 6</span>    <span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token number">3.14'159'265'3</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、constexpr-的限制"><a href="#二、constexpr-的限制" class="headerlink" title="二、constexpr 的限制"></a>二、constexpr 的限制</h2><p>C++14 相较于 C++11 对 <code>constexpr</code> 减少了一些限制：</p><ul><li>C++11 中 <code>constexpr</code> 函数可以使用递归，在 C++14 中可以使用局部变量和循环。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// c++14 和 c++11 均可</span><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> n <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 当 n 是较大的字面量时，编译时并不会进行计算结果，VS2019 测试</span><span class="token comment">// c++11 中不可，c++14 中可以</span><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 当 n 是较大的字面量时，编译时会做一些优化（不会调用 factorial 函数），直接输出结果，VS2019 测试</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>C++11 中 <code>constexpr</code> 函数必须把所有东西都放在一个单独的 return 语句中，而 C++14 则无此限制。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// c++14 和 c++11 均可</span><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// c++11 中不可，c++14 中可以</span><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">bool</span> flag<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、-deprecated-标记"><a href="#三、-deprecated-标记" class="headerlink" title="三、[[deprecated]] 标记"></a>三、[[deprecated]] 标记</h2><p>C++14 中增加了 <code>deprecated</code> 标记，指示声明有此属性的名字或实体被弃用，即允许但不鼓励使用。</p><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span><span class="token punctuation">[</span>deprecated<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token function">deprecated</span><span class="token punctuation">(</span>字符字面量<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>字符字面量 - 能用于解释弃用的理由并/或提议代替用实体的文本。</p><h3 id="2-解释"><a href="#2-解释" class="headerlink" title="2. 解释"></a>2. 解释</h3><p>允许使用声明有此属性的名称或实体，但不鼓励使用。编译器通常会对其使用情况发出警告。若指定了字符字面量，则它通常被包含于警告中。</p><p>下列名字或实体的声明中允许使用这个属性：</p><ul><li>class/struct/union：<code>struct [[deprecated]] S;</code></li><li>typedef（别名声明）：<code>[[deprecated]] typedef S* PS;、using PS [[deprecated]] = S*;</code></li><li>变量，包括静态数据成员：<code>[[deprecated]] int x;</code></li><li>非静态数据成员：<code>union U { [[deprecated]] int n; };</code></li><li>函数：<code>[[deprecated]] void f();</code></li><li>命名空间：<code>namespace [[deprecated]] NS { int x; }</code></li><li>枚举：<code>enum [[deprecated]] E {};</code></li><li>枚举项：<code>enum { A [[deprecated]], B [[deprecated]] = 42 };</code></li><li>模板特化：<code>template&lt;&gt; struct [[deprecated]] X&lt;int&gt; {};</code></li></ul><p>声明时未弃用的名字可被重声明为 <code>deprecated</code>。声明为 <code>deprecated</code> 的名字不能通过重声明它而不带此属性变为未弃用。</p><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">[</span>deprecated<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token keyword">void</span> <span class="token function">triassicPeriod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Triassic Period: [251.9 - 208.5] million years ago.\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token function">deprecated</span><span class="token punctuation">(</span><span class="token string">"Use neogenePeriod() instead."</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token keyword">void</span> <span class="token function">jurassicPeriod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Jurassic Period: [201.3 - 152.1] million years ago.\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">[</span><span class="token punctuation">[</span>deprecated<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">int</span> test <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>    <span class="token function">triassicPeriod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">jurassicPeriod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> test <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可能输出：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">main<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">5</span><span class="token operator">:</span> warning<span class="token operator">:</span> <span class="token char">'triassicPeriod'</span> is deprecated <span class="token punctuation">[</span><span class="token operator">-</span>Wdeprecated<span class="token operator">-</span>declarations<span class="token punctuation">]</span>    <span class="token function">triassicPeriod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">^</span>main<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">3</span><span class="token operator">:</span><span class="token number">3</span><span class="token operator">:</span> note<span class="token operator">:</span> <span class="token char">'triassicPeriod'</span> has been explicitly marked deprecated here<span class="token punctuation">[</span><span class="token punctuation">[</span>deprecated<span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token operator">^</span>main<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">21</span><span class="token operator">:</span><span class="token number">5</span><span class="token operator">:</span> warning<span class="token operator">:</span> <span class="token char">'jurassicPeriod'</span> is deprecated<span class="token operator">:</span> Use <span class="token function">neogenePeriod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> instead <span class="token punctuation">[</span><span class="token operator">-</span>Wdeprecated<span class="token operator">-</span>declarations<span class="token punctuation">]</span>    <span class="token function">jurassicPeriod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">^</span>main<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token number">8</span><span class="token operator">:</span><span class="token number">3</span><span class="token operator">:</span> note<span class="token operator">:</span> <span class="token char">'jurassicPeriod'</span> has been explicitly marked deprecated here<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token function">deprecated</span><span class="token punctuation">(</span><span class="token string">"Use neogenePeriod() instead"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token operator">^</span><span class="token number">2</span> warnings generated<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++14 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型推导(C++14)</title>
      <link href="/2020/10/23/39843.html"/>
      <url>/2020/10/23/39843.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、返回值类型推导"><a href="#一、返回值类型推导" class="headerlink" title="一、返回值类型推导"></a>一、返回值类型推导</h2><p>C++14 对函数返回类型推导规则做了优化。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span><span class="token keyword">auto</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>     <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果使用 C++11 编译，是无法通过编译的。该特性也可以用于模板和 lambda 表达式中。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> rhs<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> lhs<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> rhs <span class="token operator">+</span> lhs<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> <span class="token function">func</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">add</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">" world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">{</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为 C++ 是强类型语言，有些限制需要考虑：</p><ul><li><strong>函数内如果有多个 return 语句，它们必须返回相同的类型，否则编译失败</strong>；</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">bool</span> flag<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"false"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// error: “std::string”: 所有返回表达式必须推导为相同类型: 以前为“int”</span>    <span class="token comment">// error: “return”: 无法从“std::string”转换为“int”</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>如果 return 语句返回初始化列表，返回值类型推导会失败</strong>；</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// error returning initializer list</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>如果函数是虚函数，不能使用返回值类型推导</strong>；</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// error: virtual function cannot have deduced return type</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>返回值类型推导可以用在前向声明中，但是在使用它们之前，翻译单元中必须能够得到函数定义</strong>；</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// declared, not yet defined</span><span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>返回类型推导可以用在递归函数中，但是递归调用必须以至少一个返回语句作为先导，以便编译器推导出返回类型</strong>。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>  <span class="token comment">// return int</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token function">sum</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、decltype-auto"><a href="#二、decltype-auto" class="headerlink" title="二、decltype(auto)"></a>二、decltype(auto)</h2><p><code>decltype(auto)</code> 是 C++14 新增的类型指示符，可以用来声明变量以及指示函数返回类型。</p><p><code>decltype(auto)</code> 推导出的类型与 <code>auto</code> 相似，只是推导出的类型会保留引用或cv限定符，而 <code>auto</code> 并不会保留。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 函数返回类型 -&gt; int</span><span class="token keyword">auto</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> val<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 函数返回类型 -&gt; const int&amp;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> val<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 变量声明</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> cval <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> cval1 <span class="token operator">=</span> cval<span class="token punctuation">;</span>  <span class="token comment">// cval1 -&gt; int</span>    <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> cval2 <span class="token operator">=</span> cval1<span class="token punctuation">;</span>  <span class="token comment">// cval2 -&gt; const int</span>    <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">&amp;</span> rval <span class="token operator">=</span> val<span class="token punctuation">;</span>    <span class="token keyword">auto</span> rval1 <span class="token operator">=</span> rval<span class="token punctuation">;</span>  <span class="token comment">// rval1 -&gt; int</span>    <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> rval2 <span class="token operator">=</span> rval1<span class="token punctuation">;</span>  <span class="token comment">// rval2 -&gt; int&amp;</span>    <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> rrval <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> rrval1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>rrval<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// rrval1 -&gt; int</span>    <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> rrval2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>rrval<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// int&amp;&amp;</span>    <span class="token keyword">static_assert</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func1</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"const int&amp;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static_assert</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func1</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"int"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static_assert</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func2</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"const int&amp;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++14 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda 优化(C++14)</title>
      <link href="/2020/10/22/46650.html"/>
      <url>/2020/10/22/46650.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、泛型-Lambda"><a href="#一、泛型-Lambda" class="headerlink" title="一、泛型 Lambda"></a>一、泛型 Lambda</h2><p>C++11 要求 lambda 表达式参数需要声明具体的类型。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> lambda <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>C++14 进行了优化，lambda 表达式参数类型可以是 <code>auto</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token punctuation">,</span> <span class="token keyword">auto</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span>std<span class="token double-colon punctuation">::</span>string str <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hello world</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="二、Lambda-初始化捕获"><a href="#二、Lambda-初始化捕获" class="headerlink" title="二、Lambda 初始化捕获"></a>二、Lambda 初始化捕获</h2><p>C++14 允许使用任意表达式初始化捕获列表中的变量。被初始化的变量，不需要与外部的任何变量进行绑定，同时其初始值是在创建时捕获的，而非调用时捕获。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> i <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> f1 <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 600</span>    <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> f2 <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> val<span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    val <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 输出：1000 而不是 2000</span>    <span class="token keyword">auto</span> f3 <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">mutable</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// this would not compile without 'mutable' as we are modifying x on each call</span>    <span class="token keyword">auto</span> res <span class="token operator">=</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出：0</span>    res <span class="token operator">=</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出：1</span>    res <span class="token operator">=</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：2</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++14 中除了通过拷贝或者引用捕获变量，还允许捕获只能移动的变量（如：<code>std::unique_ptr</code>）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> p <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> f1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// error: std::unique_ptr cannot be copied</span>    <span class="token keyword">auto</span> f2 <span class="token operator">=</span> <span class="token punctuation">[</span>p <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 在 f2 创建完成后，外部的 p 变成 nullptr 了</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相对于引用变量，通过引用捕获初始化，可以重新定义变量名称。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> val <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>r <span class="token operator">=</span> val<span class="token punctuation">,</span> val <span class="token operator">=</span> val <span class="token operator">*</span> <span class="token number">6</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>        <span class="token operator">++</span>r<span class="token punctuation">;</span>        <span class="token keyword">return</span> r <span class="token operator">+</span> val<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 输出：701</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 输出：101</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++14 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量模板(C++14)</title>
      <link href="/2020/10/22/19742.html"/>
      <url>/2020/10/22/19742.html</url>
      
        <content type="html"><![CDATA[<p>C++14 支持<strong>变量模板</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token comment">// 变量模板</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">const</span> T pi <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token number">3.141592653</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">constexpr</span> T e <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token number">2.7182818284590452353</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> pi<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出：3</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> pi<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出：3.14159</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++14 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板特性(C++11)</title>
      <link href="/2020/10/19/2380.html"/>
      <url>/2020/10/19/2380.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、右尖括号"><a href="#一、右尖括号" class="headerlink" title="一、右尖括号"></a>一、右尖括号</h2><p>C++98/03 标准：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span> vec<span class="token punctuation">;</span>  <span class="token comment">// 需要这样写</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> vec<span class="token punctuation">;</span>  <span class="token comment">// error, &gt;&gt; 会被认为是右移操作符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>C++11 标准中，要求编译器对模板的右尖括号做单独处理，使编译器能够正确判断出”&gt;&gt;”是一个右移操作符还是模板参数表的结束标记。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> vec<span class="token punctuation">;</span>  <span class="token comment">// ok</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="二、模板别名"><a href="#二、模板别名" class="headerlink" title="二、模板别名"></a>二、模板别名</h2><p>C++11 中出现了可以重定义一个模板的语法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">using</span> str_map_t <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> T<span class="token operator">&gt;</span><span class="token punctuation">;</span>str_map_t<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> map1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里使用了 C++11 的关键字 using，使用宏或 typedef 无法达到同样的效果：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Vec</span><span class="token expression"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">;</span></span></span>Vec<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> coll<span class="token punctuation">;</span><span class="token comment">// 等同于</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> coll<span class="token punctuation">;</span>  <span class="token comment">// 并不是我们想要的结果</span><span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> Vec<span class="token punctuation">;</span>  <span class="token comment">// 类型固定成 int，typedef 不接受参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>using 几乎涵盖了 typedef 的所有功能。总的来说，typedef 有时候阅读难度比 using 更大（比如在定义函数指针的时候），using 别名语法比 typedef 更加清晰。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> uint_t<span class="token punctuation">;</span><span class="token keyword">using</span> uint_t <span class="token operator">=</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> map_str_t<span class="token punctuation">;</span><span class="token keyword">using</span> map_str_t <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">;</span><span class="token comment">// 定义函数指针</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">using</span> func_t <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// C++98/03</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">struct</span> <span class="token class-name">func_t</span> <span class="token punctuation">{</span>    <span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>type<span class="token punctuation">)</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 使用 func_t 模板</span>func_t<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type xx_1<span class="token punctuation">;</span><span class="token comment">// C++11 </span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">using</span> func_t <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用 func_t 模板</span>func_t<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> xx_2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、函数模板的默认模板参数"><a href="#三、函数模板的默认模板参数" class="headerlink" title="三、函数模板的默认模板参数"></a>三、函数模板的默认模板参数</h2><h3 id="1-默认模板参数"><a href="#1-默认模板参数" class="headerlink" title="1. 默认模板参数"></a>1. 默认模板参数</h3><p>C++98/03 中，类模版可以有默认模板参数，但是函数模板不支持默认参数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">,</span> U N <span class="token operator">=</span> <span class="token number">0</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token operator">&gt;</span>     <span class="token comment">// error in C++98/03: default template arguments</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++11 中解除了这个限制，上面的函数可以直接调用，就像调用正常函数一样：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。但是对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随”&lt;&gt;”来实例化。</p><h3 id="2-细节"><a href="#2-细节" class="headerlink" title="2. 细节"></a>2. 细节</h3><p>函数模板的默认模板参数在使用规则上和其他的默认参数也有些不同，<strong>它没有必须写在参数表最后的限制</strong>。而类模板的默认模板参数必须从右往左定义。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    T value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span> <span class="token comment">// error</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    T value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>U <span class="token function">func</span><span class="token punctuation">(</span>T val<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token operator">&gt;</span>U <span class="token function">func</span><span class="token punctuation">(</span>T val<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模版默认参数可以和自动推导结合使用来提升灵活性。可以在平时的编码中，指定一部分模板参数，另外的一部分自动推导，但是有两条规则：</p><ul><li>如果编译器无法自动推导函数模板参数类型，则使用默认模板参数</li><li>如果能推导函数模板参数，则使用推导类型</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">struct</span> <span class="token class-name">identity</span><span class="token punctuation">{</span>    <span class="token keyword">typedef</span> T type<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">identity</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type val<span class="token punctuation">,</span> T <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">func1</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// T -&gt; int</span>    <span class="token function">func1</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">123.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// T -&gt; double</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">R</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>R <span class="token function">func3</span><span class="token punctuation">(</span>U val<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">func3</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token generic-function"><span class="token function">func3</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// func 返回类型是 long</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：在调用函数模板时，若显示指定模板的参数，参数填充顺序是从左往右的。</strong></p><p>通过 identity 外部模板禁用了参数 val 的类型自动推导，但是 func1 指定了模板参数 T 的默认参数类型，所以 func1(123) 使用默认的 int 类型，而在 func1(123,123.0) 中，第二个参数 123.0 为 double 类型，所以 T 优先被推导为 double 类型。</p><p>这里要注意的是，不能将默认模板参数当做模板参数自动推导的”建议”，因为模板参数自动推导总是根据实参推导来的，当自动推导生效时，默认模板参数会被直接忽略。</p><h2 id="四、type-tratis"><a href="#四、type-tratis" class="headerlink" title="四、type_tratis"></a>四、type_tratis</h2><p>C++11 新增的类型萃取（编译期间获取）。</p><h3 id="1-std-decay"><a href="#1-std-decay" class="headerlink" title="1. std::decay"></a>1. std::decay</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">struct</span> <span class="token class-name">decay</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于普通类型来说，<code>std::decay</code> 是移除引用和 cv 符，也可以用于数组，具体的规则：</p><ul><li>先移除 T 类型的引用，得到类型 U，U 定义为 <code>std::remove_reference&lt;T&gt;::type</code>；</li><li>如果 <code>std::is_array&lt;U&gt;::value</code> 为 true，修改类型 type 为 <code>std::remove_extent&lt;U&gt;::type*</code>；</li><li>否则，如果 <code>std::is_function&lt;U&gt;::value</code> 为 true，修改类型 type 为 <code>std::add_pointer&lt;U&gt;::type</code>；</li><li>否则，修改类型 type 为 <code>std::remove_cv&lt;U&gt;::type</code>。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> A <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>decay<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span>  <span class="token comment">// int</span><span class="token keyword">using</span> B <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>decay<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span>  <span class="token comment">// int</span><span class="token keyword">using</span> C <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>decay<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span>  <span class="token comment">// int</span><span class="token keyword">using</span> D <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>decay<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span>  <span class="token comment">// int</span><span class="token keyword">using</span> E <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>decay<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span>  <span class="token comment">// int*</span><span class="token keyword">using</span> F <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>decay<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span>  <span class="token comment">// int(*)int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::decay</code> 对于函数来说就是添加指针。</p><h3 id="2-std-conditional"><a href="#2-std-conditional" class="headerlink" title="2. std::conditional"></a>2. std::conditional</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> B<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">F</span><span class="token operator">&gt;</span><span class="token keyword">struct</span> <span class="token class-name">conditional</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在编译期根据一个判断式选择两个类型中的一个，和条件表达式的语义类似，类似于一个三元表达式。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> A <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>conditional<span class="token operator">&lt;</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span>  <span class="token comment">// int</span><span class="token keyword">using</span> B <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>conditional<span class="token operator">&lt;</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span>  <span class="token comment">// float</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-std-result-of"><a href="#3-std-result-of" class="headerlink" title="3. std::result_of"></a>3. std::result_of</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">result_of</span><span class="token operator">&lt;</span><span class="token function">F</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在编译期获取一个可调用对象的返回类型。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">typedef</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>func_ref<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// function reference</span><span class="token keyword">typedef</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>func_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// function pointer</span><span class="token keyword">struct</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">using</span> A <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>result_of<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span>  <span class="token comment">// int</span><span class="token keyword">using</span> B <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>result_of<span class="token operator">&lt;</span><span class="token function">func_ref</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span>  <span class="token comment">// int</span><span class="token keyword">using</span> C <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>result_of<span class="token operator">&lt;</span><span class="token function">func_ptr</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span>  <span class="token comment">// int</span><span class="token keyword">using</span> D <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>result_of<span class="token operator">&lt;</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span>  <span class="token comment">// int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-std-enable-if"><a href="#4-std-enable-if" class="headerlink" title="4. std::enable_if"></a>4. std::enable_if</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> B<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token keyword">struct</span> <span class="token class-name">enable_if</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>利用 SFINAE（substitution failure is not an error 替换失败并非错误）实现根据条件选择重载函数。<code>std::enable_if</code> 使得函数在判断条件 B 仅为 true 时才有效。</p><p><code>std::enable_if</code> 可以用于返回值、模板定义、模板特化和参数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 用于返回值，只接受整型和浮点</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>enable_if<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>is_arithmetic<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span> T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type <span class="token function">func1</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 对入参类型做了限定，即第二个参数类型为 int</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>T <span class="token function">func2</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>enable_if<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>is_integral<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 对模板参数做了限定，只能是 int</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>enable_if<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>is_integral<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&gt;</span>T <span class="token function">func3</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">U</span> <span class="token operator">=</span> <span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">;</span><span class="token comment">// 模板特化时，对模板参数做了限定，模板参数类型只能为浮点</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>enable_if<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>is_floating_point<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>enable_if<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>is_arithmetic<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type <span class="token function">toString</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>enable_if<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type <span class="token function">toString</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">func1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ok</span>    <span class="token function">func1</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// error</span>        <span class="token function">func2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>    <span class="token function">func2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// error</span>        <span class="token function">func3</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ok</span>    <span class="token function">func3</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error</span>        Test<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> t<span class="token punctuation">;</span>  <span class="token comment">// ok</span>    Test<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> t<span class="token punctuation">;</span>  <span class="token comment">// error</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类特性(C++11)</title>
      <link href="/2020/10/19/61278.html"/>
      <url>/2020/10/19/61278.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、final-amp-override"><a href="#一、final-amp-override" class="headerlink" title="一、final &amp; override"></a>一、final &amp; override</h2><h3 id="1-重写"><a href="#1-重写" class="headerlink" title="1. 重写"></a>1. 重写</h3><p>基类 Base 中声明的虚函数 func，在其派生类 DerivedA 中再次被定义，且 DerivedA 中的函数 func 跟 Base 中 func 的原型一样（函数名、参数列表等一样），那么就称 DerivedA 重写了 Base 的 func 函数。对于任何类 DerivedA 的对象，调用成员函数 func 都是调用了 DerivedA 重写的版本。而如果同时有从 Base 的派生类 DerivedB，却并没有重写 Base 的 func 函数，那么调用成员函数 func 则会调用 Base 中的版本，这在 C++ 中就实现多态。</p><p>在 C++ 中，经常容易发生意外重写虚函数的事情。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Derived::func 可能并不是尝试重写虚函数，只是恰好加入了一个具有相同名字的函数。另一个可能的情形是，当基类的虚函数被删除后，子类拥有旧的函数就不再重写该虚函数并摇身一变成为了一个普通的类方法，这将造成灾难性的后果。</p><p>C++11 关于继承新增了两个关键字，<code>final</code> 用于修饰一个类或虚函数，表示禁止该类进一步派生和虚函数的进一步重写；<code>override</code> 用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果一个函数声明了 <code>override</code> 但父类却没有这个虚函数，编译报错，使用 <code>override</code> 关键字可以避免开发者在重写基类函数时无意产生的错误。</p><h3 id="2-override"><a href="#2-override" class="headerlink" title="2. override"></a>2. override</h3><p>C++ 中重写有一个特点，就是对于基类声明为 virtual 的函数，之后的重写版本都不需要再声明该函数为 virtual，即使在派生类中声明了 virtual，该关键字也是编译器可以忽略的；另外一点是，在 C++ 中有的虚函数会“跨层”，没有在父类中声明的接口有可能是祖先的虚函数接口，导致代码难以阅读。</p><p>于是引入了虚函数描述符 <code>override</code>，该关键字将显式的告知编译器进行虚函数重写，如果派生类在虚函数声明时使用了 <code>override</code> 描述符，那么该函数必须重写其基类中的同名函数，否则代码无法通过编译。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">turing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">vneumann</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">dknuth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">DerivedMid</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">DerivedTop</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">DerivedMid</span></span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">turing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">dikjstra</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>  <span class="token comment">// 无法通过编译，拼写错误，并非虚函数重写</span>    <span class="token keyword">void</span> <span class="token function">vneumann</span><span class="token punctuation">(</span><span class="token keyword">double</span> f<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>  <span class="token comment">// 无法通过编译，参数不一致，并非虚函数重写</span>    <span class="token keyword">void</span> <span class="token function">dknuth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>  <span class="token comment">// 无法通过编译，常量性不一致，并非虚函数重写</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>  <span class="token comment">// 无法通过编译，非虚函数重写</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-final"><a href="#3-final" class="headerlink" title="3. final"></a>3. final</h3><p><code>final</code> 则是为了防止类被继续继承以及终止虚函数继续重写引入的。<code>final</code> 可以在派生过程中任意地阻止一个接口的可重写性。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Object</span></span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">final</span><span class="token punctuation">;</span>  <span class="token comment">// 声明为 final</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived1</span> <span class="token keyword">final</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 合法</span><span class="token keyword">class</span> <span class="token class-name">Derived2</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Derived1</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 非法, Derived1 已 final</span><span class="token keyword">class</span> <span class="token class-name">Derived3</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 非法, fun 已 final</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>final</code> 关键字都是用于描述一个派生类的。那么基类中的虚函数是否可以使用 <code>final</code> 关键字呢？</p><p>答案是肯定的，不过这样将会导致该虚函数无法被重写，也就失去了虚函数的意义。如果不想成员函数被重写，可以直接将该成员函数定义为非虚的。而 <code>final</code> 通常只在继承关系的“中途”终止派生类的重写中有意义。</p><h2 id="二、default"><a href="#二、default" class="headerlink" title="二、default"></a>二、default</h2><p>C++11 引入 <code>default</code> 关键字，多数时候用于声明构造函数为默认构造函数，如果类中有了自定义的构造函数，编译器就不会隐式生成默认构造函数。析构、拷贝构造、赋值操作符均可用，普通函数不可以用。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Test t<span class="token punctuation">;</span>  <span class="token comment">// error</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码编译出错，因为没有匹配的构造函数，编译器没有生成默认构造函数，而通过 <code>default</code>，只需在函数声明后加上“<code>=default;</code>”，编译器将为显式声明的 <code>default</code> 函数自动生成函数体：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Test t<span class="token punctuation">;</span>  <span class="token comment">// ok</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、delete"><a href="#三、delete" class="headerlink" title="三、delete"></a>三、delete</h2><p>C++ 中，如果没有定义特殊成员函数，那么编译器在需要特殊成员函数时候会隐式自动生成一个默认的特殊成员函数，例如拷贝构造函数或者拷贝赋值操作符。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Test t1<span class="token punctuation">;</span>    Test t2 <span class="token operator">=</span> t1<span class="token punctuation">;</span>  <span class="token comment">// ok, 调用编译器隐式生成的默认拷贝构造函数</span>    Test t3<span class="token punctuation">;</span>    t3 <span class="token operator">=</span> t1<span class="token punctuation">;</span>  <span class="token comment">// ok, 调用编译器隐式生成的默认拷贝赋值操作符</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而有时候想禁止对象的拷贝与赋值，可以使用 <code>delete</code> 修饰，也可以将拷贝和赋值的函数声明为 private。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    Test<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Test t1<span class="token punctuation">;</span>    Test t2 <span class="token operator">=</span> t1<span class="token punctuation">;</span>  <span class="token comment">// error, 拷贝构造函数被禁用</span>    Test t3<span class="token punctuation">;</span>    t3 <span class="token operator">=</span> t1<span class="token punctuation">;</span>  <span class="token comment">// error, 拷贝赋值操作符被禁用</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>delete</code> 在 C++11 中很常用，<code>std::unique_ptr</code> 就是通过 <code>delete</code> 修饰来禁止对象的拷贝的。单例模式也可以通过该方法实现。</p><h2 id="四、explicit"><a href="#四、explicit" class="headerlink" title="四、explicit"></a>四、explicit</h2><p><code>explicit</code> 用于修饰构造函数，表示只能显式构造，不可以被隐式转换，也可以用在类型转换函数上。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Test1</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestA(int)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">operator</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>     <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Test2</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"explicit TestB(int)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>     <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Test1 ta <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 可以隐式转换</span>    Test2 tb1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// error，不可以隐式转换</span>    Test2 <span class="token function">tb2</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ok</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ta<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ok 调用 Test1::operator bool()</span>    <span class="token keyword">bool</span> ba <span class="token operator">=</span> ta<span class="token punctuation">;</span>  <span class="token comment">// ok copy-initialization selects Test1::operator bool()</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tb2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ok 调用 Test2::operator bool()</span>    <span class="token keyword">bool</span> bb <span class="token operator">=</span> tb2<span class="token punctuation">;</span>  <span class="token comment">// error copy-initialization does not consider Test2::operator bool()</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、委托构造函数"><a href="#五、委托构造函数" class="headerlink" title="五、委托构造函数"></a>五、委托构造函数</h2><p>通过委派其他构造函数，多构造函数的类编写将更加容易。原则上，编译器不允许在构造函数中调用构造函数。C++11 中的委派构造函数是<strong>在构造函数的初始化列表</strong>位置进行构造、委派的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> type_ <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">char</span> e<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> name_ <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> type_<span class="token punctuation">{</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> name_<span class="token punctuation">{</span> <span class="token char">'a'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>委派构造函数只能在函数体中为 type_、name_ 等成员变量赋初值。这是由于委派构造函数不能有初始化列表造成的，在 C++11 中，<strong>构造函数不能同时“委派”和使用初始化列表</strong>，所以如果委派构造函数要给变量赋初值，初始化代码必须放在函数体中。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token char">'a'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Test</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token char">'a'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">char</span> e<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">char</span> e<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">type_</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">name_</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">int</span> type_<span class="token punctuation">{</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> name_<span class="token punctuation">{</span> <span class="token char">'a'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、继承构造函数"><a href="#六、继承构造函数" class="headerlink" title="六、继承构造函数"></a>六、继承构造函数</h2><p>如果派生类要使用基类的构造函数，通常需要在构造函数中显式声明。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">double</span> d<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">float</span> f<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token keyword">double</span> d<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token keyword">float</span> f<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> i<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++ 中，如果派生类要使用<strong>基类的成员函数（非虚函数）</strong>，可以通过 using 声明完成。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">double</span> i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>func<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derived:"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Base b<span class="token punctuation">;</span>    b<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">4.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Base: 4.5</span>    Derived d<span class="token punctuation">;</span>    d<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">4.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Base: 4.5</span>    <span class="token comment">// 如果 Derived 中没有 using Base::func; 则 d.func(4.5); 输出：Derived: 4</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++11 中，这个想法被扩展到了构造函数上，子类可以通过使用 using 来声明继承基类的构造函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">double</span> d<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">float</span> f<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++11 标准中继承构造函数被设计为跟派生类中的各种类默认函数（默认构造、析构、拷贝构造等）一样，是隐式声明的。这意味着如果一个继承构造函数不被相关代码使用，编译器不会为其产生真正的函数代码。</p><p><strong>不过继承构造函数只会初始化基类中成员变量，对于派生类中的成员变量，则无能为力</strong>。</p><p>基类构造函数的参数会有默认值，对于继承构造函数来讲，参数的默认值时不会被继承的。事实上，默认值会导致基类产生多个构造函数的版本，这些函数版本都会被派生类继承。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">2.4</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a_</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">d_</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a_ = "</span> <span class="token operator">&lt;&lt;</span> a_ <span class="token operator">&lt;&lt;</span> <span class="token string">", d_ = "</span> <span class="token operator">&lt;&lt;</span> d_ <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> a_<span class="token punctuation">;</span>    <span class="token keyword">double</span> d_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Derived s1<span class="token punctuation">;</span>  <span class="token comment">// a_ = 3, d_ = 2.4</span>    Derived <span class="token function">s2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// a_ = 10, d_ = 2.4</span>    Derived <span class="token function">s3</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">6.6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// a_ = 10, d_ = 6.6</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事实上，Derived 可能从 Base 中继承来的候选继承构造函数有如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">=</span> <span class="token number">2.4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使用两个默认参数</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 减掉一个默认参数</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 不使用默认参数</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">const</span> Base <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 默认的复制构造函数</span><span class="token comment">// Derived 中的构造函数将会包括以下一些：</span><span class="token function">Derived</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 继承构造函数</span><span class="token function">Derived</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 减少掉一个默认参数的继承构造函数</span><span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 不包含默认参数的默认构造函数</span><span class="token function">Derived</span><span class="token punctuation">(</span><span class="token keyword">const</span> Derived <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 这是复制构造函数, 不是继承来的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果基类的构造函数被声明为私有成员函数，或者派生类是从基类中虚继承的，那么就不能够在派生类中声明继承构造函数。如果一旦使用了继承构造函数，编译器就不会再为派生类生成默认构造函数了。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语言特性(C++11)</title>
      <link href="/2020/10/18/1673.html"/>
      <url>/2020/10/18/1673.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础数据类型"><a href="#一、基础数据类型" class="headerlink" title="一、基础数据类型"></a>一、基础数据类型</h2><p>C++11 新增了几种数据类型：<code>long long</code>、<code>char16_t</code>、<code>char32_t</code> 等。</p><p><code>char16_t</code> - UTF-16 字符表示的类型，要求大到足以表示任何 UTF-16 编码单元（16 位）。</p><p><code>char32_t</code> - UTF-32 字符表示的类型，要求大到足以表示任何 UTF-32 编码单元（32 位）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token keyword">long</span> a <span class="token operator">=</span> <span class="token number">9223372036854775807</span><span class="token punctuation">;</span>  <span class="token comment">// 64 位整数</span><span class="token keyword">char16_t</span> utf8_str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token string">"\u0123"</span><span class="token punctuation">;</span><span class="token keyword">char32_t</span> utf8_str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> U<span class="token string">"\u0123"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="二、别名"><a href="#二、别名" class="headerlink" title="二、别名"></a>二、别名</h2><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>C++11 可以通过 <code>using</code> 定义类型别名，等同于 <code>typedef</code>，也可以定义别名模板</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 类型别名</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> int32<span class="token punctuation">;</span><span class="token keyword">using</span> int32 <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span class="token comment">// 定义函数指针</span><span class="token keyword">typedef</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>add<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">using</span> add <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 别名模板</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">using</span> str_map_t <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> T<span class="token operator">&gt;</span><span class="token punctuation">;</span>str_map_t<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> m<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="名称空间别名"><a href="#名称空间别名" class="headerlink" title="名称空间别名"></a>名称空间别名</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">namespace</span> MyUDP <span class="token operator">=</span> MyLibraries<span class="token double-colon punctuation">::</span>Networking<span class="token double-colon punctuation">::</span>UDP<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="三、enum-class"><a href="#三、enum-class" class="headerlink" title="三、enum class"></a>三、enum class</h2><p>C++11 新增<strong>有作用域的枚举类型</strong>，解决 C 枚举中各种类型安全的问题：隐式转换、无法指定基础类型、范围污染。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">enum</span> <span class="token class-name">Color1</span> <span class="token punctuation">{</span>    Red<span class="token punctuation">,</span>    Green<span class="token punctuation">,</span>    Blue<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">enum</span> <span class="token class-name">Color2</span> <span class="token punctuation">{</span>    White<span class="token punctuation">,</span>    Black<span class="token punctuation">,</span>    Yellow<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Red <span class="token operator">==</span> White<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"red == white\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不带作用域的枚举类型可以自动转换成整形，且不同的枚举可以相互比较，代码中红色可以和白色比较，这都是潜在的难以调试的 bug，而这种完全可以通过有作用域的枚举来规避。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Color1</span> <span class="token punctuation">{</span>    Red<span class="token punctuation">,</span>    Green<span class="token punctuation">,</span>    Blue<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Color2</span> <span class="token punctuation">{</span>    White<span class="token punctuation">,</span>    Black<span class="token punctuation">,</span>    Yellow<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Color1<span class="token double-colon punctuation">::</span>Red <span class="token operator">==</span> Color2<span class="token double-colon punctuation">::</span>White<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 编译失败</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"red == white\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用带有作用域的枚举类型后，对不同的枚举进行比较会导致编译失败，消除潜在 bug，同时带作用域的枚举类型可以选择底层类型，默认是 int，可以改成 char 等其他类型。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Color1</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">char</span></span> <span class="token punctuation">{</span>    Red<span class="token punctuation">,</span>    Green<span class="token punctuation">,</span>    Blue<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、constexpr⭐"><a href="#四、constexpr⭐" class="headerlink" title="四、constexpr⭐"></a>四、constexpr⭐</h2><p>constexpr 是 C++11 新引入的关键字。功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。</p><p>注意：获得在编译阶段计算出结果的能力，并不代表 constexpr 修饰的表达式一定会在程序编译阶段被执行，具体的计算时机还是编译器说了算。</p><h3 id="1-修饰普通变量"><a href="#1-修饰普通变量" class="headerlink" title="1. 修饰普通变量"></a>1. 修饰普通变量</h3><p>定义变量时可以用 constexpr 修饰，从而使该变量获得在编译阶段即可计算出结果的能力，变量必须经过初始化且初始值必须是一个常量表达式。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当常量表达式中包含浮点数时，考虑到程序编译和运行所在的系统环境可能不同，常量表达式在编译阶段和运行阶段计算出的结果精度很可能会受到影响，因此 C++11 标准规定，浮点常量表达式在编译阶段计算的精度要至少等于（或者高于）运行阶段计算出的精度。</p><h3 id="2-修饰函数"><a href="#2-修饰函数" class="headerlink" title="2. 修饰函数"></a>2. 修饰函数</h3><p>constexpr 可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数。</p><p>注意：constexpr 并非可以修饰任意函数的返回值。换句话说，一个函数要想成为常量表达式函数，必须满足如下 4 个条件。</p><ul><li>整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句；</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 无法编译通过</span>    <span class="token keyword">int</span> z <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>    <span class="token keyword">return</span> z<span class="token punctuation">;</span>    <span class="token comment">// 可以编译</span>    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>该函数必须有返回值，即函数的返回值类型不能是 void；</li><li>return 返回的表达式必须是常量表达式；</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> num <span class="token operator">+</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 无法通过编译</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token function">calc</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// error: 表达式的计算结果不是常数</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-修饰类的构造函数"><a href="#3-修饰类的构造函数" class="headerlink" title="3. 修饰类的构造函数"></a>3. 修饰类的构造函数</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">constexpr</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span>         <span class="token operator">:</span> <span class="token function">age_</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> age_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 若 Test 的构造函数没有 constexpr 修饰，则编译失败</span>    <span class="token keyword">constexpr</span> Test t <span class="token punctuation">{</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：constexpr 修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。</p><p>C++11 中，不支持用 constexpr 修饰带有 virtual 的成员函数。</p><h3 id="4-修饰模板函数"><a href="#4-修饰模板函数" class="headerlink" title="4. 修饰模板函数"></a>4. 修饰模板函数</h3><p>由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。</p><p>针对这种情况下，C++11 规定，如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</p><h3 id="5-用于类实现字面类型"><a href="#5-用于类实现字面类型" class="headerlink" title="5. 用于类实现字面类型"></a>5. 用于类实现字面类型</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept&gt;</span></span><span class="token comment">// 字面类</span><span class="token keyword">class</span> <span class="token class-name">ConstStr</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span>size_t N<span class="token operator">&gt;</span>    <span class="token keyword">constexpr</span> <span class="token function">ConstStr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">str_</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">size_</span><span class="token punctuation">(</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment">// constexpr 函数通过抛异常来提示错误</span>    <span class="token comment">// C++11 中，它们必须用条件运算符 ?: 来这么做</span>    <span class="token keyword">constexpr</span> <span class="token keyword">char</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> n <span class="token operator">&lt;</span> size_ <span class="token operator">?</span> str_<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token keyword">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">out_of_range</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">constexpr</span> size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> size_<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str_<span class="token punctuation">;</span>    size_t size_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// C++11 constexpr 函数必须把一切放在单条 return 语句中</span><span class="token keyword">constexpr</span> size_t <span class="token function">count_lower</span><span class="token punctuation">(</span>ConstStr s<span class="token punctuation">,</span> size_t n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> size_t c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> n <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> c <span class="token operator">:</span>        <span class="token char">'a'</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'z'</span> <span class="token operator">?</span> <span class="token function">count_lower</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span>        <span class="token function">count_lower</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span>size_t N<span class="token operator">&gt;</span><span class="token keyword">struct</span> <span class="token class-name">TestN</span><span class="token punctuation">{</span>    <span class="token function">TestN</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> N <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\"Hello, world!\" 里小写字母的个数是 "</span><span class="token punctuation">;</span>    TestN<span class="token operator">&lt;</span><span class="token function">count_lower</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> out1<span class="token punctuation">;</span> <span class="token comment">// 隐式转换到常量字符串</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、sizeof"><a href="#五、sizeof" class="headerlink" title="五、sizeof"></a>五、sizeof</h2><p>C++11 中 sizeof 可以直接用在类的数据成员上，不需要定义类对象，就能计算成员的大小。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token double-colon punctuation">::</span>string data<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// C++11 之前</span>    Test t<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Test.val size: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Test.str size: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>str<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token comment">//std::cout &lt;&lt; "Test.data size: " &lt;&lt; sizeof(t.data) &lt;&lt; std::endl;  // error 私有成员变量</span>    <span class="token comment">// C++11 之后</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Test.val size: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Test<span class="token double-colon punctuation">::</span>val<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Test.str size: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Test<span class="token double-colon punctuation">::</span>str<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token comment">//std::cout &lt;&lt; "Test.data size: " &lt;&lt; sizeof(Test::data) &lt;&lt; std::endl;  // error 私有成员变量</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、静态断言"><a href="#六、静态断言" class="headerlink" title="六、静态断言"></a>六、静态断言</h2><p><strong>static_assert(布尔常量表达式, 消息)</strong>，编译时期的断言，接受两个参数，一个是断言表达式，通常需要返回一个 bool 值；一个则是警告信息，必须是字符串字面量。</p><p>static_assert 断言表达式的结果必须是在编译时期可以计算的表达式，即必须是常量表达式。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static_assert</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"the paramenters must have same size."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="七、属性"><a href="#七、属性" class="headerlink" title="七、属性"></a>七、属性</h2><p>属性为各种由实现定义的语言扩展（例如 GNU 与 IBM 的语言扩展 <code>__attribute__((...))</code>，微软的语言扩展 <code>__declspec()</code> 等）提供了统一化的语法。</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>[[noreturn]]</td><td>指示函数永远不会将控制权返回给调用点，通常，函数要么导致某种终止，要么引发异常。</td></tr></tbody></table><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span><span class="token punctuation">[</span>noreturn<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token string">"error"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token punctuation">[</span>noreturen<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">void</span> <span class="token function">forceProgramTermination</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="八、原始字符串字面值"><a href="#八、原始字符串字面值" class="headerlink" title="八、原始字符串字面值"></a>八、原始字符串字面值</h2><p>C++11 引入了一种新方法，将字符串字面值定义为”原始字符串字面值”，使用户书写的字符串“所见即所得”，不需要考虑转义等问题。</p><p>使用以下语法声明原始字符串字面值：</p><pre class="line-numbers language-none"><code class="language-none">R"delimiter(raw_characters)delimiter"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>delimiter</code>是一个可选的字符序列，除括号、反斜面和空格外，由任何字符组成</li><li><code>raw_characters</code>是任何原始字符序列；不得包含<code>")delimiter"</code>结束序列</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> msg1 <span class="token operator">=</span> <span class="token string">"\nHello,\n\tworld!\n"</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> msg2 <span class="token operator">=</span> <span class="token raw-string string">R"(Hello,    world!)"</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>msg3 <span class="token operator">=</span> <span class="token raw-string string">R"(C:\files\)"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="九、自定义字面量"><a href="#九、自定义字面量" class="headerlink" title="九、自定义字面量"></a>九、自定义字面量</h2><p>C++11 可以自定义字面量，在使用 chrono 库时：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 100ms</span>std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 100s</span><span class="token comment">// 可以更加简单的编写：</span>std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">100</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// C++14里可以这么使用，这里只是举个自定义字面量使用的例子</span>std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">100</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自定义字面量的使用，示例如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">constexpr</span> mytype <span class="token keyword">operator</span><span class="token string">""</span> <span class="token function">_mytype</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> mytype<span class="token punctuation">{</span>n<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>mytype mm <span class="token operator">=</span> <span class="token number">123</span>_mytype<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> mm<span class="token punctuation">.</span>value <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十、friend-扩展"><a href="#十、friend-扩展" class="headerlink" title="十、friend 扩展"></a>十、friend 扩展</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Poly</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> Poly P<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">TestA</span><span class="token punctuation">{</span>    <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">Poly</span><span class="token punctuation">;</span> <span class="token comment">// c++98通过，C++11通过</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">TestB</span><span class="token punctuation">{</span>    <span class="token keyword">friend</span> Poly<span class="token punctuation">;</span> <span class="token comment">// c++98错误，C++11通过</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">TestC</span><span class="token punctuation">{</span>    <span class="token keyword">friend</span> P<span class="token punctuation">;</span> <span class="token comment">// c++98错误，C++11通过</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++11 中，声明一个类为另外一个类的友元时，不在需要使用 class 关键字，甚至类的别名也可以。</p><p>在 C++11 中，可以为类模板声明友元，这在 C++98/03 中是无法做到的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">P</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">friend</span> T<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Test<span class="token operator">&lt;</span>P<span class="token operator">&gt;</span> pp<span class="token punctuation">;</span>  <span class="token comment">// 类型P在这里是 Test 类型的友元</span>Test<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> pi<span class="token punctuation">;</span>  <span class="token comment">// 对于 int 类型模板参数．友元声明被忽略</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在就可以在模板实例化时才确定一个模板类是否有友元，以及谁是这个模板类的友元。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">DefenderT</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">friend</span> T<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">Defence</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">Tackle</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> pos_x <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pos_y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> speed <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> stamina <span class="token operator">=</span> <span class="token number">120</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">AttackerT</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">friend</span> T<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">Move</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">SpeedUp</span><span class="token punctuation">(</span><span class="token keyword">float</span> ratio<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> pos_x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pos_y <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">30</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> speed <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> stamina <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">using</span> Defender <span class="token operator">=</span> DefenderT<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">;</span><span class="token keyword">using</span> Attacker <span class="token operator">=</span> AttackerT<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Validator</span><span class="token punctuation">;</span><span class="token comment">// Validator类成为友元</span><span class="token keyword">using</span> DefenderTest <span class="token operator">=</span> DefenderT<span class="token operator">&lt;</span>Validator<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token keyword">using</span> AttackerTest <span class="token operator">=</span> AttackerT<span class="token operator">&lt;</span>Validator<span class="token operator">&gt;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Validator</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">Validate</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> DefenderTest <span class="token operator">&amp;</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">Validate</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> AttackerTest <span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    DefenderTest d<span class="token punctuation">;</span>    AttackerTest a<span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">Move</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    d<span class="token punctuation">.</span><span class="token function">Defence</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">SpeedUp</span><span class="token punctuation">(</span><span class="token number">1.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    d<span class="token punctuation">.</span><span class="token function">Defence</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Validator v<span class="token punctuation">;</span>    v<span class="token punctuation">.</span><span class="token function">Validate</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>    v<span class="token punctuation">.</span><span class="token function">Validate</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 Validator 为模板参数，实例化出 DefenderTest 及 AttackerTest 版本的类，由于 Validator 是它们的友元，可以任意访问任何成员函数。而另外一个版本则是使用 int 类型进行实例化的 Defender 和 Attacker，按照 C++11 的定义，它们不会有友元。 </p><h2 id="十一、相关宏"><a href="#十一、相关宏" class="headerlink" title="十一、相关宏"></a>十一、相关宏</h2><h3 id="1-预定义宏"><a href="#1-预定义宏" class="headerlink" title="1. 预定义宏"></a>1. 预定义宏</h3><table><thead><tr><th>宏</th><th align="left">说明</th></tr></thead><tbody><tr><td><strong>__STDC_HOSTED__</strong></td><td align="left">如果编译器的目标系统环境中包含完整的标准C库，那么这个宏的值为1， 否则宏的值为0</td></tr><tr><td><strong>__STDC__</strong></td><td align="left">C编译器通常用这个宏的值来表示编译器的实现是否和C标准一致， C++11 标准中这个宏是否定义以及定成什么值由编译器来决定</td></tr><tr><td><strong>__STDC_VERSION__</strong></td><td align="left">C编译器通常用这个宏来表示所支持的C标准的版本，比如1999mmL。C++11 标准中这个宏是否定义以及定成什么值将由编译器来决定</td></tr><tr><td><strong>__STDC_ISO_10646__</strong></td><td align="left">这个宏通常定义为一个 yyyymmL 格式的整数常量。例如 199712L，用来表示C++编译环境符合某个版本的 ISO/IEC 10646 标准</td></tr></tbody></table><p>预定义宏对于多目标平台代码的编写通常具有重大意义。</p><h3 id="2-宏-cplusplus"><a href="#2-宏-cplusplus" class="headerlink" title="2. 宏 __cplusplus"></a>2. 宏 __cplusplus</h3><p>有时头文件中有如下的声明：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span><span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">{</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token comment">// 一些代码</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span><span class="token punctuation">}</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种类型的头文件可以被 #include 到 C 文件中进行编译, 也可以被 #include 到 C++ 文件中进行编译，由于 extern “C” 可以抑制 C++ 对函数名、变量名的符号进行名称重整，因此编译出的 C 目标文件和 C++ 目标文件中的变量、函数名称等符号都是相同的，链接器可以可靠的对两种类型的目标文件进行链接，这样该做法成为了 C 与 C++ 混用头文件的典型做法。</p><p>C++11 标准中, 宏 <strong>__cplusplus</strong> 被预定义为 201103L</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">__cplusplus <span class="token operator">&lt;</span> <span class="token number">201103L</span></span></span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">error</span> <span class="token string">"sholud use C++11 implementation"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用了预处理指令 #error，这使得不支持 C++11 的代码编译立即报错并终止编译。</p><h3 id="3-func-预定义标识符"><a href="#3-func-预定义标识符" class="headerlink" title="3. __func__ 预定义标识符"></a>3. __func__ 预定义标识符</h3><p>基本功能是<strong>返回所在函数的名字</strong>。C++11 允许其使用在类或者结构体中，返回类或结构体的名称，但不允许将 <strong>__func__</strong> 标识符作为函数参数的默认值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_TEST</span> <span class="token punctuation">{</span>    <span class="token function">_TEST</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token constant">__func__</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token punctuation">}</span>TEST<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    TEST t<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// _TEST</span><span class="token punctuation">}</span>      <span class="token comment">// 下面的操作是不允许的</span><span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span>string func_name <span class="token operator">=</span> <span class="token constant">__func__</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">// 由于在参数声明时, __func__还未被定义.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-Pragma-操作符"><a href="#4-Pragma-操作符" class="headerlink" title="4. _Pragma 操作符"></a>4. _Pragma 操作符</h3><p><strong>#pragma</strong> 是一条预处理的指令，是用来向编译器传达语言标准以外的一些信息。</p><p>C++11 中，定义了与预处理指令 #pragma 功能相同的操作符 <strong>_Pragma</strong>。格式如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">_Pragma</span><span class="token punctuation">(</span>字符串字面量<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用方法跟 sizeof 等操作符一样，将字符串字面量作为参数写在括号内即可。由于 _Pragma 是一个操作符，因此也可以用在宏定义中，而 #pragma 不能在宏中展开。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">_Pragma</span><span class="token punctuation">(</span><span class="token string">"once"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 等价于 #pragma once</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">CONCAT</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token function">PRAGMA</span><span class="token punctuation">(</span>concat on #x<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PRAGMA</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token function">_Pragma</span><span class="token punctuation">(</span>#x<span class="token punctuation">)</span></span></span><span class="token function">CONCAT</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\concat<span class="token punctuation">.</span>dir<span class="token punctuation">)</span>  <span class="token comment">// _Pragma(concat on "..\concat.dir")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-变长参数的宏定义以及-VA-ARGS"><a href="#5-变长参数的宏定义以及-VA-ARGS" class="headerlink" title="5. 变长参数的宏定义以及 __VA_ARGS__"></a>5. 变长参数的宏定义以及 __VA_ARGS__</h3><p>变长参数的宏定义是指在宏定义中参数列表的最后一个参数为省略号，而预定义宏 <strong>__VA_ARGS__</strong> 则可以在宏定义的实现部分替换省略号所代表的字符串。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LOG</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> </span><span class="token string">"%s: Line %d:\t"</span><span class="token expression"><span class="token punctuation">,</span> <span class="token constant">__FILE__</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">\</span>    <span class="token expression"><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> </span><span class="token string">"\n"</span><span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">;</span>\    </span></span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chrono(C++11)</title>
      <link href="/2020/10/18/42367.html"/>
      <url>/2020/10/18/42367.html</url>
      
        <content type="html"><![CDATA[<p>C++11 关于时间引入了 chrono 库，chrono 主要有三个点：</p><ul><li><code>duration</code></li><li><code>time_point</code></li><li><code>clocks</code></li></ul><h2 id="一、duration"><a href="#一、duration" class="headerlink" title="一、duration"></a>一、duration</h2><p><code>std::chrono::duration</code> 表示一段时间，常见的单位有s、ms等。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Rep</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_Period</span> <span class="token operator">=</span> ratio<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">&gt;&gt;</span><span class="token keyword">class</span> <span class="token class-name">duration</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Rep 表示一种数值类型，用来表示 Period 的数量，比如 int、float、double，Period 是 ratio 类型，用来表示<strong>用秒表示的时间单位</strong>，比如 second。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span>intmax_t N<span class="token punctuation">,</span> intmax_t D <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">ratio</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>N 代表分子，D 代表分母，所以 ratio 表示一个分数，分母默认为1，分数值表示秒数。可以自定义 Period，比如 ratio&lt;2, 1&gt; 表示单位时间是2秒。</p><p>常用的 duration&lt;Rep, Period&gt; 已经定义好了，在 <code>std::chrono::duration</code> 下：</p><ul><li>ratio&lt;3600, 1&gt;：hours</li><li>ratio&lt;60, 1&gt;：minutes</li><li>ratio&lt;1, 1&gt;：seconds</li><li>ratio&lt;1, 1000&gt;：microseconds</li><li>ratio&lt;1, 1000000&gt;：microseconds</li><li>ratio&lt;1, 1000000000&gt;：nanosecons</li></ul><p>标准库还提供了 <code>duration_cast</code> 用于转换各种 duration。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> sec <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> mill <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">duration_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>milliseconds<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>sec<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> sec<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 10s   </span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> mill<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 10000ms</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、time-point"><a href="#二、time-point" class="headerlink" title="二、time_point"></a>二、time_point</h2><p><code>std::chrono::time_point</code> 表示一个具体时间点，如2020年5月10日10点10分10秒。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Clock</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_Duration</span> <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token class-name">_Clock</span><span class="token double-colon punctuation">::</span>duration<span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">time_point</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用方式：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// now type: std::chrono::time_point&lt;std::chrono::steady_clock&gt;</span>    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>high_resolution_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> now<span class="token punctuation">.</span><span class="token function">time_since_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>time_t t <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span><span class="token function">to_time_t</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"time: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">ctime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数 <code>time_since_epoch()</code>，表示这个 time_point 距离元年也就是1970年1月1日所经过的 duration。</p><p>time_point 也有各种表示方式，类似于 duration，也提供了转换函数 <code>time_point_cast()</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>high_resolution_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> now<span class="token punctuation">.</span><span class="token function">time_since_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// ns</span>    <span class="token keyword">auto</span> seconds <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">time_point_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>seconds<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> seconds<span class="token punctuation">.</span><span class="token function">time_since_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// s</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、clocks"><a href="#三、clocks" class="headerlink" title="三、clocks"></a>三、clocks</h2><p>时钟，chrono 里面提供了三种时钟：</p><ul><li><code>steady_clock</code></li><li><code>system_clock</code></li><li><code>high_resolution_clock</code></li></ul><h3 id="1-steady-clock"><a href="#1-steady-clock" class="headerlink" title="1. steady_clock"></a>1. steady_clock</h3><p><code>std::chrono::steady_clock</code> 表示稳定的时钟，它只有一个函数，就是 now()，后一次调用 now() 肯定比上一次调用 now() 的返回值大，不受系统时间修改的影响。</p><p>源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">steady_clock</span><span class="token punctuation">{</span>   <span class="token comment">// wraps QueryPerformanceCounter</span>    <span class="token keyword">using</span> rep <span class="token operator">=</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">;</span>    <span class="token keyword">using</span> period <span class="token operator">=</span> nano<span class="token punctuation">;</span>    <span class="token keyword">using</span> duration <span class="token operator">=</span> nanoseconds<span class="token punctuation">;</span>    <span class="token keyword">using</span> time_point <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>time_point<span class="token operator">&lt;</span>steady_clock<span class="token operator">&gt;</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> is_steady <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        _NODISCARD <span class="token keyword">static</span> time_point <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span>   <span class="token comment">// get current time</span>        <span class="token keyword">const</span> <span class="token keyword">long</span> <span class="token keyword">long</span> _Freq <span class="token operator">=</span> <span class="token function">_Query_perf_frequency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// doesn't change after system boot</span>        <span class="token keyword">const</span> <span class="token keyword">long</span> <span class="token keyword">long</span> _Ctr  <span class="token operator">=</span> <span class="token function">_Query_perf_counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">static_assert</span><span class="token punctuation">(</span>period<span class="token double-colon punctuation">::</span>num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"This assumes period::num == 1."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> <span class="token keyword">long</span> <span class="token keyword">long</span> _Whole <span class="token operator">=</span> <span class="token punctuation">(</span>_Ctr <span class="token operator">/</span> _Freq<span class="token punctuation">)</span> <span class="token operator">*</span> period<span class="token double-colon punctuation">::</span>den<span class="token punctuation">;</span>        <span class="token keyword">const</span> <span class="token keyword">long</span> <span class="token keyword">long</span> _Part  <span class="token operator">=</span> <span class="token punctuation">(</span>_Ctr <span class="token operator">%</span> _Freq<span class="token punctuation">)</span> <span class="token operator">*</span> period<span class="token double-colon punctuation">::</span>den <span class="token operator">/</span> _Freq<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">time_point</span><span class="token punctuation">(</span><span class="token function">duration</span><span class="token punctuation">(</span>_Whole <span class="token operator">+</span> _Part<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用方式：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> begin <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>steady_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> end <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>steady_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> spend <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">duration_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>milliseconds<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>end <span class="token operator">-</span> begin<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"time: "</span> <span class="token operator">&lt;&lt;</span> spend<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-system-clock"><a href="#2-system-clock" class="headerlink" title="2. system_clock"></a>2. system_clock</h3><p><code>std::chrono::system_clock</code> 表示当前的系统时钟，可以用于获取当前时间。有三个函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>time_point<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token operator">&gt;</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span> <span class="token comment">// 表示当前时间的 time_point</span><span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>time_t <span class="token function">to_time_t</span><span class="token punctuation">(</span><span class="token keyword">const</span> time_point<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token comment">// 将 time_point 转换成 time_t 秒</span><span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span>time_point <span class="token function">from_time_t</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>time_t t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token comment">// 将 time_t 转换成 time_point</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用方式：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token punctuation">;</span>    <span class="token keyword">auto</span> today <span class="token operator">=</span> system_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>time_t t <span class="token operator">=</span> system_clock<span class="token double-colon punctuation">::</span><span class="token function">to_time_t</span><span class="token punctuation">(</span>today<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"today is: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">ctime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-high-resolution-clock"><a href="#3-high-resolution-clock" class="headerlink" title="3. high_resolution_clock"></a>3. high_resolution_clock</h3><p><code>std::chrono::high_resolution_clock</code> 表示系统可用的最高精度的时钟，实际上就是 <code>std::chrono::system_clock</code> 或者 <code>std::chrono::steady_clock</code> 其中一种的定义，官方没有说明具体是哪个，不同系统可能不一样。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// MSVC 编译器中</span><span class="token keyword">using</span> high_resolution_clock <span class="token operator">=</span> steady_clock<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="四、计时器-timer"><a href="#四、计时器-timer" class="headerlink" title="四、计时器 timer"></a>四、计时器 timer</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Timer</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">begin_</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>high_resolution_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment">/**     * @brief   重置     */</span>    <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        begin_ <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>high_resolution_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * @brief   默认输出毫秒     */</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Duration</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>milliseconds<span class="token operator">&gt;</span>    <span class="token keyword">int64_t</span> <span class="token function">elapsed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">auto</span> end <span class="token operator">=</span> high_resolution_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">duration_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Duration<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>end <span class="token operator">-</span> begin_<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * @brief   微秒     */</span>    <span class="token keyword">int64_t</span> <span class="token function">elapsed_micro</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">elapsed</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>microseconds<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * @brief   纳秒     */</span>    <span class="token keyword">int64_t</span> <span class="token function">elapsed_nano</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">elapsed</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>nanoseconds<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * @brief   秒     */</span>    <span class="token keyword">int64_t</span> <span class="token function">elapsed_sconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">elapsed</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>seconds<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * @brief   分钟     */</span>    <span class="token keyword">int64_t</span> <span class="token function">elapsed_minutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">elapsed</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>minutes<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * @brief   小时     */</span>    <span class="token keyword">int64_t</span> <span class="token function">elapsed_hours</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">elapsed</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>hours<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>time_point<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>high_resolution_clock<span class="token operator">&gt;</span> begin_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Timer t<span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span><span class="token function">elapsed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// func 函数耗时毫秒</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span><span class="token function">elapsed_micro</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">//func 函数耗时微秒</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span><span class="token function">elapsed_nano</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// func 函数耗时纳秒</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span><span class="token function">elapsed_sconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// func 函数耗时秒</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span><span class="token function">elapsed_minutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// func 函数耗时分</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span><span class="token function">elapsed_hours</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// func 函数耗时小时</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步(C++11)</title>
      <link href="/2020/10/17/23650.html"/>
      <url>/2020/10/17/23650.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、std-future"><a href="#一、std-future" class="headerlink" title="一、std::future"></a>一、std::future</h2><p><code>&lt;future&gt;</code> 头文件中包含了以下几个类和函数：</p><ul><li>Providers 类：<code>std::promise</code>，<code>std::package_task</code>；</li><li>Futures 类：<code>std::future</code>，<code>std::shared_future</code>；</li><li>Providers 函数：<code>std::async()</code>；</li><li>其他类型：<code>std::future_error</code>，<code>std::future_errc</code>，<code>std::future_status</code>，<code>std::launch</code>。</li></ul><h3 id="1-std-promise"><a href="#1-std-promise" class="headerlink" title="1. std::promise"></a>1. std::promise</h3><p><code>std::promise</code>对象可以<strong>保存某一类型 T 的值</strong>，该值可被 <code>std::future</code> 对象读取（可能在另外一个线程中），因此该类提供了一种线程同步的手段。</p><p>在 <code>std::promise</code> 对象构造时可以和一个共享状态（通常是 <code>std::future</code>）相关联，并可以在相关联的共享状态（<code>std::future</code>）上保存一个类型为 T 的值。<code>std::promise</code> 禁止拷贝，支持移动语义。</p><p>通过 get_future() 来获取与该 <code>std::promise</code> 对象相关联的 <code>std::future</code> 对象。</p><ul><li><code>std::promise</code> 对象是异步 Provider，它可以在某一时刻设置共享状态的值；</li><li><code>std::future</code> 对象可以异步返回共享状态的值，或者在必要的情况下阻塞调用者并等待共享状态标志变为 ready，然后获取共享状态的值。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;future&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> fut<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> fut<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 获取共享状态的值</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"value: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// value: 10</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> prom<span class="token punctuation">;</span>  <span class="token comment">// 生成一个 std::promise&lt;int&gt; 对象</span>    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> fut <span class="token operator">=</span> prom<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 和 future 关联</span>    std<span class="token double-colon punctuation">::</span>thread <span class="token function">thd</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>fut<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将 future 交给另外一个线程</span>    prom<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 设置共享状态的值, 此处和线程保持同步</span>    thd<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> lam <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> pro<span class="token punctuation">)</span> <span class="token punctuation">{</span>        pro<span class="token punctuation">.</span><span class="token function">set_value_at_thread_exit</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    prom <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">promise</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// move 语义</span>    thd <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>lam<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>prom<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fut <span class="token operator">=</span> prom<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"value: "</span> <span class="token operator">&lt;&lt;</span> fut<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// value: 20</span>    thd<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-1-get-future"><a href="#1-1-get-future" class="headerlink" title="1.1 get_future()"></a>1.1 get_future()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>R<span class="token operator">&gt;</span> <span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回一个与 promise 共享状态相关联的 future。返回的 future 对象可以访问由 promise 对象设置在共享状态上的值或者某个异常对象。只能从 promise 共享状态获取一个 future 对象。在调用该函数之后，promise 对象通常会在某个时间点准备好（设置一个值或者一个异常对象），如果不设置值或者异常，promise 对象在析构时会自动地设置一个 future_error 异常（broken_promise）来设置其自身的准备状态。</p><h4 id="1-2-set-value"><a href="#1-2-set-value" class="headerlink" title="1.2 set_value()"></a>1.2 set_value()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">set_value</span><span class="token punctuation">(</span><span class="token keyword">const</span> R<span class="token operator">&amp;</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">set_value</span><span class="token punctuation">(</span>R<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>设置共享状态的值，promise 的共享状态标志变为 ready。</p><h4 id="1-3-set-exception"><a href="#1-3-set-exception" class="headerlink" title="1.3 set_exception()"></a>1.3 set_exception()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">set_exception</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>exception_ptr p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置异常，promise 的共享状态变标志变为 ready。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;future&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;exception&gt;</span></span><span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> prom<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Please, enter an integer value: "</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">exceptions</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ios<span class="token double-colon punctuation">::</span>failbit<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// throw on failbit</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> x<span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> x<span class="token punctuation">;</span>  <span class="token comment">// sets failbit if input is not int</span>        prom<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>exception<span class="token operator">&amp;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        prom<span class="token punctuation">.</span><span class="token function">set_exception</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">current_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> fut<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> fut<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"value: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>exception<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"exception: "</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> prom<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> fut <span class="token operator">=</span> prom<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>thread <span class="token function">th1</span><span class="token punctuation">(</span>set<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>prom<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>thread <span class="token function">th2</span><span class="token punctuation">(</span>get<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>fut<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    th1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    th2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-set-value-at-thread-exit"><a href="#1-4-set-value-at-thread-exit" class="headerlink" title="1.4 set_value_at_thread_exit()"></a>1.4 set_value_at_thread_exit()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">set_value_at_thread_exit</span><span class="token punctuation">(</span><span class="token keyword">const</span> R<span class="token operator">&amp;</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">set_value_at_thread_exit</span><span class="token punctuation">(</span>R<span class="token operator">&amp;&amp;</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>设置共享状态的值，但是不将共享状态的标志设置为 ready，当线程退出时该 promise 对象会自动设置为 ready。如果某个 future 对象与该 promise 对象的共享状态相关联，并且该 future 正在调用 get，则调用 get 的线程会被阻塞，当线程退出时，调用 <code>future::get</code> 的线程解除阻塞，同时 get 返回 <code>set_value_at_thread_exit</code> 所设置的值。</p><p>注意：该函数已经设置了 promise 共享状态的值，如果在线程结束之前有其他设置或者修改共享状态的值的操作，则会抛出 future_error(promise_already_satisfied)。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;future&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> prom<span class="token punctuation">)</span><span class="token punctuation">{</span>    prom<span class="token punctuation">.</span><span class="token function">set_value_at_thread_exit</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> fut<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> fut<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"value: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> prom<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> fut <span class="token operator">=</span> prom<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>thread <span class="token function">th1</span><span class="token punctuation">(</span>set<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>prom<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>thread <span class="token function">th2</span><span class="token punctuation">(</span>get<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>fut<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    th1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    th2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-5-set-exception-at-thread-exit"><a href="#1-5-set-exception-at-thread-exit" class="headerlink" title="1.5 set_exception_at_thread_exit()"></a>1.5 set_exception_at_thread_exit()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">set_exception_at_thread_exit</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>exception_ptr p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置异常值，但是不将共享状态的标志设置为 ready，当线程退出时该 promise 对象会自动设置为 ready。作用同 <code>set_value_at_thread_exit()</code>。</p><h3 id="2-std-packaged-task"><a href="#2-std-packaged-task" class="headerlink" title="2. std::packaged_task"></a>2. std::packaged_task</h3><p><code>std::packaged_task</code><strong>包装一个可调用的对象</strong>，并且允许异步获取该可调用对象产生的结果。</p><p><code>std::packaged_task</code>对象内部包含了两个最基本元素：</p><ul><li><strong>被包装的任务</strong>：任务是一个可调用的对象，如函数指针、成员函数指针或者函数对象；</li><li><strong>共享状态</strong>：用于保存任务的返回值，可以通过 future 对象来达到异步访问共享状态的效果。</li></ul><p>通过 <code>std::packaged_task::get_future</code> 来获取与共享状态相关联的 <code>std::future</code> 对象。在调用该函数之后，两个对象共享相同的状态：</p><ul><li><code>std::packaged_task</code> 对象是异步 Provider，它在某一时刻通过调用被包装的任务来设置共享状态的值；</li><li><code>std::future</code> 对象是一个异步返回对象，通过它可以获得共享状态的值，在必要的时候需要等待共享状态标志变为 ready。</li></ul><p><code>std::packaged_task</code> 共享状态的生命周期一直持续到最后一个与之相关联的对象被释放或者销毁为止，同样禁止拷贝，支持移动语义。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;future&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int32_t</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">task</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 创建 packaged_task</span>    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> fut <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 获得与 packaged_task 共享状态相关联的 future 对象</span>    std<span class="token double-colon punctuation">::</span>thread <span class="token function">thd</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 创建一个新线程完成任务</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> fut<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 等待任务完成并获取结果</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func result: "</span> <span class="token operator">&lt;&lt;</span> ret <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    thd<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-valid"><a href="#2-1-valid" class="headerlink" title="2.1 valid()"></a>2.1 valid()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">valid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查当前 packaged_task 是否和一个有效的共享状态相关联，对于由默认构造函数生成的 packaged_task 对象，该函数返回 false。</p><h4 id="2-2-get-future"><a href="#2-2-get-future" class="headerlink" title="2.2 get_future()"></a>2.2 get_future()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>R<span class="token operator">&gt;</span> <span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回一个与 packaged_task 对象共享状态相关的 future 对象，返回的 future 对象可以获得在该 packaged_task 对象的共享状态上设置的某个值或者异常。</p><h4 id="2-3-operator"><a href="#2-3-operator" class="headerlink" title="2.3 operator()"></a>2.3 operator()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ArgTypes<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用该 packaged_task 对象所包装的对象（通常为函数指针，函数对象，lambda 表达式等），传入的参数为 args，调用该函数一般会发生两种情况：</p><ul><li>如果调用 packaged_task 所包装的对象成功，则返回值（如果被包装的对象有返回值的话）被保存在 packaged_task 的共享状态中；</li><li>如果调用 packaged_task 所包装的对象失败，并且抛出了异常，则异常也会被保存在 packaged_task 的共享状态中。</li></ul><p>以上两种情况都使共享状态的标志变为 ready，因此其他等待该共享状态的线程可以获取共享状态的值或者异常并继续执行下去。</p><p>共享状态的值可以通过 future 对象（由 get_future 获得）调用 get 来获得。</p><p>由于被包装的任务在 packaged_task 构造时指定，因此调用 operator() 的效果由 packaged_task 对象构造时所指定的可调用对象来决定：</p><ul><li>如果被包装的任务是函数指针或者函数对象，调用 operator() 只是将参数传递给被包装的对象；</li><li>如果被包装的任务是指向类的非静态成员函数的指针，那么 operator() 的第一个参数应该指定为成员函数被调用的那个对象，剩余的参数作为该成员函数的参数；</li><li>如果被包装的任务是指向类的非静态成员变量，那么 operator() 只允许单个参数。</li></ul><h4 id="2-4-make-ready-at-thread-exit"><a href="#2-4-make-ready-at-thread-exit" class="headerlink" title="2.4 make_ready_at_thread_exit()"></a>2.4 make_ready_at_thread_exit()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">make_ready_at_thread_exit</span><span class="token punctuation">(</span>ArgTypes<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该函数会调用被包装的任务，并向任务传递参数，类似 operator() 成员函数。但是与 operator() 函数不同的是，<code>make_ready_at_thread_exit</code> 并不会立即设置共享状态的标志为 ready，而是在线程退出时设置共享状态的标志。</p><p>如果与该 packaged_task 共享状态相关联的 future 对象调用 <code>future::get</code>，则该函数会被阻塞，直到 packaged_task 所在线程退出。</p><p>注意：该函数已经设置了 promise 共享状态的值，如果在线程结束之前有其他设置或者修改共享状态的值的操作，则会抛出 future_error(promise_already_satisfied)。</p><h4 id="2-5-reset"><a href="#2-5-reset" class="headerlink" title="2.5 reset()"></a>2.5 reset()</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void reset();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重置 packaged_task 的共享状态，但是保留之前被包装的任务。</p><h4 id="2-6-示例"><a href="#2-6-示例" class="headerlink" title="2.6 示例"></a>2.6 示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;future&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>std<span class="token double-colon punctuation">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> task<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    task<span class="token punctuation">.</span><span class="token function">make_ready_at_thread_exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int32_t</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    task <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">packaged_task</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 创建 packaged_task</span>    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> fut <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 获得与 packaged_task 共享状态相关联的 future 对象</span>    <span class="token comment">// 执行任务</span>    <span class="token function">task</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 等待任务完成并获取结果</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> fut<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ret == 5</span>    task<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fut <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>thread thd <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> fut<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ret == 1</span>    thd<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-std-future"><a href="#3-std-future" class="headerlink" title="3. std::future"></a>3. std::future</h3><p><code>std::future</code>可以用来获取异步任务的结果，因此可以把它当成一种简单的线程间同步的手段。<code>std::future</code> 通常由某个 Provider 创建，可以把 Provider 想象成一个异步任务的提供者，Provider 在某个线程中设置共享状态的值，与该共享状态相关联的 <code>std::future</code> 对象调用 get（通常在另外一个线程中）获取该值，如果共享状态的标志不为 ready，则调用 get 会阻塞当前的调用者，直到 Provider 设置了共享状态的值（此时共享状态的标志变为 ready），get 返回异步任务的值或异常（如果发生了异常）。</p><p><code>std::future</code> 对象通常由以下三种 Provider 创建，并和某个共享状态相关联。Provider 可以是函数或者类，分别是：</p><ul><li><code>std::async()</code>；</li><li><code>std::promise::get_future()</code>；</li><li><code>std::packaged_task::get_future()</code>。</li></ul><p><code>std::future</code> 对象只有在有效的情况下才有用，由 <code>std::future</code> 默认构造函数创建的对象不是有效的。同样，<code>std::future</code> 也是禁止拷贝，支持移动语义。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;future&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">bool</span> <span class="token function">isPrime</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> x<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> fut <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>isPrime<span class="token punctuation">,</span> <span class="token number">66666663</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"checking, please wait"</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>milliseconds <span class="token function">span</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fut<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>span<span class="token punctuation">)</span> <span class="token operator">==</span> std<span class="token double-colon punctuation">::</span>future_status<span class="token double-colon punctuation">::</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token char">'.'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> x <span class="token operator">=</span> fut<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n66666663 "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>x <span class="token operator">?</span> <span class="token string">"is"</span> <span class="token operator">:</span> <span class="token string">"is not"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" prime.\n"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-1-share"><a href="#3-1-share" class="headerlink" title="3.1 share()"></a>3.1 share()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_future<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">share</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回一个 <code>std::shared_future</code> 对象，调用该函数之后，该 future 对象本身已经不和任何共享状态相关联，因此该 future 的状态不再是 valid 的。</p><h4 id="3-2-get"><a href="#3-2-get" class="headerlink" title="3.2 get()"></a>3.2 get()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当与该 future 对象相关联的共享状态标志变为 ready 后，调用该函数将返回保存在共享状态中的值，如果共享状态的标志不为 ready，则调用该函数会阻塞当前的调用者，而此后一旦共享状态的标志变为 ready，get 返回 Provider 所设置的共享状态的值或者异常（如果抛出了异常）。</p><h4 id="3-3-valid"><a href="#3-3-valid" class="headerlink" title="3.3 valid()"></a>3.3 valid()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">valid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查当前的 <code>std::future</code> 对象是否有效。</p><h4 id="3-4-wait"><a href="#3-4-wait" class="headerlink" title="3.4 wait()"></a>3.4 wait()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等待与当前 future 对象相关联的共享状态的标志变为 ready。如果共享状态的标志不是 ready，调用该函数的线程会被阻塞，直到共享状态的标志变为 ready。一旦共享状态的标志变为 ready，wait 函数返回，当前线程被解除阻塞，但是 wait 并不读取共享状态的值或者异常信息。</p><h4 id="3-5-wait-for"><a href="#3-5-wait-for" class="headerlink" title="3.5 wait_for()"></a>3.5 wait_for()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Rep</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Period</span><span class="token operator">&gt;</span>std<span class="token double-colon punctuation">::</span>future_status <span class="token function">wait_for</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span>Rep<span class="token punctuation">,</span>Period<span class="token operator">&gt;</span><span class="token operator">&amp;</span> timeout_duration<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>与 wait() 的功能类似，不同的是，wait_for() 可以设置一个时间段 rel_time，如果共享状态的标志在该时间段结束之前没有被 Provider 设置为 ready，则调用 wait_for 的线程被阻塞，在等待了 rel_time 时间后 wait_for() 返回，返回值如下：</p><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>future_status::ready</td><td>共享状态的标志已经变为 ready，即 Provider 在共享状态上设置了值或者异常</td></tr><tr><td>future_status::timeout</td><td>超时，即在规定的时间内共享状态的标志没有变为 ready</td></tr><tr><td>future_status::deferred</td><td>共享状态包含一个 deferred 函数</td></tr></tbody></table><h4 id="3-6-wait-until"><a href="#3-6-wait-until" class="headerlink" title="3.6 wait_until()"></a>3.6 wait_until()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Clock</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Duration</span><span class="token operator">&gt;</span>std<span class="token double-colon punctuation">::</span>future_status <span class="token function">wait_until</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>time_point<span class="token operator">&lt;</span>Clock<span class="token punctuation">,</span>Duration<span class="token operator">&gt;</span><span class="token operator">&amp;</span> timeout_time<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>与 wait_for() 类似，不同的是设置一个绝对时间点 abs_time。</p><h3 id="4-std-shared-future"><a href="#4-std-shared-future" class="headerlink" title="4. std::shared_future"></a>4. std::shared_future</h3><p><code>std::shared_future</code> 与 <code>std::future</code> 类似，但是 <code>std::shared_future</code> 可以拷贝，多个 <code>std::shared_future</code> 可以共享某个共享状态的最终结果（即共享状态的某个值或者异常）。<code>std::shared_future</code> 可以通过某个 <code>std::future</code> 对象隐式转换（参见 <code>std::shared_future</code> 的构造函数），或者通过 <code>std::future::share()</code> 显示转换，无论哪种转换，被转换的那个 future 对象都会变为 not-valid。</p><h2 id="二、std-async"><a href="#二、std-async" class="headerlink" title="二、std::async"></a>二、std::async</h2><p><code>std::async</code> 是比 <code>std::future</code>，<code>std::packaged_task</code>，<code>std::promise</code> 更上层，它是基于任务的异步操作，可以用来直接创建异步的 task，异步任务返回的结果保存在 <code>std::future</code> 中，当需要获取线程执行的结果，可以通过 <code>future::get</code> 来获取，如果不关注异步任务的结果，只是简单的等待任务执行完成，则调用 <code>future::wait</code> 即可。</p><p>async 是更高层次的异步操作，不关心线程创建的内部细节，就能方便的获取线程异步执行的结果，还可以指定线程创建策略，更多的时候应该使用 <code>std::async</code> 来创建线程，成为异步操作的首选。</p><p>具体语法如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>async <span class="token operator">|</span> std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>deferred<span class="token punctuation">,</span> func<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一个参数是创建策略：</p><ul><li><strong>std::launch::async</strong>：表示任务执行在另一线程，在调用 async 之后就开始创建线程</li><li><strong>std::launch::deferred</strong>：表示延迟执行任务，调用 get 或者 wait 时才会执行，不会创建线程，惰性执行在当前线程。</li></ul><p>如果不明确指定创建策略，以上两个都不是 async 的默认策略，而是未定义，它是一个基于任务的程序设计，内部有一个调度器（线程池），会根据实际情况决定采用哪种策略。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;future&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> fut1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> fut1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 10</span>    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span> fut2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">20</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fut2<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> fut3 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">30</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Wating..."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>future_status status<span class="token punctuation">;</span>    <span class="token keyword">do</span>    <span class="token punctuation">{</span>        status <span class="token operator">=</span> fut3<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token double-colon punctuation">::</span>future_status<span class="token double-colon punctuation">::</span>deferred<span class="token punctuation">)</span> <span class="token punctuation">{</span>            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"deferred."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token double-colon punctuation">::</span>future_status<span class="token double-colon punctuation">::</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"timeout."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ready."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>status <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>future_status<span class="token double-colon punctuation">::</span>ready<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> fut3<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 30</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>异步任务的封装：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">&gt;</span><span class="token keyword">inline</span> <span class="token keyword">auto</span> <span class="token function">create_async</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>F<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Args<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并行(C++11)</title>
      <link href="/2020/10/16/28933.html"/>
      <url>/2020/10/16/28933.html</url>
      
        <content type="html"><![CDATA[<p>C++11 引入了五个头文件来支持多线程编程，分别是：<code>&lt;atomic&gt;</code>，<code>&lt;thread&gt;</code>，<code>&lt;mutex&gt;</code>，<code>&lt;condition_variable&gt;</code>。</p><ul><li><code>&lt;atomic&gt;</code>：声明了 <code>std::atomic</code> 和 <code>std::atomic_flag</code> ；</li><li><code>&lt;thread&gt;</code>：声明了 <code>std::thread</code> ，以及<code>std::this_thread</code> 命名空间；</li><li><code>&lt;mutex&gt;</code>：声明了与互斥量（mutex）相关的类，包括 <code>std::mutex</code> 系列，<code>std::lock_guard</code>，<code>std::unique_lock</code> 以及其他的类型和函数；</li><li><code>&lt;condition_variable&gt;</code>：声明了与条件变量相关的类，包括 <code>std::condition_variable</code> 和 <code>std::condition_variable_any</code>。</li></ul><h2 id="一、thread"><a href="#一、thread" class="headerlink" title="一、thread"></a>一、thread</h2><h3 id="1-线程的创建"><a href="#1-线程的创建" class="headerlink" title="1. 线程的创建"></a>1. 线程的创建</h3><p>C++11 引入了 <code>std::thread</code> 来创建线程，支持对线程 join 或者 detach。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">auto</span> func1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>func1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 检查线程可否被join</span>        t1<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">auto</span> func2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>func2<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t2<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：可被 joinable 的 thread 对象必须在它们销毁之前被主线程 join 或者将其设置为 detached。</p><h3 id="2-阻塞-amp-非阻塞"><a href="#2-阻塞-amp-非阻塞" class="headerlink" title="2. 阻塞 &amp; 非阻塞"></a>2. 阻塞 &amp; 非阻塞</h3><p>在线程执行的时候，可以选择线程是否阻塞执行，如果阻塞，则主线程等子线程函数执行完，再往下执行，否则启动线程之后，主线程直接往下执行。</p><p><code>join()</code> 函数会阻塞主线程，直到子线程函数执行结束，如果线程函数有返回值，返回值会被忽略。</p><p><code>detach()</code> 函数会将线程和线程对象分离，让线程作为后台线程执行，当前线程不会阻塞，但是，分离之后的线程就无法再和主线程发生联系，不能再通过 join 来等待线程执行完成，线程何时执行完成也无法控制。</p><p><strong>注意</strong>：<code>std::thread</code> 出了作用域之后将会析构，如果线程函数还未执行完成，则会发生错误，所以，需要保证线程函数的生命周期在线程变量 thread 的生命周期内。</p><h3 id="3-其他用法"><a href="#3-其他用法" class="headerlink" title="3. 其他用法"></a>3. 其他用法</h3><h4 id="3-1-移动"><a href="#3-1-移动" class="headerlink" title="3.1 移动"></a>3.1 移动</h4><p><code>std::thread</code> 禁止拷贝，但是可以移动，移动后的线程不代表任何线程。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// t1.join();    将会抛异常</span>    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-其他线程函数传入方式"><a href="#3-2-其他线程函数传入方式" class="headerlink" title="3.2 其他线程函数传入方式"></a>3.2 其他线程函数传入方式</h4><p>通过 <code>std::bind()</code> 或者 lambda 表达式来创建线程。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>func1<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>func2<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>thread <span class="token function">t3</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-线程信息获取"><a href="#3-3-线程信息获取" class="headerlink" title="3.3 线程信息获取"></a>3.3 线程信息获取</h4><p>获取当前线程的 ID，还可以获取当前 CPU 的核心数量。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 获取当前线程 ID</span>std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取CPU核心数量</span>std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span><span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-线程休眠"><a href="#3-4-线程休眠" class="headerlink" title="3.4 线程休眠"></a>3.4 线程休眠</h4><p>通过 <code>std::this_thread::sleep_for()</code> 或 <code>std::this_thread::sleep_until()</code> 来让当前线程休眠一段时间。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-5-yield-函数"><a href="#3-5-yield-函数" class="headerlink" title="3.5 yield 函数"></a>3.5 yield 函数</h4><p><code>std::this_thread::yield()</code> 函数的作用是当前线程“放弃”执行，让操作系统调度另一线程继续执行。</p><p>将悬挂当前线程并将它放到准备运行的同优先级线程的队列尾（而若无其他线程在同优先级，则 <code>yield</code> 无效果），此函数的准确性为依赖于实现。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">ready</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 由于使用了yield函数，在 not Ready 情况下，避免了空循环，在一定程度上，可以提高 cpu 的利用率</span>        std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    std<span class="token double-colon punctuation">::</span>string <span class="token function">str</span><span class="token punctuation">(</span><span class="token string">"thread : "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> str<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>thread thds<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"race of 10 threads that count to 1 million:\n"</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        thds<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ready <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> th <span class="token operator">:</span> thds<span class="token punctuation">)</span> <span class="token punctuation">{</span>        th<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、mutex"><a href="#二、mutex" class="headerlink" title="二、mutex"></a>二、mutex</h2><p>mutex 是一种线程同步的手段，用于保证多线程同时操作的共享数据的正确性。分为四种：</p><ul><li><code>std::mutex</code>：独占的互斥量，不能递归使用，不带超时功能；</li><li><code>std::recursive_mutex</code>：递归互斥量，可重入，不带超时功能；</li><li><code>std::timed_mutex</code>：带超时的互斥量，不能递归；</li><li><code>std::recursive_timed_mutex</code>：带超时的互斥量，可以递归使用。</li></ul><p>lock 有两种 RAII 方式的锁封装，可以方便的操作 mutex：</p><ul><li><code>std::lock_guard</code>：方便对互斥量上锁；</li><li><code>std::unique_lock</code>：方便对互斥量上锁，但提供了更好的上锁和解锁控制。</li></ul><h3 id="1-独占互斥量"><a href="#1-独占互斥量" class="headerlink" title="1. 独占互斥量"></a>1. 独占互斥量</h3><p><code>std::mutex</code> 不允许拷贝，也不允许移动，mutex 对象的初始状态为 unlocked。</p><ul><li><code>lock()</code>：线程调用该函数会发生 3 种情况：<ul><li>如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock 之前，该线程一直拥有锁；</li><li>如果该互斥量被其他线程锁住，则当前的调用线程被阻塞；</li><li>如果该互斥量被当前调用线程锁住，则会产生死锁 (deadlock)。</li></ul></li><li><code>unlock()</code>：解锁，释放对互斥量的所有权；</li><li><code>try_lock()</code>：尝试锁住互斥量，线程调用该函数也会出现 3 种情况：<ul><li>如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量；</li><li>如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞；</li><li>如果当前互斥量被当前调用线程锁住，则当前调用线程返回 false。</li></ul></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span><span class="token keyword">volatile</span> <span class="token keyword">int</span> counter<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>mutex mtx<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">thread_proc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mtx<span class="token punctuation">.</span><span class="token function">try_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token operator">++</span>counter<span class="token punctuation">;</span>            mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">constexpr</span> size_t num<span class="token punctuation">{</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>thread threads<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>thread_proc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> th <span class="token operator">:</span> threads<span class="token punctuation">)</span> <span class="token punctuation">{</span>        th<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> counter <span class="token operator">&lt;&lt;</span> <span class="token string">" successful increases of the counter.\n"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-递归互斥量"><a href="#2-递归互斥量" class="headerlink" title="2. 递归互斥量"></a>2. 递归互斥量</h3><p><code>std::recursive_mutex</code> 与 <code>std::mutex</code> 一样，也是一种可以被上锁的对象，但是和 mutex 不同的是，recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权。recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock，可理解为 lock 次数和 unlock 次数相同，除此之外，recursive_mutex 和 mutex 大致相同。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>std<span class="token double-colon punctuation">::</span>recursive_mutex mutex<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>recursive_mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>recursive_mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>recursive_mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，尽量少用递归锁，原因如下：</p><ul><li>允许递归互斥容易放纵复杂逻辑的产生，从而导致一些多线程同步引起的晦涩问题；</li><li>递归锁比非递归锁效率低；</li><li>递归锁虽然可以在同一线程多次获取，但是获取次数过多容易发生问题，引发 <code>std::system</code> 错误。</li></ul><h3 id="3-超时互斥量"><a href="#3-超时互斥量" class="headerlink" title="3. 超时互斥量"></a>3. 超时互斥量</h3><p><code>std::time_mutex</code> 是带超时的独占锁，<code>std::recursive_timed_mutex</code> 是带超时的递归锁，主要用于在获取锁时增加超时等待功能，设置一个等待获取锁的时间，超时后做其他的事情。超时锁多了两个获取锁的接口：</p><ul><li><code>try_lock_for()</code> 函数接受一个时间范围，表示在这一段时间之内，线程如果没有获得锁则被阻塞，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false；</li><li><code>try_lock_until()</code> 函数则接受一个时间点，在指定时间点未到来之前，线程如果没有获得锁则被阻塞，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>std<span class="token double-colon punctuation">::</span>timed_mutex mutex<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">thread_proc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>mutex<span class="token punctuation">.</span><span class="token function">try_lock_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"-"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"*\n"</span><span class="token punctuation">;</span>    mutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">constexpr</span> size_t num<span class="token punctuation">{</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>thread threads<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>thread_proc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> th <span class="token operator">:</span> threads<span class="token punctuation">)</span> <span class="token punctuation">{</span>        th<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-lock-锁"><a href="#4-lock-锁" class="headerlink" title="4. lock 锁"></a>4. lock 锁</h3><p>C++11 标准提供了两种基本的锁类型，分别如下：</p><ul><li><code>std::lock_guard</code>：与 Mutex RAII 相关，方便线程对互斥量上锁</li><li><code>std::unique_lock</code>：与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制</li></ul><p>使用 <code>std::lock_guard</code> 和 <code>std::unique_lock</code> 可以简化 lock/unlock 的写法，同时也更安全，因为使用了 RAII 技术，在构造分配资源，在析构释放资源，会在构造时自动锁定互斥量，在退出作用域之后进行解锁，所以不用担心没有解锁的情况，更加安全。</p><p><code>std::unique_lock</code> 相比于 <code>std::lock_guard</code> 提供了更好的上锁和解锁控制，它可以自由的释放 mutex，而 lock_guard 需要等生命周期结束才能释放。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>std<span class="token double-colon punctuation">::</span>mutex mutex<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// std::lock_guard&lt;std::mutex&gt; lock(mutex);</span>        std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">constexpr</span> size_t num<span class="token punctuation">{</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>thread threads<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> th <span class="token operator">:</span> threads<span class="token punctuation">)</span> <span class="token punctuation">{</span>        th<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::adopt_lock_t</code>、<code>std::defer_lock_t</code>、<code>std::try_to_lock_t</code> 通常作为参数传入给 <code>std::unique_lock</code> 或 <code>std::lock_guard</code> 的构造函数。</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>std::defer_lock_t</td><td>do not acquire ownership of the mutex</td></tr><tr><td>std::try_to_lock_t</td><td>try to acquire ownership of the mutex without blocking</td></tr><tr><td>std::adopt_lock_t</td><td>assume the calling thread already has ownership of the mutex</td></tr></tbody></table><h2 id="三、condition-variable"><a href="#三、condition-variable" class="headerlink" title="三、condition_variable"></a>三、condition_variable</h2><p><code>std::condition_variable</code>（条件变量）是 C++11 引入的一种同步机制，它可以阻塞一个线程或者多个线程，直到收到另外一个线程发出的通知或者超时，才会唤醒当前阻塞的线程，条件变量要和互斥量配合起来使用。</p><ul><li><code>std::condition_variable</code>：配合 <code>std::unique_lock&lt;std::mutex&gt;</code> 进行 wait 操作。</li><li><code>std::condition_variable_any</code>：和任意带有 lock、unlock 语意的 mutex 搭配使用，比较灵活，但是效率比 <code>std::condition_variable</code> 低。</li></ul><h3 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h3><p>条件变量的使用过程如下：</p><ol><li>拥有条件变量的线程获取互斥量；</li><li>循环检查某个条件，如果条件不满足，则阻塞线程直到满足；如果条件满足，则向下执行；</li><li>某个线程满足条件并执行完成之后，调用 notify_one 或者 notify_all 来唤醒一个或者多个线程。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">explicit</span> <span class="token function">CountDownLatch</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">count_</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">locker</span><span class="token punctuation">(</span>mutex_<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count_ <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cv_<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>locker<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">count_down</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">locker</span><span class="token punctuation">(</span>mutex_<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">--</span>count_<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count_ <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cv_<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">mutable</span> std<span class="token double-colon punctuation">::</span>mutex mutex_<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>condition_variable cv_<span class="token punctuation">;</span>    <span class="token keyword">int</span> count_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>条件变量其实还涉及到通知丢失和虚假唤醒问题</strong>。</p><p>条件变量的 wait 方法还有个重载方法，可以接受一个条件。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">locker</span><span class="token punctuation">(</span>mutex_<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>count_ <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cv_<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>locker<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 可以这样写</span>std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">locker</span><span class="token punctuation">(</span>mutex_<span class="token punctuation">)</span><span class="token punctuation">;</span>cv_<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>locker<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> count_ <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两种写法都一样，后者代码更加简洁。条件变量先检查判断式是否满足条件，如果满足，结束 wait，继续往下执行；如果不满足条件，则释放 mutex，将线程置为 waiting 状态，继续等待。</p><p>在线程被阻塞时，wait 函数会自动调用 locker.unlock() 释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。另外，一旦当前线程获得通知(notified，通常是另外某个线程调用 notify_* 唤醒了当前线程)，wait() 函数也是自动调用 locker.lock()，使得 locker 的状态和 wait 函数被调用时相同。</p><h3 id="2-超时等待"><a href="#2-超时等待" class="headerlink" title="2. 超时等待"></a>2. 超时等待</h3><p>除了 wait() 还可以使用超时等待函数 wait_for() 和 wait_until()。</p><p>wait_for() 可以指定一个时间段，在当前线程收到通知或者指定的时间 rel_time 超时之前，该线程都会处于阻塞状态。而一旦超时或者收到了其他线程的通知，wait_for() 返回，剩下的处理步骤和 wait() 类似。</p><p>wait_until() 可以指定一个时间点，在当前线程收到通知或者指定的时间点 abs_time 超时之前，该线程都会处于阻塞状态。而一旦超时或者收到了其他线程的通知，wait_until() 返回，剩下的处理步骤和 wait() 类似。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> value<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>condition_variable cv<span class="token punctuation">;</span>    <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cv<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入数字："</span><span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> value<span class="token punctuation">;</span>        cv<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// while (cv.wait_until(lock, std::chrono::system_clock::now() + std::chrono::seconds(1)) == std::cv_status::timeout) {</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cv<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> std<span class="token double-colon punctuation">::</span>cv_status<span class="token double-colon punctuation">::</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"输出："</span> <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>wait_for 和 wait_until 返回值为：std::cv_status 枚举类型。</p><table><thead><tr><th>cv_status</th><th>说明</th></tr></thead><tbody><tr><td>cv_status::no_timeout</td><td>wait_for 或者 wait_until 没有超时，即在规定的时间段内线程收到了通知。</td></tr><tr><td>cv_status::timeout</td><td>wait_for 或者 wait_until 超时。</td></tr></tbody></table><h3 id="3-std-notify-all-at-thread-exit"><a href="#3-std-notify-all-at-thread-exit" class="headerlink" title="3. std::notify_all_at_thread_exit"></a>3. std::notify_all_at_thread_exit</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">notify_all_at_thread_exit</span><span class="token punctuation">(</span>condition_variable<span class="token operator">&amp;</span> cond<span class="token punctuation">,</span> unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> lck<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当调用该函数的线程退出时，所有在 cond 条件变量上等待的线程都会收到通知。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable&gt;</span></span>std<span class="token double-colon punctuation">::</span>mutex mtx<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>condition_variable cv<span class="token punctuation">;</span><span class="token keyword">bool</span> ready <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">locker</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>locker<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread "</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">go</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">locker</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span><span class="token function">notify_all_at_thread_exit</span><span class="token punctuation">(</span>cv<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>locker<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ready <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>thread threads<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>print<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"10 threads ready to race...\n"</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>go<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> th <span class="token operator">:</span> threads<span class="token punctuation">)</span> <span class="token punctuation">{</span>        th<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、std-atomic"><a href="#四、std-atomic" class="headerlink" title="四、std::atomic"></a>四、std::atomic</h2><h3 id="1-std-atomic-flag"><a href="#1-std-atomic-flag" class="headerlink" title="1. std::atomic_flag"></a>1. std::atomic_flag</h3><p><code>std::atomic_flag</code> 一种简单的原子布尔类型，只支持两种操作，test-and-set 和 clear。</p><p><code>std::atomic_flag</code>只有默认构造函数，拷贝构造函数已被禁用，如果在初始化时没有明确使用 <strong>ATOMIC_FLAG_INIT</strong> 初始化，那么新创建的对象的状态是未指定的（既没有被 set 也没有被 clear）。</p><p><strong>ATOMIC_FLAG_INIT</strong>：如果某个 atomic_flag 对象使用该宏初始化，那么可以保证该 atomic_flag 对象在创建时处于 clear 状态。</p><h4 id="1-1-test-and-set"><a href="#1-1-test-and-set" class="headerlink" title="1.1 test_and_set()"></a>1.1 test_and_set()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">test_and_set</span><span class="token punctuation">(</span>memory_order sync <span class="token operator">=</span> memory_order_seq_cst<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该函数检查 atomic_flag 标志，如果 atomic_flag 之前没有被设置过，则设置 atomic_flag 的标志，并返回先前该 atomic_flag 对象是否被设置过，如果之前 atomic_flag 对象已被设置，则返回 true，否则返回 false。</p><h4 id="1-2-clear"><a href="#1-2-clear" class="headerlink" title="1.2 clear()"></a>1.2 clear()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span>memory_order sync <span class="token operator">=</span> memory_order_seq_cst<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>清除 atomic_flag 标志使得下一次调用 test_and_set 返回 false。</p><h4 id="1-3-示例"><a href="#1-3-示例" class="headerlink" title="1.3 示例"></a>1.3 示例</h4><p>一个简单的自旋锁使用。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>std<span class="token double-colon punctuation">::</span>atomic_flag flag <span class="token operator">=</span> ATOMIC_FLAG_INIT<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">.</span><span class="token function">test_and_set</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// acquire lock</span>            <span class="token punctuation">;</span> <span class="token comment">// spin</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Output from thread "</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>        flag<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// release lock</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span> thds<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        thds<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>func<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> thd <span class="token operator">:</span> thds<span class="token punctuation">)</span> <span class="token punctuation">{</span>        thd<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-std-atomic"><a href="#2-std-atomic" class="headerlink" title="2. std::atomic"></a>2. std::atomic<t></t></h3><p>C++11 提供了原子类型 <code>std::atomic&lt;T&gt;</code>，理论上这个 T 可以是任意类型，用原子变量就不需要使用互斥量来保护该变量，用起来更加简洁，同样拷贝构造函数被禁用。</p><h4 id="2-1-store"><a href="#2-1-store" class="headerlink" title="2.1 store()"></a>2.1 store()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">store</span><span class="token punctuation">(</span>T val<span class="token punctuation">,</span> memory_order sync <span class="token operator">=</span> memory_order_seq_cst<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改被封装的值，store 函数将类型为 T 的参数 val 复制给原子对象所封装的值。</p><h4 id="2-2-load"><a href="#2-2-load" class="headerlink" title="2.2 load()"></a>2.2 load()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T <span class="token function">load</span><span class="token punctuation">(</span>memory_order sync <span class="token operator">=</span> memory_order_seq_cst<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>读取被封装的值。</p><h4 id="2-3-exchange"><a href="#2-3-exchange" class="headerlink" title="2.3 exchange()"></a>2.3 exchange()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T <span class="token function">exchange</span><span class="token punctuation">(</span>T val<span class="token punctuation">,</span> memory_order sync <span class="token operator">=</span> memory_order_seq_cst<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>读取并修改被封装的值，exchange 会将 val 指定的值替换掉之前该原子对象封装的值，并返回之前该原子对象封装的值，整个过程是原子操作。</p><h4 id="2-4-compare-exchange-weak"><a href="#2-4-compare-exchange-weak" class="headerlink" title="2.4 compare_exchange_weak()"></a>2.4 compare_exchange_weak()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> expected<span class="token punctuation">,</span> T desired<span class="token punctuation">,</span>  memory_order sync <span class="token operator">=</span> memory_order_seq_cst<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> expected<span class="token punctuation">,</span> T desired<span class="token punctuation">,</span>    memory_order success<span class="token punctuation">,</span> memory_order failure<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>比较并交换被封装的值（weak）与参数 expected 所指定的值是否相等，如果：</p><ul><li>相等，则用 desired 替换原子对象的值，返回 true；</li><li>不相等，则用原子对象的值替换 expected，返回 false。</li></ul><p>第二个函数，内存序（Memory Order）的选择取决于比较操作结果，如果比较结果为 true（即原子对象的值等于 expected），则选择参数 success 指定的内存序，否则选择参数 failure 所指定的内存序。</p><h4 id="2-5-compare-exchange-strong"><a href="#2-5-compare-exchange-strong" class="headerlink" title="2.5 compare_exchange_strong()"></a>2.5 compare_exchange_strong()</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">compare_exchange_strong</span> <span class="token punctuation">(</span>T<span class="token operator">&amp;</span> expected<span class="token punctuation">,</span> T desired<span class="token punctuation">,</span>  memory_order sync <span class="token operator">=</span> memory_order_seq_cst<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">compare_exchange_strong</span> <span class="token punctuation">(</span>T<span class="token operator">&amp;</span> expected<span class="token punctuation">,</span> T desired<span class="token punctuation">,</span>    memory_order success<span class="token punctuation">,</span> memory_order failure<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>用法与 compare_exchange_weak 相同。</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>weak 版本的 compare-and-exchange 操作允许相同时返回 false（即原子对象所封装的值与参数 expected 相同，但仍然返回 false），不过在某些需要循环操作的算法下这是可以接受的，并且在一些平台下 compare_exchange_weak 的性能更好。</p><p>如果 compare_exchange_weak 的判断确实发生了伪失败，compare_exchange_weak 函数返回 false，并且参数 expected 的值不会改变。</p><p>对于某些不需要采用循环操作的算法而言, 通常采用 compare_exchange_strong 更好。</p><h4 id="2-6-示例"><a href="#2-6-示例" class="headerlink" title="2.6 示例"></a>2.6 示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span><span class="token comment">// 使用原子变量的计数器</span><span class="token keyword">class</span> <span class="token class-name">Counter</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">++</span>m_value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">--</span>m_value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> m_value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> m_value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-7-其他"><a href="#2-7-其他" class="headerlink" title="2.7 其他"></a>2.7 其他</h4><p>C++11 标准库中的 std::atomic 针对整形和指针类型的特化版本新增了一些算术运算和逻辑运算操作。如 <strong>fetch_add</strong>、<strong>fetch_sub</strong> 等。</p><h2 id="五、std-call-once"><a href="#五、std-call-once" class="headerlink" title="五、std::call_once"></a>五、std::call_once</h2><p>C++11 提供了<code>std::call_once</code> 来保证某一函数在多线程环境中只调用一次，比如要初始化某个对象，而这个对象只能被初始化一次，就可以使用<code>std::call_once</code>来保证函数在多线程环境中只被调用一次。</p><p>使用时，需要一个<code>std::once_flag</code>作为 call_once 的入参。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span>  <span class="token comment">// atexit</span></span><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> Singleton<span class="token operator">&amp;</span> <span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span><span class="token function">call_once</span><span class="token punctuation">(</span>flag_<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Singleton<span class="token double-colon punctuation">::</span>init<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span>value_<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call init\n"</span><span class="token punctuation">;</span>        value_ <span class="token operator">=</span> <span class="token keyword">new</span> Singleton<span class="token punctuation">;</span>        <span class="token double-colon punctuation">::</span><span class="token function">atexit</span><span class="token punctuation">(</span>destroy<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call delete\n"</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>value_ <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">delete</span> value_<span class="token punctuation">;</span>            value_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>once_flag flag_<span class="token punctuation">;</span>    <span class="token keyword">static</span> Singleton<span class="token operator">*</span> value_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>once_flag Singleton<span class="token double-colon punctuation">::</span>flag_<span class="token punctuation">;</span>Singleton<span class="token operator">*</span> Singleton<span class="token double-colon punctuation">::</span>value_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>        <span class="token class-name">Singleton</span><span class="token double-colon punctuation">::</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>thread thds<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        thds<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        thds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、thread-local"><a href="#六、thread-local" class="headerlink" title="六、thread_local"></a>六、thread_local</h2><p>C++11 引入 thread_local，用 thread_local 修饰的变量具有线程（thread）周期，这些变量在线程开始的时候被生成，在线程结束的时候被销毁，并且每一个线程都拥有一个独立的变量实例。一般用于需要保证线程安全的函数中。</p><p>如果类的成员函数内定义了 thread_local 变量，则对于同一个线程内的该类的多个对象都会共享一个变量实例，并且只会在第一次执行这个成员函数时初始化这个变量实例，这一点是跟类的静态成员变量类似的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">thread_local</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token operator">++</span>count<span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>    Foo f1<span class="token punctuation">;</span>    f1<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    f1<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    Foo f2<span class="token punctuation">;</span>    f2<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    f2<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> <span class="token string">"thread1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> <span class="token string">"thread2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左值右值(C++11)</title>
      <link href="/2020/10/15/36086.html"/>
      <url>/2020/10/15/36086.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、左值、右值"><a href="#一、左值、右值" class="headerlink" title="一、左值、右值"></a>一、左值、右值</h2><p>在 C++11 中所有的值必属于左值、将亡值、纯右值三者之一。</p><p>左值是指表达式结束后依然存在的持久化对象，右值是指表达式结束时就不再存在的临时对象。所有的具名变量或者对象都是左值，而右值不具名。区分左值和右值的方法：<strong>看能不能对表达式取地址</strong>，如果能，则为左值，否则为右值。</p><p>注意：字符串字面量(如：”hello world”)是左值。</p><p>在 C++11 中，右值分为将亡值和纯右值。</p><p><strong>纯右值</strong>：非引用返回的临时变量、运算表达式产生的临时变量、除字符串字面量之外的字面量和 lambda 表达式等。</p><p><strong>将亡值</strong>：C++11 新增的、与右值引用相关的表达式，比如，将要被移动的对象、T&amp;&amp; 函数返回值、<code>std::move</code> 返回值和转换为 T&amp;&amp; 类型的转换函数的返回值等，将亡值可以理解为即将要销毁的值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a_</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> a_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Test <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// i是左值，0是纯右值</span>    Test t1 <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// t1是左值，func() 的返回值是右值(临时变量)</span>    <span class="token keyword">auto</span> t2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// t2 是将亡值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>左值引用</strong>：对左值进行引用的类型，普通的左值引用不能接受右值。</p><p><strong>右值引用</strong>：对右值进行引用的类型，语法是 T&amp;&amp;，通过’&amp;&amp;’来表示绑定类型为 T 的右值。通过右值引用的声明，该右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样，只要该变量还活着，该右值将会一直存活下去。</p><p><strong>常量左值引用</strong>：在 C++ 中是个“万能”的引用类型，它可以接收左值、右值、常量左值和常量右值。而且在使用右值对其初始化的时候，常量左值引用还可以像右值引用一样将右值的生命期延长。</p><p>无论是声明一个左值引用还是右值引用，都<strong>必须立即进行初始化</strong>。因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量的别名，而右值引用则是不具名（匿名）变量的别名。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> num1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">&amp;</span> num2 <span class="token operator">=</span> num1<span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">&amp;</span> num3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// error: 普通的左值引用不能接受右值</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> num4 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> num5 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> num6 <span class="token operator">=</span> num5<span class="token punctuation">;</span>  <span class="token comment">// error: 右值引用是不能绑定任何左值的</span>Test test1 <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> Test<span class="token operator">&amp;</span> test2 <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、右值引用"><a href="#二、右值引用" class="headerlink" title="二、右值引用"></a>二、右值引用</h2><p>T&amp;&amp; 并不一定表示右值，有可能表示左值，也有可能表示右值，称为 universal references（未定的引用类型）。但是 T&amp;&amp; 必须被初始化，如果被右值初始化就是右值；如果被左值初始化就是左值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;type_traits&gt;</span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span>  <span class="token comment">// T 需要推导</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_lvalue_reference<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lvalue"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_rvalue_reference<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"rvalue"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// param 一定为右值引用</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">func1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// rvalue，10 是右值</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token function">func1</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// lvalue，num 是左值</span>        <span class="token function">func2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ok</span>    <span class="token function">func2</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// error: 无法将左值绑定到右值引用上</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>⭐<strong>注意</strong>：只有当发生自动类型推导时（如函数模板的类型自动推导，或 auto 关键字），&amp;&amp; 才是一个 universal references，并且 universal references 仅仅在 T&amp;&amp; 下发生，任何一点的附加条件都会使之失效，而变成一个普通的右值引用（如 func2）。</p><table>    <tbody align="center">        <tr>            <th rowspan="2">引用类型</th>            <th colspan="4">可以引用的值类型</th>            <th rowspan="2">注记</th>        </tr>        <tr>            <td>非常量左值</td>            <td>常量左值</td>            <td>非常量右值</td>            <td>常量右值</td>        </tr>        <tr>            <td>非常量左值引用</td>            <td>Y</td>            <td>N</td>            <td>N</td>            <td>N</td>            <td>无</td>        </tr>        <tr>            <td>常量左值引用</td>            <td>Y</td>            <td>Y</td>            <td>Y</td>            <td>Y</td>            <td>全能类型，可用于拷贝语义</td>        </tr>        <tr>            <td>非常量右值引用</td>            <td>N</td>            <td>N</td>            <td>Y</td>            <td>N</td>            <td>用于移动语义，完美转发</td>        </tr>        <tr>            <td>常量右值引用</td>            <td>N</td>            <td>N</td>            <td>Y</td>            <td>Y</td>            <td>暂无用途</td>        </tr>    </tbody></table><p>标准库 <code>&lt;type_traits&gt;</code> 头文件中提供了3个模板类：<code>std::is_reference</code>、<code>std::is_rvalue_reference</code>、<code>std::is_lvalue_reference</code>，可判断一个类型是否是引用类型，以及是左值引用还是右值引用。</p><p>对于 T&amp;&amp; 这种变化被称为引用折叠。C++11 中的折叠引用规则如下：</p><ul><li><strong>所有的右值引用叠加到右值引用上还是一个右值引用</strong>；</li><li><strong>所有的其他引用类型之间的叠加都变成左值引用</strong>。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">void</span> <span class="token function">reference</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lvalue"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">reference</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;&amp;</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"rvalue"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">forward_t</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;&amp;</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">reference</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>string str1 <span class="token operator">=</span> <span class="token string">"string"</span><span class="token punctuation">;</span>  <span class="token comment">// str1 是一个左值</span>    <span class="token function">reference</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// lvalue</span>    <span class="token function">reference</span><span class="token punctuation">(</span><span class="token string">"string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// rvalue</span>    <span class="token function">forward_t</span><span class="token punctuation">(</span><span class="token string">"string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// lvalue, forward_t 函数接收的是一个右值，但是在转发给 reference 时又变成了左值。</span>                          <span class="token comment">// 因为在 forward_t 中调用 reference 时，右值 str 变成了一个命名的对象，编译器会将其当作左值处理。</span>        std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;&amp;</span> str2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ok, std::move 可以将左值转移为右值</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"str2 = "</span> <span class="token operator">&lt;&lt;</span> str2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// string</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"str1 = "</span> <span class="token operator">&lt;&lt;</span> str1 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// string, 并没有将 str1 的值转移</span>    <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str3 <span class="token operator">=</span> str1 <span class="token operator">+</span> str1<span class="token punctuation">;</span>  <span class="token comment">// ok, 常量左值引用能够延长临时变量的生命周期(字面值)</span>    <span class="token comment">// str3 += "Test";  // 非法, const 无法被修改</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"str3 = "</span> <span class="token operator">&lt;&lt;</span> str3 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// stringstring</span>    std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;&amp;</span> str4 <span class="token operator">=</span> str1 <span class="token operator">+</span> str3<span class="token punctuation">;</span>  <span class="token comment">// ok, 右值引用延长临时对象的生命周期</span>    str4 <span class="token operator">+=</span> <span class="token string">"string"</span><span class="token punctuation">;</span>  <span class="token comment">// ok, 非常量引用能够修改临时变量</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"str4 = "</span> <span class="token operator">&lt;&lt;</span> str4 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// stringstringstringstring</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> vec<span class="token punctuation">;</span>    vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// str1 的值转移, str2 的值也没有了</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> str1 <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> str2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// ' '</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&amp;&amp; 的总结如下：</p><ul><li>左值和右值是独立于它们的类型的，右值引用类型可能是左值也可能是右值；</li><li>auto&amp;&amp; 或函数参数类型自动推导的 T&amp;&amp; 是一个未定的引用类型，被称为 universal references，它可能是左值引用也可能是右值引用类型，取决于初始化的值类型；</li><li>所有的右值引用叠加到右值引用上仍然是一个右值引用，其他引用折叠都为左值引用。当 T&amp;&amp; 为模板参数时，输入左值，它会变成左值引用，而输入右值时则变为具名的右值引用；</li><li>编译器会将已命名的右值引用视为左值，而将未命名的右值引用视为右值。</li></ul><h2 id="三、优化性能"><a href="#三、优化性能" class="headerlink" title="三、优化性能"></a>三、优化性能</h2><p>引入右值解决两个问题，第一个问题是<strong>临时对象非必要的昂贵的拷贝操作</strong>，第二个问题是<strong>在模板函数中如何按照参数的实际类型进行转发。</strong></p><p>C++ 中引入右值引用和移动语义，可以避免无谓的复制，提高程序性能。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"construct:"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">++</span>s_construct_count <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"destruct:"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">++</span>s_destruct_count <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"copy construct:"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">++</span>s_copy_count <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">uint32_t</span> s_construct_count<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">uint32_t</span> s_destruct_count<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">uint32_t</span> s_copy_count<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">uint32_t</span> Test<span class="token double-colon punctuation">::</span>s_construct_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">uint32_t</span> Test<span class="token double-colon punctuation">::</span>s_destruct_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">uint32_t</span> Test<span class="token double-colon punctuation">::</span>s_copy_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>Test <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Test t <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 GCC 使用编译参数 -fno-elide-constructors 关闭返回值优化，会有以下输出结果：</p><p><img src="/pic/36086_001.jpg"></p><p>从结果中可以看到，拷贝构造函数调用了两次，一次是 func() 函数内部创建的对象返回出来构造一个临时对象产生的，另一次是在 main 函数中构造 t 对象产生的。第二次的 destruct 是因为临时对象在构造 t 对象之后就销毁了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Test<span class="token operator">&amp;&amp;</span> t <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>func() 返回的右值本应该在表达式语句结束后，其生命也就结束了（因为是临时变量），而通过右值引用，该右值又重获新生，其生命期将与右值引用类型变量 t 的生命期一样，只要 t 还活着，该右值临时变量将会一直存活下去。</p><p><img src="/pic/36086_002.jpg"></p><p>通过右值引用，比之前少了一次拷贝构造和一次析构，原因在于右值引用绑定了右值，让临时右值的生命周期延长了。可以利用这个特点做一些性能优化，即避免临时对象的拷贝构造和析构，事实上，在 C++98/03 中，通过常量左值引用也经常用来做性能优化。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> Test<span class="token operator">&amp;</span> t <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="四、移动语义⭐"><a href="#四、移动语义⭐" class="headerlink" title="四、移动语义⭐"></a>四、移动语义⭐</h2><p>C++11 中可以将左值强制转换为右值，从而避免对象的拷贝来提升性能。move 将对象的状态或者所有权从一个对象转移到另一个对象，没有内存拷贝。深拷贝和 move 的区别如图：</p><p><img src="/./pic/36086_003.jpg"></p><p>从图可以看出，深拷贝会有两份内存，而 move 只有一份，move 只是将内存的所有者切换为目标对象，并没有拷贝任何东西。</p><p>在 C++11 之前的拷贝构造函数和赋值函数要有如下定义：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 赋值函数</span>T<span class="token operator">&amp;</span> T<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 销毁内部资源</span>    <span class="token comment">// 复制rhs资源到自身</span><span class="token punctuation">}</span>T <span class="token function">getT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 假如 getT 是返回一个 T 类型的函数</span>T t<span class="token punctuation">;</span>t <span class="token operator">=</span> <span class="token function">getT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>t = getT() 将有如下动作：</p><ol><li>销毁 t 的资源；</li><li>赋值 getT 返回的临时对象的资源；</li><li>销毁临时对象，释放其资源。</li></ol><p>其实可以优化的是，将 t 和临时对象的资源指针做交换，让临时对象去销毁 t 原来拥有的资源，t 拥有临时对象的资源指针。那么赋值操作函数就该这么写：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T<span class="token operator">&amp;</span> T<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 转移资源的控制权，无需复制</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-移动构造函数和移动赋值操作符"><a href="#1-移动构造函数和移动赋值操作符" class="headerlink" title="1. 移动构造函数和移动赋值操作符"></a>1. 移动构造函数和移动赋值操作符</h3><p><strong>C++11 提供了移动构造函数和移动赋值操作符，用于支持移动语义。</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">// 拷贝 rhs.str 的内容到 this.str 中, 需要深拷贝</span>        str_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>rhs<span class="token punctuation">.</span>size_<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>str_<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>str_<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>size_<span class="token punctuation">)</span><span class="token punctuation">;</span>        size_ <span class="token operator">=</span> rhs<span class="token punctuation">.</span>size_<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 移动构造函数</span>    <span class="token function">Test</span><span class="token punctuation">(</span>Test<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">// 夺取 rhs.str 的资源，并将 rhs.str 置空, 无需深拷贝</span>        str_ <span class="token operator">=</span> rhs<span class="token punctuation">.</span>str_<span class="token punctuation">;</span>        size_ <span class="token operator">=</span> rhs<span class="token punctuation">.</span>size_<span class="token punctuation">;</span>        rhs<span class="token punctuation">.</span>str_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        rhs<span class="token punctuation">.</span>size_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Test<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">// 释放 str</span>        <span class="token comment">// 拷贝 rhs.str 的内容到 this.str 中, 需要深拷贝</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str_ <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str_<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        str_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>rhs<span class="token punctuation">.</span>size_<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>str_<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>str_<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>size_<span class="token punctuation">)</span><span class="token punctuation">;</span>        size_ <span class="token operator">=</span> rhs<span class="token punctuation">.</span>size_<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 移动赋值操作符</span>    Test<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Test<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">// 释放 str</span>        <span class="token comment">// 夺取 rhs.str 的资源，并将 rhs.str 置空, 无需深拷贝</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str_ <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str_<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        str_ <span class="token operator">=</span> rhs<span class="token punctuation">.</span>str_<span class="token punctuation">;</span>        size_ <span class="token operator">=</span> rhs<span class="token punctuation">.</span>size_<span class="token punctuation">;</span>        rhs<span class="token punctuation">.</span>str_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        rhs<span class="token punctuation">.</span>size_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">char</span><span class="token operator">*</span> str_<span class="token punctuation">{</span> <span class="token keyword">nullptr</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    size_t size_<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假如一个临时容器很大，要赋值给另一个容器。如果不用 move，拷贝的代价很大，性能较低，使用 move 几乎没有代价，只转换了资源的所有权。当然，<strong>当一个左值被 move 之后，不再对之前的内存拥有控制权，会被置为一个空对象。</strong></p><p><strong>注意</strong>：在提供移动构造函数的同时也会提供一个拷贝构造函数，以防止移动不成功的时候还能拷贝构造，使代码更安全。</p><h3 id="2-std-move"><a href="#2-std-move" class="headerlink" title="2. std::move"></a>2. std::move</h3><p>在 C++11 中，标准库 <code>&lt;utility&gt;</code> 中提供了 <code>std::move</code>，<strong>该函数并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用</strong>，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，<code>std::move</code> 基本等同于一个类型转换：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>lvalue<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意</strong>：被转化的左值，其生命期并没有随着左右值的转化而改变。</p><p>使用移动语义的前提是：<strong>类需要添加一个以右值引用为参数的移动构造函数和移动赋值操作符</strong>，若没有声明该函数，将调用以常量左值引用为参数的拷贝构造函数。这是一种非常安全的设计：移动不成，至少还可以拷贝。</p><p>标准库 <code>&lt;type_traits&gt;</code> 头文件中提供了模板类，来判断一个类型是否是可以移动。如：<code>std::is_move_constructible</code>、<code>std::is_trivially_move_constructible</code>、<code>std::is_nothrow_move_constructible</code>。</p><h3 id="3-NRVO"><a href="#3-NRVO" class="headerlink" title="3. NRVO"></a>3. NRVO</h3><p>编译器一般会对返回值进行优化(NRVO)，但是在没有返回值优化的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。而使用 <code>std::move</code> 对于移动行为没有帮助，反而会影响返回值优化。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Test()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test<span class="token operator">&amp;</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Test(const Test&amp;)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">Test</span><span class="token punctuation">(</span>Test<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Test(Test&amp;&amp;)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Test <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Test t<span class="token punctuation">;</span>    <span class="token comment">// 一般会 NRVO</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span>Test <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Test t<span class="token punctuation">;</span>    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Test <span class="token function">test3</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    Test t1<span class="token punctuation">;</span>    Test t2<span class="token punctuation">;</span>    <span class="token comment">// 有分支，一般无 NRVO</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> t1<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> t2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"----test_with_nrvo\n"</span><span class="token punctuation">;</span>    Test t1 <span class="token operator">=</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n----test_with_move\n"</span><span class="token punctuation">;</span>    Test t2 <span class="token operator">=</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n----test_no_nrvo\n"</span><span class="token punctuation">;</span>    Test t3 <span class="token operator">=</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/pic/36086_004.png"></p><h2 id="五、完美转发⭐"><a href="#五、完美转发⭐" class="headerlink" title="五、完美转发⭐"></a>五、完美转发⭐</h2><p>指在函数模板中，完全依照模板的参数类型（即保持参数的左值、右值特性），将参数传递给函数模板中调用的另外一个函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"rvalue"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lvalue"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">forward_t</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">test</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">forward_t</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// lvalue，5 在此时是右值，在 test 调用的时候就是左值</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++11 提供了 <strong>std::forward</strong>，将参数传递给函数中调用的另一个函数，按照参数原本的类型转发。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"rvalue ref\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lvalue ref\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"const rvalue ref\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"const lvalue ref\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token function">forward_t</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">test</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">{</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> b<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> c<span class="token punctuation">{</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> d<span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">forward_t</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// lvalue ref</span>    <span class="token function">forward_t</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// rvalue ref</span>    <span class="token function">forward_t</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// const lvalue ref</span>    <span class="token function">forward_t</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// const rvalue ref</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针(C++11)</title>
      <link href="/2020/10/14/14371.html"/>
      <url>/2020/10/14/14371.html</url>
      
        <content type="html"><![CDATA[<p>C++11 引入了三种智能指针：</p><ul><li><code>std::shared_ptr</code></li><li><code>std::weak_ptr</code></li><li><code>std::unique_ptr</code></li></ul><h2 id="一、std-shared-ptr"><a href="#一、std-shared-ptr" class="headerlink" title="一、std::shared_ptr"></a>一、std::shared_ptr</h2><p><code>std::shared_ptr</code> 使用引用计数，每个 <code>std::shared_ptr</code> 的拷贝都指向相同的内存，在最后一个 <code>std::shared_ptr</code> 析构的时候，内存才会释放。</p><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h3><ul><li>通过 <code>std::make_shared&lt;T&gt;()</code>；</li><li>直接构造 <code>std::shared_ptr</code>；</li><li>调用 <code>reset()</code> 方法初始化。</li></ul><p>智能指针的用法和普通指针类似，不过不需要自己管理分配的内存，对于没有初始化的智能指针，只能通过 <code>reset()</code> 来初始化；当智能指针有值时，<code>reset()</code> 会使计数器减 1。</p><p>注意：<strong>智能指针不能通过原始指针来初始化</strong>。</p><p>优先使用 <code>std::make_shared</code> 来构造智能指针，更高效。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 1. 使用 std::make_shared&lt;T&gt;()</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2. 直接构造</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p3 <span class="token operator">=</span> p2<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p4<span class="token punctuation">;</span>    <span class="token comment">// 3. 使用 reset() 方法</span>    p4<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p4<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"p4:"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p4 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// error: 无法使用原始指针直接初始化</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译报错，不能直接赋值</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-成员方法"><a href="#2-成员方法" class="headerlink" title="2. 成员方法"></a>2. 成员方法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当需要获取原始指针的时候，可以通过 <code>get()</code> 方法来获取原始指针。注意：<strong>不能释放，如果释放会出错。</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该方法获得当前资源的引用计数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> ptr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token comment">// 会导致 ptr 释放时异常，即二次释放</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p3 <span class="token operator">=</span> p2<span class="token punctuation">;</span>p3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-指定删除器"><a href="#3-指定删除器" class="headerlink" title="3. 指定删除器"></a>3. 指定删除器</h3><p>智能指针支持指定删除器，即在指针引用为 0 的时候自动调用，支持普通函数和 lambda 表达式。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span><span class="token keyword">void</span> <span class="token function">delete_ptr</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">delete</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> delete_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当智能指针管理动态数组的时候，需要指定删除器，<strong>默认的删除器不支持数组对象</strong>。自定义删除器或者使用改善的默认修改器都可以。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// lambda</span><span class="token comment">// std::default_delete 为默认删除器，内部通过调用 delete 实现。</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">default_delete</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 指定 delete[]</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">make_shared_array</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> T<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">default_delete</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h3><ul><li>避免用一个原始指针初始化多个 <code>std::shared_ptr</code>，否则会出现 double free，导致程序崩溃；</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p1</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p2</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>通过 <code>shared_from_this()</code> 返回 this 指针。不要将 this 指针作为 <code>std::shared_ptr</code> 返回出来，因为 this 指针本质是一个裸指针，这样可能导致重复析构。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">TestA</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>TestA<span class="token operator">&gt;</span> <span class="token function">get_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>TestA<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">TestA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestA is deleted."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>TestA<span class="token operator">&gt;</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> TestA<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>TestA<span class="token operator">&gt;</span> p2 <span class="token operator">=</span> p1<span class="token operator">-&gt;</span><span class="token function">get_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 输出</span><span class="token comment">// TestA is deleted.</span><span class="token comment">// TestA is deleted.</span><span class="token comment">// 崩溃</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决办法：让目标类派生自 <code>std::enable_shared_from_this&lt;T&gt;</code> 类，然后使用基类的成员函数 <code>shared_from_this</code> 来返回 this 的 <code>std::shared_ptr</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TestA</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">enable_shared_from_this</span><span class="token operator">&lt;</span><span class="token class-name">TestA</span><span class="token operator">&gt;</span></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>TestA<span class="token operator">&gt;</span> <span class="token function">get_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">TestA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestA is deleted."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>避免循环使用，循环使用可能导致内存泄漏</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">TestB</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">TestA</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>TestB<span class="token operator">&gt;</span> bptr_<span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">TestA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestA is deleted."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">TestB</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>TestA<span class="token operator">&gt;</span> aptr_<span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">TestB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestB is deleted."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>TestA<span class="token operator">&gt;</span> <span class="token function">pa</span><span class="token punctuation">(</span><span class="token keyword">new</span> TestA<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>TestB<span class="token operator">&gt;</span> <span class="token function">pb</span><span class="token punctuation">(</span><span class="token keyword">new</span> TestB<span class="token punctuation">)</span><span class="token punctuation">;</span>    pa<span class="token operator">-&gt;</span>bptr_ <span class="token operator">=</span> pb<span class="token punctuation">;</span>    pb<span class="token operator">-&gt;</span>aptr_ <span class="token operator">=</span> pa<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序结果是两个指针 pa 和 pb 都不会删除，存在内存泄漏。循环引用导致 pa 和 pb 的引用计数为 2，离开作用域之后，pa 和 pb 的引用计数为 1，并不会减为 0，导致两个指针都不会析构而产生内存泄漏，解决方法是使用 <code>std::weak_ptr</code>。</p><ul><li>不要在参数中创建 <code>std::shared_ptr</code>，不同的编译器可能有不同的调用约定，如果先 <code>new int</code>，然后调用 func1，在 func1 过程中发生异常，但是 <code>std::shared_ptr</code> 没有创建，那么会导致内存泄漏。应该先创建智能指针。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">func</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>尽量使用 <code>std::make_shared</code>，少用 new；</li><li>不要删除 get() 返回的原始指针；</li><li>不是 new 出来的空间要自定义删除器。</li></ul><h2 id="二、std-unique-ptr"><a href="#二、std-unique-ptr" class="headerlink" title="二、std::unique_ptr"></a>二、std::unique_ptr</h2><p><code>std::unique_ptr</code> 是一个独占型智能指针，它不允许其他的智能指针共享其内部的指针，不允许复制，支持移动，通过 <code>std::move()</code> 来转移到其他的 <code>std::unique_ptr</code>，但是转移之后，它本身不再拥有原来指针的所有权。</p><h3 id="1-初始化-1"><a href="#1-初始化-1" class="headerlink" title="1. 初始化"></a>1. 初始化</h3><p><code>std::unique_ptr</code> 没有 <code>std::make_unique()</code> 辅助函数来创建对象。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>  <span class="token comment">// error</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p3 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// p1 将变为 nullptr</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p4<span class="token punctuation">;</span>p4<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-release-方法"><a href="#2-release-方法" class="headerlink" title="2. release 方法"></a>2. release 方法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pointer <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该方法释放管理对象的所有权，并返回指向该对象的指针。调用 <code>release</code> 后，<code>std::unique_ptr</code> 将不再管理该对象，<code>get()</code> 方法将返回 nullptr，<strong>调用者需要负责释放该对象</strong>。</p><h3 id="3-数组"><a href="#3-数组" class="headerlink" title="3. 数组"></a>3. 数组</h3><p><code>std::unique_ptr</code> 除了独占之外，还可以指向数组。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ok</span>p1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-指定删除器"><a href="#4-指定删除器" class="headerlink" title="4. 指定删除器"></a>4. 指定删除器</h3><p><code>std::unique_ptr</code> 必须指定删除器类型。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ok</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// error</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">p3</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ok</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>指定函数类型，然后通过 lambda 表达式是可以，但是如果捕获了变量将会编译报错，因为 lambda 表达式在没有捕获变量的情况下可以直接转换为函数指针，但是捕获了变量就无法转换。如果要支持，可以通过 <code>std::function</code> 来解决。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// error</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ok</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同样也支持自定义删除器。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">DeletePtr</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>        <span class="token keyword">delete</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> DeletePtr<span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、std-weak-ptr"><a href="#三、std-weak-ptr" class="headerlink" title="三、std::weak_ptr"></a>三、std::weak_ptr</h2><p>弱引用智能指针 <code>std::weak_ptr</code> 用来监视 <code>std::shared_ptr</code>，其不会使引用计数加 1，也不管理 <code>std::shared_ptr</code> 内部的指针，主要是监视 <code>std::shared_ptr</code> 的生命周期。<code>std::weak_ptr</code> 不共享指针，不能操作资源，它的构造和析构都不会改变引用计数。</p><p>使用 <code>std::shared_ptr</code> 来初始化 <code>std::weak_ptr</code>。</p><h3 id="1-观测引用计数"><a href="#1-观测引用计数" class="headerlink" title="1. 观测引用计数"></a>1. 观测引用计数</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该方法获得当前资源的引用计数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">wp</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> wp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出 1</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sp1</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>wp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-监视-std-shared-ptr-是否有效"><a href="#2-监视-std-shared-ptr-是否有效" class="headerlink" title="2. 监视 std::shared_ptr 是否有效"></a>2. 监视 std::shared_ptr 是否有效</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该方法判断所观察的资源是否已被释放，返回 true 表示指针已失效。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">wp</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>wp<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// false, 指针有效</span>sp<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>wp<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true，指针失效</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-获取"><a href="#3-获取" class="headerlink" title="3. 获取"></a>3. 获取</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该方法获取所监视的 <code>std::shared_ptr</code>，如果当前 <code>std::weak_ptr</code> 已经过期，则该函数会返回一个空的 <code>std::shared_ptr</code> 指针。</p><p>⭐<strong>注意：<code>lock()</code> 方法是原子操作。</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> wptr<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 监听是否释放</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>wptr<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr 已经释放"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">auto</span> sp <span class="token operator">=</span> wptr<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">{</span>        <span class="token keyword">auto</span> sptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        wptr <span class="token operator">=</span> sptr<span class="token punctuation">;</span>        <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出：20</span>    <span class="token punctuation">}</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出：ptr 已经释放</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-返回-this-指针"><a href="#4-返回-this-指针" class="headerlink" title="4. 返回 this 指针"></a>4. 返回 this 指针</h3><p><code>std::shared_ptr</code> 不能直接返回 this 指针，需要通过派生 <code>std::enable_shared_from_this</code> 类，并通过其方法 <code>shared_from_this()</code> 来返回智能指针，因为 <code>std::enable_shared_from_this</code> 类中有一个 <code>std::weak_ptr</code>，这个 <code>std::weak_ptr</code> 用来观测 this 指针，调用 <code>shared_from_this()</code> 方法时，调用了内部的 <code>std::weak_ptr</code> 的 <code>lock()</code> 方法，将所观测的 <code>std::sharerd_ptr</code> 返回。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">TestA</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">enable_shared_from_this</span><span class="token operator">&lt;</span><span class="token class-name">TestA</span><span class="token operator">&gt;</span></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>TestA<span class="token operator">&gt;</span> <span class="token function">get_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">TestA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestA is deleted."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>TestA<span class="token operator">&gt;</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> TestA<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>TestA<span class="token operator">&gt;</span> p2 <span class="token operator">=</span> p1<span class="token operator">-&gt;</span><span class="token function">get_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//ok</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 输出： </span><span class="token comment">// TestA is deleted.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-解决循环引用问题"><a href="#5-解决循环引用问题" class="headerlink" title="5. 解决循环引用问题"></a>5. 解决循环引用问题</h3><p><code>std::shared_ptr</code> 的循环引用可能导致内存泄漏，通过 <code>std::weak_ptr</code> 可以解决这个问题，将 TestA 或者 TestB 任意一个成员变量改为 <code>std::weak_ptr</code> 即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">TestB</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">TestA</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>TestB<span class="token operator">&gt;</span> bptr_<span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">TestA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestA is deleted."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">TestB</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span>TestA<span class="token operator">&gt;</span> aptr_<span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">TestB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestB is deleted."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>TestA<span class="token operator">&gt;</span> <span class="token function">pa</span><span class="token punctuation">(</span><span class="token keyword">new</span> TestA<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>TestB<span class="token operator">&gt;</span> <span class="token function">pb</span><span class="token punctuation">(</span><span class="token keyword">new</span> TestB<span class="token punctuation">)</span><span class="token punctuation">;</span>    pa<span class="token operator">-&gt;</span>bptr_ <span class="token operator">=</span> pb<span class="token punctuation">;</span>    pb<span class="token operator">-&gt;</span>aptr_ <span class="token operator">=</span> pa<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 输出：</span><span class="token comment">// TestA is deleted.</span><span class="token comment">// TestB is deleted.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、标准库中-std-shared-ptr-的实现"><a href="#四、标准库中-std-shared-ptr-的实现" class="headerlink" title="四、标准库中 std::shared_ptr 的实现"></a>四、标准库中 std::shared_ptr 的实现</h2><p><code>std::shared_ptr</code> 内部是使用引用计数来记录托管指针被引用的次数，当托管指针的引用计数为 0 时，会释放托管的内存，通过 gcc 源码探究 <code>std::shared_ptr</code> 内部究竟是如何实现内存引用计数功能。</p><p>类图如下：</p><p><img src="/%5Cpic%5C14371_001.jpg" alt="shared_ptr"></p><p>shared_ptr 类几乎什么都没有做，继承 __shared_ptr，其内部有一个类型为 __shared_count 的成员，__shared_count 类内部有类型为 _Sp_counted_base 的 _M_pi 的成员，_Sp_counted_base 才是整个 shared_ptr 功能的核心，通过 _Sp_counted_base 控制引用计数来管理内存，由图可见 _Sp_counted_base 内部不持有托管内存的指针。</p><p>__shared_count 内部的 _M_pi 成员其实是一个继承自 _Sp_counted_base 的 _Sp_counted_ptr 类型，_Sp_counted_ptr 类型内部持有托管内存的指针 _M_ptr，_M_pi 是一个 _Sp_counted_base 基类对象指针，指向 _Sp_counted_ptr 子类对象内存，这样 _M_pi 内部就既可以控制引用计数，又可以在最后释放托管内存。</p><p><strong>这里称 _M_pi 为管理对象，其内部的 _M_ptr 为托管对象</strong>。管理对象内部有两个成员变量 _M_use_count 和 _M_weak_count。<strong>_M_use_count 表示托管对象的引用计数</strong>，控制托管对象什么时候析构和释放。假如有 N 个 shared_ptr 的拷贝，那引用计数就是 N，当引用计数为 0 时调用托管对象的析构函数并释放内存。<strong>_M_weak_count 表示管理对象的引用计数</strong>，管理对象也是一个内存指针，<strong>该指针是创建第一个 shared_ptr 时 new 出来的</strong>，到最后也需要释放，所以使用 _M_weak_count 来控制管理对象什么时候析构，平时用到的 weak_ptr 内部其实持有的就是这个管理对象的指针，当 weak_ptr 拷贝时，管理对象的引用计数 _M_weak_count 就会增加，当 _M_weak_count 为 0 时，管理对象 _M_pi 就会析构且释放内存。</p><h3 id="1-M-use-count-的加减"><a href="#1-M-use-count-的加减" class="headerlink" title="1. _M_use_count 的加减"></a>1. _M_use_count 的加减</h3><p>_M_use_count 表示托管对象的引用计数，即当 shared_ptr 拷贝时增加，当 shared_ptr 析构时减少：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// shared_ptr 的拷贝构造函数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_Yp</span><span class="token operator">&gt;</span><span class="token function">__shared_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> __shared_ptr<span class="token operator">&lt;</span>_Yp<span class="token punctuation">,</span> _Lp<span class="token operator">&gt;</span><span class="token operator">&amp;</span> __r<span class="token punctuation">,</span> element_type<span class="token operator">*</span> __p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token operator">:</span> <span class="token function">_M_ptr</span><span class="token punctuation">(</span>__p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_refcount</span><span class="token punctuation">(</span>__r<span class="token punctuation">.</span>_M_refcount<span class="token punctuation">)</span> <span class="token comment">// never throws</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_Yp</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> _Compatible<span class="token operator">&lt;</span>_Yp<span class="token operator">&gt;&gt;</span><span class="token function">__shared_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> __shared_ptr<span class="token operator">&lt;</span>_Yp<span class="token punctuation">,</span> _Lp<span class="token operator">&gt;</span><span class="token operator">&amp;</span> __r<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token operator">:</span> <span class="token function">_M_ptr</span><span class="token punctuation">(</span>__r<span class="token punctuation">.</span>_M_ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_refcount</span><span class="token punctuation">(</span>__r<span class="token punctuation">.</span>_M_refcount<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// __shared_count 的拷贝构造函数</span><span class="token function">__shared_count</span><span class="token punctuation">(</span><span class="token keyword">const</span> __shared_count<span class="token operator">&amp;</span> __r<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token operator">:</span> <span class="token function">_M_pi</span><span class="token punctuation">(</span>__r<span class="token punctuation">.</span>_M_pi<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_M_pi <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        _M_pi<span class="token operator">-&gt;</span><span class="token function">_M_add_ref_copy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使引用计数加 1</span><span class="token punctuation">}</span><span class="token comment">// 增加引用计数</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">_Sp_counted_base</span><span class="token operator">&lt;</span>_S_single<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">_M_add_ref_copy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">++</span>_M_use_count<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>shared_ptr 的赋值操作符：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// shared_ptr 的赋值操作符</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_Yp</span><span class="token operator">&gt;</span>_Assignable<span class="token operator">&lt;</span><span class="token keyword">const</span> shared_ptr<span class="token operator">&lt;</span>_Yp<span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> shared_ptr<span class="token operator">&lt;</span>_Yp<span class="token operator">&gt;</span><span class="token operator">&amp;</span> __r<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token operator">-&gt;</span>__shared_ptr<span class="token operator">&lt;</span>_Tp<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>__r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// __shared_ptr 的赋值操作符</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_Yp</span><span class="token operator">&gt;</span>_Assignable<span class="token operator">&lt;</span>_Yp<span class="token operator">&gt;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> __shared_ptr<span class="token operator">&lt;</span>_Yp<span class="token punctuation">,</span> _Lp<span class="token operator">&gt;</span><span class="token operator">&amp;</span> __r<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span>    _M_ptr <span class="token operator">=</span> __r<span class="token punctuation">.</span>_M_ptr<span class="token punctuation">;</span>    _M_refcount <span class="token operator">=</span> __r<span class="token punctuation">.</span>_M_refcount<span class="token punctuation">;</span> <span class="token comment">// __shared_count::op= doesn't throw</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// __shared_count 的赋值操作符</span>__shared_count<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> __shared_count<span class="token operator">&amp;</span> __r<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span>    _Sp_counted_base<span class="token operator">&lt;</span>_Lp<span class="token operator">&gt;</span><span class="token operator">*</span> __tmp <span class="token operator">=</span> __r<span class="token punctuation">.</span>_M_pi<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>__tmp <span class="token operator">!=</span> _M_pi<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>__tmp <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            __tmp<span class="token operator">-&gt;</span><span class="token function">_M_add_ref_copy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 增加新托管对象的引用计数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>_M_pi <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            _M_pi<span class="token operator">-&gt;</span><span class="token function">_M_release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 减少原有托管对象的引用计数</span>        _M_pi <span class="token operator">=</span> __tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>shared_ptr 析构时会调用 _shared_count 的析构函数，进而减少 _M_use_count 的计数，当减为 0 时，释放内存：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">~</span><span class="token function">__shared_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><span class="token operator">~</span><span class="token function">__shared_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_M_pi <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        _M_pi<span class="token operator">-&gt;</span><span class="token function">_M_release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 减少引用计数</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">_Sp_counted_base</span><span class="token operator">&lt;</span>_S_single<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">_M_release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>_M_use_count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">_M_dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 为0，释放托管对象</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>_M_weak_count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">_M_destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 为0，释放管理对象</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> _Sp_counted_ptr<span class="token double-colon punctuation">::</span><span class="token function">_M_dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span>    <span class="token keyword">delete</span> _M_ptr<span class="token punctuation">;</span>  <span class="token comment">// 释放托管对象</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 shared_ptr 生命周期结束，析构时会将引用计数减 1，如果引用计数为 0，会调用 _M_dispose() 函数进而释放托管对象内存。</p><h3 id="2-M-weak-count-的加减"><a href="#2-M-weak-count-的加减" class="headerlink" title="2. _M_weak_count 的加减"></a>2. _M_weak_count 的加减</h3><p>上面的代码中可以看出 <code>--_M_weak_count == 0</code> 时，会调用 _M_destroy() 函数。</p><p>管理对象初始化时 _M_weak_count 的初始值为 1。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">_Sp_counted_base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>     <span class="token operator">:</span> <span class="token function">_M_use_count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_weak_count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意：<strong>当 shared_ptr 拷贝或者移动时， _M_weak_count 是不会增加的</strong>，它表示的是管理对象的计数，只有当 _M_use_count 为 0 时， _M_weak_count 才会减 1，除此之外 _M_weak_count 的数值是由 weak_ptr 控制的。</p><p>从类图可以看出 weak_ptr 内部其实和 shared_ptr 内部持有的是同一个管理对象指针，即 _Sp_counted_base 的指针，当 weak_ptr 拷贝、析构时，_Sp_counted_base 内部的 _M_weak_count 会相应加减。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 拷贝构造</span><span class="token function">__weak_count</span><span class="token punctuation">(</span><span class="token keyword">const</span> __shared_count<span class="token operator">&lt;</span>_Lp<span class="token operator">&gt;</span><span class="token operator">&amp;</span> __r<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token operator">:</span> <span class="token function">_M_pi</span><span class="token punctuation">(</span>__r<span class="token punctuation">.</span>_M_pi<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_M_pi <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        _M_pi<span class="token operator">-&gt;</span><span class="token function">_M_weak_add_ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">_Sp_counted_base</span><span class="token operator">&lt;</span>_S_single<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">_M_weak_add_ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span>    <span class="token operator">++</span>_M_weak_count<span class="token punctuation">;</span>  <span class="token comment">// 增加管理对象引用计数</span><span class="token punctuation">}</span><span class="token comment">// 析构函数</span><span class="token operator">~</span><span class="token function">__weak_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_M_pi <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        _M_pi<span class="token operator">-&gt;</span><span class="token function">_M_weak_release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 减少管理对象引用计数</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">_Sp_counted_base</span><span class="token operator">&lt;</span>_S_single<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">_M_weak_release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>_M_weak_count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">_M_destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 为0，释放管理对象</span><span class="token punctuation">}</span><span class="token keyword">virtual</span> <span class="token keyword">void</span> _Sp_counted_base<span class="token double-colon punctuation">::</span><span class="token function">_M_destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span>    <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>weak_ptr 拷贝时 _M_weak_count 加 1，析构时 _M_weak_count 减 1，当 _M_weak_count 为 0 时，表示不再需要管理对象来控制托管对象，调用 _M_destroy() 的 delete this 来释放管理对象内存。</p><h3 id="3-weak-ptr-的-expired-和-lock"><a href="#3-weak-ptr-的-expired-和-lock" class="headerlink" title="3. weak_ptr 的 expired() 和 lock()"></a>3. weak_ptr 的 expired() 和 lock()</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> __weak_ptr<span class="token double-colon punctuation">::</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> _M_refcount<span class="token punctuation">.</span><span class="token function">_M_get_use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 标准规定该操作为原子操作</span>__shared_ptr<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Lp<span class="token operator">&gt;</span> __weak_ptr<span class="token double-colon punctuation">::</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">__shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>element_type<span class="token punctuation">,</span> _Lp<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>nothrow<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">__shared_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> __weak_ptr<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Lp<span class="token operator">&gt;</span><span class="token operator">&amp;</span> __r<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>nothrow_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token operator">:</span> <span class="token function">_M_refcount</span><span class="token punctuation">(</span>__r<span class="token punctuation">.</span>_M_refcount<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>nothrow<span class="token punctuation">)</span><span class="token punctuation">{</span>    _M_ptr <span class="token operator">=</span> _M_refcount<span class="token punctuation">.</span><span class="token function">_M_get_use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> __r<span class="token punctuation">.</span>_M_ptr <span class="token operator">:</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-shared-from-this"><a href="#4-shared-from-this" class="headerlink" title="4. shared_from_this()"></a>4. shared_from_this()</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_Tp</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">enable_shared_from_this</span><span class="token punctuation">{</span>    shared_ptr<span class="token operator">&lt;</span>_Tp<span class="token operator">&gt;</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>_Tp<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-&gt;</span>_M_weak_this<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">const</span> _Tp<span class="token operator">&gt;</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> _Tp<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-&gt;</span>_M_weak_this<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">mutable</span> weak_ptr<span class="token operator">&lt;</span>_Tp<span class="token operator">&gt;</span> _M_weak_this<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 shared_from_this() 的类需要继承 <code>std::enable_shared_from_this</code> 类，<code>std::enable_shared_from_this</code> 类中持有一个类型为 weak_ptr 的成员 _M_weak_this，调用 shared_from_this() 就是将内部持有的 weak_ptr 转成了 shared_ptr。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ul><li>shared_ptr 内部使用 __shared_count 中的 _Sp_counted_base 对象来控制托管指针；</li><li>_Sp_counted_base 内部有 _M_use_count 和 _M_weak_count；<ul><li>_M_use_count 表示托管指针的引用计数，_M_use_count 为 0 时，释放托管指针指向的内存；</li><li>_M_weak_count 表示 _Sp_counted_base 的引用计数，_M_weak_count 为 0 时，释放 _Sp_counted_base 指向的内存；</li></ul></li><li>_Sp_counted_base 的生命周期一般不会短于 shared_ptr 的生命周期。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型推导(C++11)</title>
      <link href="/2020/10/14/51296.html"/>
      <url>/2020/10/14/51296.html</url>
      
        <content type="html"><![CDATA[<p>C++11 中引入了 <strong>auto</strong> 和 <strong>decltype</strong> 关键字来实现类型推导，通过这两个关键字不仅能方便的获取复杂的类型，还能简化书写，提高编码效率。</p><h2 id="一、auto"><a href="#一、auto" class="headerlink" title="一、auto"></a>一、auto</h2><h3 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> val1 <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>  <span class="token comment">// val1 -&gt; int</span><span class="token keyword">auto</span> val2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">auto</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// val2 -&gt; int*</span><span class="token keyword">static</span> <span class="token keyword">auto</span> val3 <span class="token operator">=</span> <span class="token number">6.6</span><span class="token punctuation">;</span>  <span class="token comment">// val3 -&gt; double</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">*</span> val4 <span class="token operator">=</span> <span class="token operator">&amp;</span>val1<span class="token punctuation">,</span> val5 <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>  <span class="token comment">// val4 -&gt; const int*, val5 -&gt; const int</span><span class="token keyword">auto</span> val6<span class="token punctuation">;</span>  <span class="token comment">// error: 无法推导出类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>val4 和 val5 需要注意两点：</p><ul><li>虽然已通过 &amp;val1 推导出类型为 int，但是 val5 仍然要写后面的 “=6”，否则编辑失败；</li><li>val5 的初始化不能使编译器产生二义性。如 “val5=6.0”，编译器将会报错。</li></ul><h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><ul><li>auto 不能代表一个实际的类型声明，只是一个类型声明的“占位符”；</li><li>使用 auto 声明的变量必须<strong>马上初始化</strong>，以让编译器推断出它的实际类型，并在编译时将 auto 占位符替换为真正的类型。</li></ul><h3 id="2-推导规则"><a href="#2-推导规则" class="headerlink" title="2. 推导规则"></a>2. 推导规则</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> val1 <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token keyword">auto</span><span class="token operator">*</span> val2 <span class="token operator">=</span> <span class="token operator">&amp;</span>val1<span class="token punctuation">;</span>  <span class="token comment">// val2 -&gt; int*</span><span class="token keyword">auto</span> val3 <span class="token operator">=</span> <span class="token operator">&amp;</span>val1<span class="token punctuation">;</span>  <span class="token comment">// val3 -&gt; int*</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> val4 <span class="token operator">=</span> val1<span class="token punctuation">;</span>  <span class="token comment">// val4 -&gt; int&amp;</span><span class="token keyword">auto</span> val5 <span class="token operator">=</span> val4<span class="token punctuation">;</span>  <span class="token comment">// val5 -&gt; int</span><span class="token keyword">const</span> <span class="token keyword">auto</span> val5 <span class="token operator">=</span> val1<span class="token punctuation">;</span>  <span class="token comment">// val5 -&gt; const int</span><span class="token keyword">auto</span> val6 <span class="token operator">=</span> val5<span class="token punctuation">;</span>  <span class="token comment">// val6 -&gt; int</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> val7 <span class="token operator">=</span> val1<span class="token punctuation">;</span>  <span class="token comment">// val7 -&gt; const int&amp;</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> val8 <span class="token operator">=</span> val7<span class="token punctuation">;</span>  <span class="token comment">// val8 -&gt; const int&amp;;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与函数模板参数的自动推导类似。</p><h4 id="结论：-1"><a href="#结论：-1" class="headerlink" title="结论："></a>结论：</h4><ul><li>当<strong>不声明为指针或者引用</strong>时，auto 的推导结果和初始化表达式抛弃引用和 cv 限定符后的类型一致；</li><li>当<strong>声明为指针或者引用</strong>时，auto 推导的结果将保持初始化表达式的 cv 属性。</li></ul><h3 id="3-auto-的限制"><a href="#3-auto-的限制" class="headerlink" title="3. auto 的限制"></a>3. auto 的限制</h3><ul><li><strong>不能用于函数参数</strong></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">)</span>  <span class="token comment">// error: 不能用于函数参数</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>不能用于非静态成员变量</strong>，仅能用于推导 static const 的整形或者枚举成员（因为其他静态类型在 C++ 标准中无法就地初始化）。C++11 中可以接受非静态成员变量的就地初始化，但不支持 auto 类型非静态成员变量的初始化</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> var1_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// error</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">auto</span> var2_ <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// ok  var2_ -&gt; static const int</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>无法定义数组</strong></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> array1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> array2 <span class="token operator">=</span> array1<span class="token punctuation">;</span>  <span class="token comment">// array2 -&gt; int*</span><span class="token keyword">auto</span> array3<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>无法推导出模版参数</strong></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">auto</span><span class="token operator">&gt;</span> vec2 <span class="token operator">=</span> vec1<span class="token punctuation">;</span>  <span class="token comment">// error</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">auto</span><span class="token operator">&gt;</span> vec3 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-应用"><a href="#4-应用" class="headerlink" title="4. 应用"></a>4. 应用</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 未使用 auto 时</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> test1<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator iter <span class="token operator">=</span> test1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> test1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>iter<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// do something</span>    <span class="token punctuation">}</span>    std<span class="token double-colon punctuation">::</span>multimap<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> test2<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>multimap<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>multimap<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator<span class="token operator">&gt;</span> range <span class="token operator">=</span> test2<span class="token punctuation">.</span><span class="token function">equal_range</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 使用 auto 时</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> test1<span class="token punctuation">;</span>    <span class="token keyword">auto</span> iter <span class="token operator">=</span> test1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> test1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>iter<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// do something</span>    <span class="token punctuation">}</span>    std<span class="token double-colon punctuation">::</span>multimap<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> test2<span class="token punctuation">;</span>    <span class="token keyword">auto</span> range <span class="token operator">=</span> test2<span class="token punctuation">.</span><span class="token function">equal_range</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：auto 虽然很强大，但是也不要随意使用 auto，否则会带来代码可读性和维护性的严重下降。</p><h2 id="二、decltype"><a href="#二、decltype" class="headerlink" title="二、decltype"></a>二、decltype</h2><h3 id="1-基本用法-1"><a href="#1-基本用法-1" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h3><p>C++11 新增 <strong>decltype</strong> 关键字，用来在编译时推导出一个表达式的类型。定义如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">decltype</span><span class="token punctuation">(</span>exp<span class="token punctuation">)</span>  <span class="token comment">// exp 为一个表达式</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>decltype 的推导过程是在编译期完成的，并且不会真正计算表达式的值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> val1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>val1<span class="token punctuation">)</span> val2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// val2 -&gt; int</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>val1 <span class="token operator">+</span> val2<span class="token punctuation">)</span> val3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// val3 -&gt; int</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> val4 <span class="token operator">=</span> val1<span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>val4<span class="token punctuation">)</span> val5 <span class="token operator">=</span> val4<span class="token punctuation">;</span>  <span class="token comment">// val5 -&gt; const int&amp;</span><span class="token keyword">const</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>val3<span class="token punctuation">)</span><span class="token operator">*</span> val6 <span class="token operator">=</span> <span class="token operator">&amp;</span>val3<span class="token punctuation">;</span>  <span class="token comment">// val6 -&gt; const int*</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>val3<span class="token punctuation">)</span><span class="token operator">*</span> val7 <span class="token operator">=</span> <span class="token operator">&amp;</span>val3<span class="token punctuation">;</span>  <span class="token comment">// val7 -&gt; int*</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>val6<span class="token punctuation">)</span><span class="token operator">*</span> val8 <span class="token operator">=</span> <span class="token operator">&amp;</span>val7<span class="token punctuation">;</span>  <span class="token comment">// val8 -&gt; const int**</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>decltype 精确地推导出表达式定义本身的类型，不会像 auto 那样在某些情况下舍弃引用和 cv 限定符。</p><h3 id="2-推导规则-1"><a href="#2-推导规则-1" class="headerlink" title="2. 推导规则"></a>2. 推导规则</h3><ul><li>exp 是标识符、类访问表达式，decltype(exp) 和 exp 的类型一致</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> x_ <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> y_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token keyword">volatile</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> n2 <span class="token operator">=</span> n1<span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span> val1 <span class="token operator">=</span> n1<span class="token punctuation">;</span>  <span class="token comment">// val1 -&gt; int</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>n2<span class="token punctuation">)</span> val2 <span class="token operator">=</span> n2<span class="token punctuation">;</span>  <span class="token comment">// val2 -&gt; const valatile int&amp;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>Test<span class="token double-colon punctuation">::</span>x_<span class="token punctuation">)</span> val3 <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>  <span class="token comment">// val3 -&gt; const int</span><span class="token comment">// 类访问表达式</span>Test a<span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>y_<span class="token punctuation">)</span> val4 <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>  <span class="token comment">// val4 -&gt; int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>exp 是函数调用，decltype(exp) 和函数返回值一致</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">func_int_l</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 左值</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">func_int_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 右值</span><span class="token keyword">int</span> <span class="token function">func_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 纯右值</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">func_cint_l</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 左值</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">func_cint_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 右值</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token function">func_cint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 纯右值</span><span class="token keyword">const</span> Test <span class="token function">func_ct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 纯右值</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_int_l</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> x1 <span class="token operator">=</span> n<span class="token punctuation">;</span>  <span class="token comment">// x1 -&gt; int&amp;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_int_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> y1 <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>  <span class="token comment">// y1 -&gt; int&amp;&amp;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> z1 <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>  <span class="token comment">// z1 -&gt; int</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_cint_l</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> x2 <span class="token operator">=</span> n<span class="token punctuation">;</span>  <span class="token comment">// x2 -&gt; const int&amp;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_cint_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> y2 <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>  <span class="token comment">// y2 -&gt; const int&amp;&amp;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_cint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> z2 <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>  <span class="token comment">// z2 -&gt; int</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_ct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> val <span class="token operator">=</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// val -&gt; const Test</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：z2 的推导结果是 int 而不是 const int，这是因为函数的返回值 int 是个纯右值，对于纯右值而言，只有类类型可以携带 cv 限定符，所以 func_ct 推导出来的 a 是 const Test。</p><ul><li>若 exp 是一个左值，则 decltype(exp) 是 exp 的一个左值引用，否则和 exp 的类型一致</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 带括号的表达式和加法运算表达式</span><span class="token keyword">const</span> Test a <span class="token operator">=</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>y_<span class="token punctuation">)</span> x1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// x1 -&gt; int  根据规则1</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>y_<span class="token punctuation">)</span><span class="token punctuation">)</span> x2 <span class="token operator">=</span> x1<span class="token punctuation">;</span>  <span class="token comment">// x2 -&gt; const int&amp;  加括号后也为左值，根据规则3，a 是 const，所以 a.y_ 是 const int</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>i <span class="token operator">+</span> j<span class="token punctuation">)</span> y1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// y1 -&gt; int  i + j 为右值，根据规则3</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>i <span class="token operator">+=</span> j<span class="token punctuation">)</span> y2 <span class="token operator">=</span> y1<span class="token punctuation">;</span>  <span class="token comment">// y2 -&gt; int&amp;  i += j 为左值，根据规则3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-应用"><a href="#3-应用" class="headerlink" title="3. 应用"></a>3. 应用</h3><p>decltype 多用在泛型编程中。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">begin</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> container<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        iter_ <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> iter_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec1<span class="token punctuation">;</span>    Test<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> t1<span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span>vec1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// iter_ -&gt; std::vector&lt;int&gt;::iterator</span>    <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec2<span class="token punctuation">;</span>    Test<span class="token operator">&lt;</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> t2<span class="token punctuation">;</span>    t2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span>vec2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// iter_ -&gt; std::vector&lt;int&gt;::const_iterator</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、返回类型后置语法"><a href="#三、返回类型后置语法" class="headerlink" title="三、返回类型后置语法"></a>三、返回类型后置语法</h2><p>C++11 中增加了返回类型后置语法，将 decltype 和 auto 结合起来完成返回值类型的推导，主要用在泛型编程中。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span><span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> U u<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>t <span class="token operator">+</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> t <span class="token operator">+</span> u<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">2.0</span><span class="token punctuation">;</span><span class="token keyword">auto</span> res <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于范围的 for 循环(C++11)</title>
      <link href="/2020/10/13/33510.html"/>
      <url>/2020/10/13/33510.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、C-11-前-for-循环的用法"><a href="#一、C-11-前-for-循环的用法" class="headerlink" title="一、C++11 前 for 循环的用法"></a>一、C++11 前 for 循环的用法</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator iter <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>iter<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>iter <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token comment">// for_each 方法</span>    std<span class="token double-colon punctuation">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::for_each</code> 与普通的 for 循环相比，不需要关注迭代器，只需要关心容器中的元素类型即可。不过都需要显式给出容器的开头和结尾。</p><h2 id="二、C-11-的-for-循环"><a href="#二、C-11-的-for-循环" class="headerlink" title="二、C++11 的 for 循环"></a>二、C++11 的 for 循环</h2><p>C++11 中改善了这种遍历方式，不再需要给出容器的两端，循环会根据容器的范围自动展开。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token comment">// 语法：</span><span class="token comment">// for (element : container) {</span><span class="token comment">//    statement;</span><span class="token comment">// }</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">:</span> vec<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 编译器会转换为：</span><span class="token comment">// for (auto _begin=vec.begin(), _end=vec.end(); _begin!=_end; ++_begin) {</span><span class="token comment">//  n = *_begin;</span><span class="token comment">//  statement;</span><span class="token comment">// }</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基于范围的 for 循环，对于冒号前面的局部变量声明只要求能够支持容器类型的隐式转换。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> vec<span class="token punctuation">)</span>  <span class="token comment">// int 会被隐式转换为 char</span>  <span class="token comment">// ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以上都是以只读方式来遍历容器的，如果需要改变容器中的值，需要加上引用，如果是只希望遍历而不是修改，可以使用 <code>const auto&amp;</code> 来定义，这样对于复制负担比较大的容器元素也可以无耗的进行遍历。</p><h2 id="三、使用细节"><a href="#三、使用细节" class="headerlink" title="三、使用细节"></a>三、使用细节</h2><h3 id="1-推导类型"><a href="#1-推导类型" class="headerlink" title="1. 推导类型"></a>1. 推导类型</h3><p>使用范围的 for 循环和普通的 for 循环的区别：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> tmap <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 普通 for 循环</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> iter <span class="token operator">=</span> tmap<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> tmap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>iter<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> iter<span class="token operator">-&gt;</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">" : "</span> <span class="token operator">&lt;&lt;</span> iter<span class="token operator">-&gt;</span>second <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 基于范围的 for 循环</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> val <span class="token operator">:</span> tmap<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> val<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">" : "</span> <span class="token operator">&lt;&lt;</span> val<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>基于范围的 for 循环中 val 的类型是 <code>std::pair</code>。因此，对于 map 这种关联性容器而言，需要使用 val.first 或 val.second 来提取键值；</li><li>auto 自动推导出的类型是容器中的 value_type，而不是迭代器。</li></ul><h3 id="2-容器约束"><a href="#2-容器约束" class="headerlink" title="2. 容器约束"></a>2. 容器约束</h3><ul><li>对于 <code>std::map</code> 等关联性容器的遍历，基于范围的 for 循环中的 <code>std::pair</code> 引用，是不能够修改 first 的。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;set&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> tmap <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> tset <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> val <span class="token operator">:</span> tmap<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// val: std::pair&lt;const int, int&gt;&amp;</span>        <span class="token operator">++</span>val<span class="token punctuation">.</span>first<span class="token punctuation">;</span>  <span class="token comment">// error: 表达式必须是可修改的左值</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> val <span class="token operator">:</span> tset<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// val: const int&amp;</span>        <span class="token operator">++</span>val<span class="token punctuation">;</span>  <span class="token comment">// error: 表达式必须是可修改的左值</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于基于范围的 for 循环而言，冒号后面的表达式只会被执行一次。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">get_vec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"get_vec"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">:</span> <span class="token function">get_vec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序执行结果：</p><p><img src="/pic/33510_001.png" alt="for"></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>基于范围的 for 循环其实是普通 for 循环的语法糖，同普通的循环一样，在迭代时修改容器可能引起迭代器失效，导致一些意料之外的结果。</p><p><strong>切莫在 for 循环中修改容器的大小（添加和删除元素）</strong></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>列表初始化(C++11)</title>
      <link href="/2020/10/13/56762.html"/>
      <url>/2020/10/13/56762.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、C-98-x2F-03-初始化"><a href="#一、C-98-x2F-03-初始化" class="headerlink" title="一、C++98/03 初始化"></a>一、C++98/03 初始化</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 普通数组</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// POD(plain old data) 用来表明C++中与C相兼容的数据类型</span><span class="token keyword">struct</span> <span class="token class-name">TestA</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">TestB</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> i<span class="token punctuation">;</span>        <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span>b<span class="token punctuation">;</span><span class="token punctuation">}</span>a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 拷贝初始化</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>T <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token comment">// 直接初始化</span><span class="token keyword">int</span> <span class="token function">j</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些不同的初始化方法都有各自的适用范围，但是种类繁多的方法却没有一种可以通用的，所以 C++11 提出了初始化列表的方法来解决此问题。</p><h2 id="二、快速初始化成员变量"><a href="#二、快速初始化成员变量" class="headerlink" title="二、快速初始化成员变量"></a>二、快速初始化成员变量</h2><p>在 C++98/03 中，支持在类声明中使用等号”=”加初始值的方式，来初始化类中静态成员常量。如果静态成员不满足常量性，则不可以就地初始化，而且即使静态成员常量也只能是整型或者枚举才能就地初始化，而非静态成员变量的初始化则必须在构造函数中进行。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a_</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a_</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> a_<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c_ <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// error, 无法编译通过</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> d_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 无法编译通过</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">double</span> e_ <span class="token operator">=</span> <span class="token number">1.3</span><span class="token punctuation">;</span>  <span class="token comment">// 非整型或者枚举，无法编译通过</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> f_ <span class="token operator">=</span> <span class="token string">"e"</span><span class="token punctuation">;</span>  <span class="token comment">// 非整型或者枚举，无法编译通过</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++11 中可以使用 {} 就地初始化非静态成员，但是列表初始化的效果总是优于就地初始化的。对于非常量的静态成员变量，还是需要到头文件以外去定义。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">TestA</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">TestA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestA(), num: "</span> <span class="token operator">&lt;&lt;</span> num_ <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TestA</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">num_</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestA(int), num: "</span> <span class="token operator">&lt;&lt;</span> num_ <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> num_<span class="token punctuation">{</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">TestB</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">TestB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestB(), val: "</span> <span class="token operator">&lt;&lt;</span> val_ <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TestB</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val_</span><span class="token punctuation">(</span><span class="token char">'G'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">a</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestB(int), val: "</span> <span class="token operator">&lt;&lt;</span> val_ <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">num_of_a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"number of A: "</span> <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span>num_ <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">num_of_b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"number of B: "</span> <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span>num_ <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">char</span> val_<span class="token punctuation">{</span> <span class="token char">'g'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    TestA a<span class="token punctuation">;</span>    TestA b<span class="token punctuation">{</span> <span class="token number">19</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    TestA a<span class="token punctuation">;</span>  <span class="token comment">// TestA(), num: 2</span>    TestB b<span class="token punctuation">;</span>  <span class="token comment">// TestA(), num: 2</span>    <span class="token comment">// TestA(int), num: 19</span>    <span class="token comment">// TestB(), val: g</span>    b<span class="token punctuation">.</span><span class="token function">num_of_a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// number of A: 2</span>    b<span class="token punctuation">.</span><span class="token function">num_of_b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// number of B: 19</span>    TestB <span class="token function">c</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// TestA(int), num: 7</span>    <span class="token comment">// TestA(int), num: 19</span>    <span class="token comment">// TestB(int), val: G</span>    c<span class="token punctuation">.</span><span class="token function">num_of_a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// number of A: 7</span>    c<span class="token punctuation">.</span><span class="token function">num_of_b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// number of B: 19</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、统一初始化方法——列表初始化"><a href="#三、统一初始化方法——列表初始化" class="headerlink" title="三、统一初始化方法——列表初始化"></a>三、统一初始化方法——列表初始化</h2><p>C++98/03 中已经存在初始化列表的方法，只是范围比较窄，只适用于常规 POD 类型。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> arr1<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> arr2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span><span class="token punctuation">}</span>t <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++11 将这种初始化方法适用于所有类型的初始化，可以使用以下几种形式完成初始化工作：</p><ul><li>等号”=”加上赋值表达式，比如 <code>int a = 3 + 4;</code></li><li>等号”=”加上花括号式的初始化列表，比如 <code>int a = { 3 + 4 };</code></li><li>圆括号式的表达式列表，比如 <code>int a(3+4);</code></li><li>花括号式的初始化列表，比如 <code>int a{ 3+4 };</code></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Test <span class="token function">v1</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Test v2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    Test v3<span class="token punctuation">{</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> v4 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> v5<span class="token punctuation">{</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新的初始化方法是变量名后面加 {} 来进行初始化，{} 内则是初始化的内容，等号是否存在并不影响(编译器会进行优化)。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">type val<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>初始化列表支持 new 操作符，也可以作为函数的返回值：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">{</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>、std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++11 中，初始化列表是非常方便的，不仅统一了对象的初始化方式，还使代码更加简洁清晰。</p><h3 id="1-std-initializer-list"><a href="#1-std-initializer-list" class="headerlink" title="1. std::initializer_list"></a>1. std::initializer_list</h3><p>在 C++11 中，对于 stl 容器和未显示数组长度的数组可以进行任意长度的初始化。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> tmap <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但是对于自定义类型不具备这种能力，但是 C++11 解决了这个问题，C++11 中可以通过轻量级模板 <code>std::initalizer_list</code> 来解决这个问题。只需要添加一个参数为 <code>std::initializer_list</code> 的构造函数，这个自定义类型即可拥有这种任意长度初始化列表来初始化的能力。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vals<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> each <span class="token operator">:</span> vals<span class="token punctuation">)</span> <span class="token punctuation">{</span>            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> each <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Test t<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::initializer_list</code> 负责接收初始化列表，可以通过 for 循环来读取其中的元素，并对元素做操作。同样的，可以作为函数参数传递同类型的数据集合。在任何需要的时候，都可以使用其来一次性传递多个<strong>同类型</strong>参数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> pair_t <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_type<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span>pair_t<span class="token operator">&gt;</span> list<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> each <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            map_<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>each<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> map_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Test t <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> each <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> each <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-使用细节"><a href="#2-使用细节" class="headerlink" title="2. 使用细节"></a>2. 使用细节</h3><p><code>std::initializer_list</code> 的实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Elem</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">initializer_list</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> value_type <span class="token operator">=</span> _Elem<span class="token punctuation">;</span>    <span class="token keyword">using</span> reference <span class="token operator">=</span> <span class="token keyword">const</span> _Elem<span class="token operator">&amp;</span><span class="token punctuation">;</span>    <span class="token keyword">using</span> const_reference <span class="token operator">=</span> <span class="token keyword">const</span> _Elem<span class="token operator">&amp;</span><span class="token punctuation">;</span>    <span class="token keyword">using</span> size_type <span class="token operator">=</span> size_t<span class="token punctuation">;</span>    <span class="token keyword">using</span> iterator <span class="token operator">=</span> <span class="token keyword">const</span> _Elem<span class="token operator">*</span><span class="token punctuation">;</span>    <span class="token keyword">using</span> const_iterator <span class="token operator">=</span> <span class="token keyword">const</span> _Elem<span class="token operator">*</span><span class="token punctuation">;</span>    <span class="token keyword">constexpr</span> <span class="token function">initializer_list</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">:</span> <span class="token function">_First</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_Last</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">constexpr</span> <span class="token function">initializer_list</span><span class="token punctuation">(</span><span class="token keyword">const</span> _Elem<span class="token operator">*</span> _First_arg<span class="token punctuation">,</span> <span class="token keyword">const</span> _Elem<span class="token operator">*</span> _Last_arg<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>        <span class="token operator">:</span> <span class="token function">_First</span><span class="token punctuation">(</span>_First_arg<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_Last</span><span class="token punctuation">(</span>_Last_arg<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    _NODISCARD <span class="token keyword">constexpr</span> <span class="token keyword">const</span> _Elem<span class="token operator">*</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> _First<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    _NODISCARD <span class="token keyword">constexpr</span> <span class="token keyword">const</span> _Elem<span class="token operator">*</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> _Last<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    _NODISCARD <span class="token keyword">constexpr</span> size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>_Last <span class="token operator">-</span> _First<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">const</span> _Elem<span class="token operator">*</span> _First<span class="token punctuation">;</span>    <span class="token keyword">const</span> _Elem<span class="token operator">*</span> _Last<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::initializer_list</code> 的特点如下：</p><ul><li><p>编译底层使用的是 <code>std::array</code>，<code>std::initializer_list</code> 保存的是 array 的引用；</p></li><li><p>它是一个轻量级的容器类型；</p></li><li><p>可以接收任意长度的初始化列表，但是要求元素必须都是同种类型；</p></li><li><p>有三个成员接口，size()，begin()，end()；</p></li><li><p>只能被整体初始化或者赋值。</p></li></ul><p><code>std::initializer_list</code> 的访问只能通过 begin() 和 end() 来进行循环遍历，遍历取得的迭代器是只读的，所以无法修改其中元素的值，但是可以整体赋值来修改。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ini_list<span class="token punctuation">;</span>size_t len <span class="token operator">=</span> ini_list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// len = 0</span>ini_list <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>len <span class="token operator">=</span> ini_list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// len = 5</span>ini_list <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>len <span class="token operator">=</span> ini_list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// len = 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>std::initializer_list</code> 是非常高效的，它的内部并不保存初始化列表元素中的拷贝，仅仅<strong>保存初始化列表中的引用</strong>。</p><p>如果按照下面的代码来使用 <code>std::initializer_list</code> 是错误的，虽然可以正常通过编译，但是可能无法得到我们希望的结果，因为 a，b 在函数结束时生存周期也结束了，返回的是不确定的内容。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;&gt;</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> vec1<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        vec1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> vec2<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">200</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        vec2<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span> vec1<span class="token punctuation">,</span> vec2 <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// vec1, vec2 在返回时并没有拷贝</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确的用法是，通过真正的容器或者具有转移拷贝语意的容器来替代 <code>std::initializer_list</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;&gt;</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> vec1<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        vec1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> vec2<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">200</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        vec2<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span> vec1<span class="token punctuation">,</span> vec2 <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// vec1, vec2 在返回时并没有拷贝</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、防止类型收窄"><a href="#四、防止类型收窄" class="headerlink" title="四、防止类型收窄"></a>四、防止类型收窄</h2><h3 id="1-类型收窄的情况"><a href="#1-类型收窄的情况" class="headerlink" title="1. 类型收窄的情况"></a>1. 类型收窄的情况</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Test <span class="token function">t</span><span class="token punctuation">(</span><span class="token number">1.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子就是类型收窄的情况，虽然说能够正常通过编译，但是在传递 i 之后不能完整的保存浮点数的数据。</p><p>C++ 中类型收窄的情况：</p><ul><li>从一个浮点数隐式转换为一个整数，如 <code>int i = 2.2;</code></li><li>从高精度浮点数隐式转换为低精度浮点数，如 long doule 隐式转换为 double 或者 float；</li><li>从一个整数隐式转换为一个浮点数，并且超出了浮点数的范围，如 <code>float f = (unsigned long long)–1</code>；</li><li>从一个整型隐式转换为一个长度较短的整型数，并且超出了长度较短的整型数范围，如 <code>char x = 65536</code>。</li></ul><p>这些类型收窄的情况，在编译器并不会报错，但是可能存在潜在的错误。</p><h3 id="2-C-11-的改善"><a href="#2-C-11-的改善" class="headerlink" title="2. C++11 的改善"></a>2. C++11 的改善</h3><p>C++11 中可以通过初始化列表来检查，防止类型的收窄。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">1.1</span><span class="token punctuation">;</span>  <span class="token comment">// ok</span><span class="token keyword">int</span> n2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1.1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// error</span><span class="token keyword">float</span> f1 <span class="token operator">=</span> <span class="token number">1e40</span><span class="token punctuation">;</span>  <span class="token comment">// ok</span><span class="token keyword">float</span> f2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1e40</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// error</span><span class="token keyword">float</span> f3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// ok</span><span class="token keyword">float</span> f4 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// error</span><span class="token keyword">float</span> f5 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// ok</span><span class="token keyword">float</span> f6 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// ok</span><span class="token keyword">const</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">char</span> c1 <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">// ok</span><span class="token keyword">char</span> c2 <span class="token operator">=</span> <span class="token punctuation">{</span> x <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// error</span><span class="token keyword">char</span> c3 <span class="token operator">=</span> y<span class="token punctuation">;</span>  <span class="token comment">// ok</span><span class="token keyword">char</span> c4 <span class="token operator">=</span> <span class="token punctuation">{</span> y <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// ok</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、聚合类型"><a href="#五、聚合类型" class="headerlink" title="五、聚合类型"></a>五、聚合类型</h2><h3 id="1-自定义类型初始化"><a href="#1-自定义类型初始化" class="headerlink" title="1. 自定义类型初始化"></a>1. 自定义类型初始化</h3><p>在 C++11 中使用初始化列表时，可能有以下情况：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">TestA</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span>a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">123</span><span class="token punctuation">,</span><span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// a.x = 123, a.y = 123</span><span class="token keyword">struct</span> <span class="token class-name">TestB</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span>    <span class="token function">TestB</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span>b <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">123</span><span class="token punctuation">,</span><span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// b.x = 0, b.y = 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TestA 是以 C++98/03 的聚合类型来初始化的，用拷贝的方式初始化 TestA 中的成员，而 TestB 由于自定义了构造函数，所以初始化是以构造函数来初始化的。</p><p>当使用初始化列表时，如果是聚合类型，则以拷贝的方式来初始化成员，如果是非聚合类型，则是以构造函数来初始化成员。</p><h3 id="2-聚合类型"><a href="#2-聚合类型" class="headerlink" title="2. 聚合类型"></a>2. 聚合类型</h3><ol><li>类型是普通数组（int[10]，char[]，long[2][3]等）；</li><li>类型是类，且：<ul><li>无用户自定义构造函数；</li><li>无私有或者保护的非静态成员；</li><li>无基类；</li><li>无虚函数；</li><li>无{}和=直接初始化的非静态数据成员。</li></ul></li></ol><h4 id="2-1-数组"><a href="#2-1-数组" class="headerlink" title="2.1 数组"></a>2.1 数组</h4><p>对于数组而言，只要该类型是一个普通的数组，如果数组的元素并不是聚合类型，那么这个数组仍是一个聚合类型。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>string strarr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"C++"</span><span class="token punctuation">,</span> <span class="token string">"11"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-2-存在自定义构造函数"><a href="#2-2-存在自定义构造函数" class="headerlink" title="2.2 存在自定义构造函数"></a>2.2 存在自定义构造函数</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span>    <span class="token keyword">int</span> z<span class="token punctuation">;</span>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Test a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">12</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当一个自定义类或结构体拥有自己的构造函数，无法将该类看作一个聚合类型，必须通过自定义的构造函数才能构造对象。</p><h4 id="2-3-存在私有或者保护的非静态数据成员"><a href="#2-3-存在私有或者保护的非静态数据成员" class="headerlink" title="2.3 存在私有或者保护的非静态数据成员"></a>2.3 存在私有或者保护的非静态数据成员</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">TestA</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">int</span> z<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>TestA a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">12</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">// error</span><span class="token keyword">struct</span> <span class="token class-name">TestB</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> z<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>TestB b <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>       <span class="token comment">// ok</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TestA 的实例化是失败的，因为 z 是一个受保护的非静态成员。而 TestB 是成功的，因为 z 是一个受保护的静态数据成员，所以，类成员里面的静态数据成员是不能通过初始化列表来初始化的，静态数据成员的初始化遵循静态成员的初始化方式。</p><h4 id="2-4-基类或者虚函数"><a href="#2-4-基类或者虚函数" class="headerlink" title="2.4 基类或者虚函数"></a>2.4 基类或者虚函数</h4><p>有基类或者虚函数同样不适用于使用初始化列表。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">TestA</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>TestA a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>       <span class="token comment">// error</span><span class="token keyword">struct</span> <span class="token class-name">Base</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Derived b <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>       <span class="token comment">// error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-5-和-x3D-初始化的非静态数据成员"><a href="#2-5-和-x3D-初始化的非静态数据成员" class="headerlink" title="2.5 {} 和 = 初始化的非静态数据成员"></a>2.5 {} 和 = 初始化的非静态数据成员</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Test a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>y 在声明时被初始化为 2，所以 A 不再是一个聚合类型。</p><p>这个例子中需要注意的是，C++11 中放宽了类型声明的初始化操作，即在非静态数据成员的声明时调用 {} 或者 = 来对成员进行初始化，但是造成的影响是该类型不再是聚合类型，所以不能直接使用初始化列表。如果要使用初始化列表就必须自己定义一个构造函数。</p><h3 id="3-聚合类型并非递归"><a href="#3-聚合类型并非递归" class="headerlink" title="3. 聚合类型并非递归"></a>3. 聚合类型并非递归</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">TestA</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> z<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>TestA a<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">// error</span>TestA a1<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token comment">// ok</span><span class="token keyword">struct</span> <span class="token class-name">TestB</span><span class="token punctuation">{</span>    TestA a<span class="token punctuation">;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>TestB b<span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2.5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TestA 有一个私有化的非静态成员，所以使用 a 是错误的，但是可以调用无参构造函数，所以在 TestB 中，即使成员 a 是一个非聚合类型，但是 TestB 仍然是一个聚合类型，可以直接使用初始化列表。</p><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><p>对于一个聚合类型，使用初始化列表相当于对其中每个元素分别赋值；而对于非集合类型，则需要先定义一个合适的构造函数，此时使用初始化列表将调用对应的构造函数。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>function、bind、lambda(C++11)</title>
      <link href="/2020/10/13/44198.html"/>
      <url>/2020/10/13/44198.html</url>
      
        <content type="html"><![CDATA[<p>C++11 新增 <code>std::function</code>、<code>std::bind</code>、lambda 表达式等封装，使函数调用更加方便。</p><p>满足以下条件之一就可称为<strong>可调用对象</strong>：</p><ul><li>函数指针；</li><li>具有 operator() 成员函数的类对象(传说中的仿函数)，lambda 表达式；</li><li>是一个可被转换为函数指针的类对象；</li><li>是一个类成员(函数)指针；</li><li>bind 表达式或其它函数对象。</li></ul><h2 id="一、lambda-表达式"><a href="#一、lambda-表达式" class="headerlink" title="一、lambda 表达式"></a>一、lambda 表达式</h2><p>lambda 表达式定义了一个匿名函数，可以捕获一定范围的变量在函数内部使用，一般有如下语法形式：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span>capture<span class="token punctuation">]</span> <span class="token punctuation">(</span>params<span class="token punctuation">)</span> opt <span class="token operator">-&gt;</span> ret <span class="token punctuation">{</span> func_body<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>func：可以说是 lambda 表达式的名字，作为一个函数使用；</li><li>capture：捕获列表；</li><li>params：参数列表；</li><li>opt：函数选项(mutable 之类)；</li><li>ret：返回值类型；</li><li>func_body：函数体。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> func1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> func2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> func3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 省略空参数列表</span><span class="token keyword">auto</span> func4 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// error：无法自动推导</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>很多时候 lambda 表达式返回值是很明显的，C++11 允许省略表达式的返回值定义，但是，<strong>初始化列表不能用于返回值的自动推导</strong>。在没有参数列表的时候，参数列表可以省略。</p><p>lambda 表达式允许捕获一定范围内的变量：</p><ul><li>[] 不捕获任何变量；</li><li>[&amp;] 捕获外部作用域中所有变量，并作为引用在函数体内使用（按引用捕获）；</li><li>[=] 捕获外部作用域中所有变量，并作为副本在函数体内使用（按值捕获）；</li><li>[=, &amp;a] 按值捕获外部作用域中所有变量，并按引用捕获 a 变量；</li><li>[a] 按值捕获 a 变量，不捕获其它变量；</li><li>[this] 捕获当前类中的 this 指针，让 lambda 表达式拥有和当前类成员函数同样的访问权限。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> func1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 值捕获 a</span>    a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func1.a: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// func1.a: 0</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// a: 100</span>    <span class="token keyword">auto</span> func2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// error 修改按值捕获的外部变量</span>    <span class="token keyword">auto</span> func3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">mutable</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">++</span>a<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func3.a: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// func3.a: 101</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// a: 100</span>    <span class="token keyword">auto</span> func4 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>a<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">++</span>a<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func4.a: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">func4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// func4.a: 101</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// a: 101</span>    a <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func4.a: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">func4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// func4.a: 501</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// a: 501</span><span class="token punctuation">}</span><span class="token comment">// func1 的编译器的处理</span><span class="token keyword">class</span> <span class="token class-name">__lambda_6_14</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>     <span class="token keyword">inline</span> <span class="token comment">/*constexpr */</span> <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>     <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">__lambda_6_14</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span> _a<span class="token punctuation">)</span>        <span class="token operator">:</span> a<span class="token punctuation">{</span>_a<span class="token punctuation">}</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>__lambda_6_14 func1 <span class="token operator">=</span> __lambda_6_14<span class="token punctuation">{</span>a<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>func1 的结果为 0，因为在 lambda 表达式<strong>创建之时</strong>，<strong>就已经获取了相关变量的值</strong>，而不是在调用时获取。</p><p>func2 编译失败，因为修改了按值捕获的外部变量，其实 lambda 表达式就相当于是一个仿函数，仿函数是一个有 operator() 成员函数的类对象，这个 operator() 默认是 const 的，所以不能修改成员变量，而加了 mutable，就是去掉 const 属性。<strong>被 mutable 修饰的 lambda 表达式就算没有参数也要写明参数列表。</strong></p><p>对于没有捕获任何变量的 lambda 表达式，还可以被转换成一个普通的函数指针。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> func_t <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>func_t func <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="二、std-bind"><a href="#二、std-bind" class="headerlink" title="二、std::bind"></a>二、std::bind</h2><p>使用 <code>std::bind</code> 可以将可调用对象和参数一起绑定，绑定后的结果使用 <code>std::function</code> 进行保存，并延迟到任何需要调用的时候。</p><p><code>std::bind</code> 通常有两大作用：</p><ul><li>将可调用对象与其参数一起绑定成一个仿函数；</li><li>将 n 个参数的可调用对象转成 m(m &lt; n) 个参数的可调用对象，绑定一部分参数，这里需要使用 <code>std::placeholders</code>。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg1<span class="token punctuation">,</span> <span class="token keyword">int</span> arg2<span class="token punctuation">,</span> <span class="token keyword">int</span> arg3<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> arg4<span class="token punctuation">,</span> <span class="token keyword">int</span> arg5<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> arg1 <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> arg2 <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> arg3 <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> arg4 <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> arg5 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> arg<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg1<span class="token punctuation">,</span> <span class="token keyword">int</span> arg2<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> arg1 <span class="token operator">+</span> arg2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> data_ <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token punctuation">;</span>  <span class="token comment">// 针对 _1, _2, _3...</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>    <span class="token comment">// std::cref 创建常量引用</span>    <span class="token keyword">auto</span> f1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>func1<span class="token punctuation">,</span> _2<span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> _1<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">cref</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f1: "</span><span class="token punctuation">;</span>  <span class="token comment">// f1: 2 42 1 10 7</span>    <span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// func1(2, 42, 1, n, 7);</span>    <span class="token comment">// std::bind 嵌套</span>    <span class="token keyword">auto</span> f2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>func1<span class="token punctuation">,</span> _3<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>func2<span class="token punctuation">,</span> _3<span class="token punctuation">)</span><span class="token punctuation">,</span> _3<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f2: "</span><span class="token punctuation">;</span>  <span class="token comment">// f2: 12 12 12 4 5</span>    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// func1(12, func2(12), 12, 4, 5);</span>    <span class="token comment">// 类的成员函数指针</span>    Test t<span class="token punctuation">;</span>    <span class="token keyword">auto</span> f3 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>add<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">,</span> <span class="token number">95</span><span class="token punctuation">,</span> _1<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f3: "</span><span class="token punctuation">;</span>  <span class="token comment">// f3: 100</span>    <span class="token function">f3</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Test::add(95, 5);</span>    <span class="token comment">// 绑定指向数据成员指针  输出数据成员的值</span>    <span class="token keyword">auto</span> f4 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>data_<span class="token punctuation">,</span> _1<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f4: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">f4</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// f4: 10</span>    <span class="token comment">// 智能指针也能用于调用被引用对象的成员</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f4: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">f4</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Test<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// f4: 10</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec<span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">60</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 查找元素值大于10的元素个数</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">count_if</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">less</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> _1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 查找元素值小于10的元素个数</span>    count <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">count_if</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">less</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> _1<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、std-function"><a href="#三、std-function" class="headerlink" title="三、std::function"></a>三、std::function</h2><p><code>std::function</code> 就是上面这种可调用对象的封装器，可以把 <code>std::function</code> 看做一个函数对象，用于表示函数这个抽象概念。<code>std::function</code> 的实例可以存储、复制和调用任何可调用对象，存储的可调用对象称为 <code>std::function</code> 的目标，若 <code>std::function</code> 不含目标，则称它为空，调用空的 <code>std::function</code> 的目标会抛出 <code>std::bad_function_call</code> 异常；也可以作为函数入参。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Test1</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">num_</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> num_ <span class="token operator">+</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> num_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 仿函数</span><span class="token keyword">class</span> <span class="token class-name">Test2</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 存储普通函数</span>    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> func1 <span class="token operator">=</span> print<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func1: "</span><span class="token punctuation">;</span>    <span class="token function">func1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 存储 lambda</span>    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> func2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func2: "</span><span class="token punctuation">;</span>    <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 存储 std::bind 的结果</span>    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> func3 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>print<span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func3: "</span><span class="token punctuation">;</span>    <span class="token function">func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 存储成员函数的调用</span>    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test1<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> func4 <span class="token operator">=</span> <span class="token operator">&amp;</span>Test1<span class="token double-colon punctuation">::</span>add<span class="token punctuation">;</span>    <span class="token keyword">const</span> Test1 <span class="token function">t</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func4: "</span><span class="token punctuation">;</span>    <span class="token function">func4</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func4: "</span><span class="token punctuation">;</span>    <span class="token function">func4</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 会先构造 Test1(50)，再调用 add</span>    <span class="token comment">// 存储数据成员访问器的调用</span>    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test1<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> func5 <span class="token operator">=</span> <span class="token operator">&amp;</span>Test1<span class="token double-colon punctuation">::</span>num_<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func5: num: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">func5</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token comment">// 存储成员函数及对象的调用</span>    <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> func6 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Test1<span class="token double-colon punctuation">::</span>add<span class="token punctuation">,</span> t<span class="token punctuation">,</span> _1<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func6: "</span><span class="token punctuation">;</span>    <span class="token function">func6</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 存储成员函数和对象指针的调用</span>    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> func7 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Test1<span class="token double-colon punctuation">::</span>add<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">,</span> _1<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func7: "</span><span class="token punctuation">;</span>    <span class="token function">func7</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 存储函数对象的调用</span>    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> func8 <span class="token operator">=</span> <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func8: "</span><span class="token punctuation">;</span>    <span class="token function">func8</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><p><img src="/%5Cpic%5C44198_001.png" alt="function"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nullptr(C++11)</title>
      <link href="/2020/10/12/14457.html"/>
      <url>/2020/10/12/14457.html</url>
      
        <content type="html"><![CDATA[<p>C++11 引入了 <code>nullptr</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而 <code>NULL</code> 从源码中可得，在 C 中 <code>NULL</code> 是 <code>((void*)0)</code> 指针，在 C++ 中 <code>NULL</code> 却是个整数 0。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression"><span class="token constant">NULL</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++ 中有个很特别的规定就是 0 既表示<strong>整数常量</strong>也用来表示<strong>空指针常量</strong>。</p><p>在 C++03 标准中：</p><blockquote><p>主要规定空指针常量需要被转化为指针类型，同时这个转化为指针类型的值还不能和其它的对象指针或者函数指针的值相同。两个空指针常量的值还需要相等</p></blockquote><p>而 C99 标准中：</p><blockquote><p>C 中的空指针常量是整数 0 被强制转成了 void*，这就可以确保这个空指针的值与其他对象或函数指针值不相等。</p></blockquote><p>C++ 不允许 <code>void*</code> 隐式转换成其他指针类型。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// error: cannot initialize a variable of type 'int *' with an rvalue of type 'void *'</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一、为什么要引入-nullptr"><a href="#一、为什么要引入-nullptr" class="headerlink" title="一、为什么要引入 nullptr"></a>一、为什么要引入 nullptr</h2><p>一个原因是可以让整数 0 只表示一件事情，它只是一个整数类型 0，没有任何其他语义。</p><p>另一个原因是 C++ 函数重载中，传 <code>NULL</code> 会导致编译失败，所以需要引入 <code>nullptr</code>，使用 <code>nullptr</code> 可以解决函数重载中的参数匹配问题。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"char*"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// error: call of overloaded ‘func(NULL)’ is ambiguous</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、nullptr-的实现"><a href="#二、nullptr-的实现" class="headerlink" title="二、nullptr 的实现"></a>二、nullptr 的实现</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">nullptr_t</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>        <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>    <span class="token keyword">inline</span> <span class="token keyword">operator</span> T<span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>     <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>    <span class="token keyword">inline</span> <span class="token keyword">operator</span> T C<span class="token double-colon punctuation">::</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>     <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过实现部分运算符，<code>nullptr</code> 可以转换成 int* 等，同时，它的取址操作被 delete 修饰，所以不能对 <code>nullptr</code> 取址。</p><p><strong>nullptr 可以用于抛出异常</strong>：<code>nullptr</code> 是有类型的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> nullptr_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当空指针用 <code>nullptr</code> 表示时，空指针就有类型了，当有异常需要抛出时，就可以抛出 <code>nullptr</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">// ...</span>        <span class="token keyword">throw</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">catch</span><span class="token punctuation">(</span>nullptr_t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// ...</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后使用它的类型 <code>nullptr_t</code> 捕获，这里如果 throw NULL，那用什么类型去 catch 呢？用 int 类型来 catch？是不是有点别扭。所以能用 <code>nullptr</code> 就一定要用 <code>nullptr</code> 代替 <code>NULL</code>。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><ol><li>使用 <code>nullptr</code> 可以不用担心整形和指针类型的重载，不会产生二义性导致编译失败；</li><li>0 和空指针分别表示不同的含义，使用 <code>nullptr</code> 可以更好的支持模板编程；</li><li>使用 <code>nullptr</code> 使代码更安全，让用户编写代码更清晰直观。</li></ol><p>空指针特性：</p><ol><li>不能被用于算术表达式中，不能被赋值给整型，也不能用于和指针类型外的类型作比较；</li><li>空指针可以转化为任何指针类型，不能转换成指针类型外的任何类型。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>noexcept(C++11)</title>
      <link href="/2020/10/12/32551.html"/>
      <url>/2020/10/12/32551.html</url>
      
        <content type="html"><![CDATA[<p><code>noexcept</code> 表示其修饰的函数不会抛出异常，如果 <code>noexcept</code> 修饰的函数抛出了异常，编译器可以选择直接调用 <code>std::terminate()</code> 函数来终止程序的运行，这比基于异常机制的 <code>throw()</code> 在效率上会高一些，这是因为异常机制会带来一些额外的开销，比如函数抛出异常，会导致函数栈被依次的展开，并依帧调用在本帧中以构造的自动变量的析构函数等。</p><p><strong>noexcept</strong> 有两种形式，一种就是简单地在函数声明后加上 <code>noexcept</code> 关键字</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span class="token comment">// 等价于</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>另一种则可以接受一个常量表达式作为参数，如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span>常量表达式<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常量表达式的结果会被转换成一个 bool 类型的值，该值为 true，表示函数不会抛出异常，反之，则有可能抛出异常。这里，不带常量表达式的 noexcept 相当于声明了 noexcept(true)，即不会抛出异常。</p><p>在 C++11 中使用 noexcept 可以有效地阻止异常的传播与扩散。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">throw_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">noBlockThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">throw_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">blockThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span>    <span class="token function">throw_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">throw_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"throw throw_test."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">noBlockThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token comment">// 会在catch中捕获异常</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"throw noBlockThrow."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">blockThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token comment">// 直接调用std::terminate中断程序的执行，从而阻止了异常的继续传播</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"throw blockThrow."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>noexcept 作为一个操作符时，通常可以用于模板</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里，func 函数是否是一个 noexcept 的函数，将由 T() 表达式是否会抛出异常所决定。这里的第二个 noexcept 就是一个 noexcept 操作符。当其参数是一个有可能抛出异常的表达式的时候，其返回值为 false，反之为 true。 这样一来，就可以使模板函数根据条件实现 noexcept 修饰的版本或无 noexcept 修饰的版本。 从泛型编程的角度看来，这样的设计保证了关于“函数是否抛出异常”这样的问题可以通过表达式进行推导。因此这也可以视作 C++11 为了更好地支持泛型编程而引入的特性。</p><p>比如在 C++98 中，存在着使用 throw() 来声明不抛出异常的函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> T <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> T <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token comment">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而在 C++11 中，则使用 noexcept 来替换 throw()</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> T <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> T <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token comment">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>又比如在 C++98 中，new 可能会包含一些抛出的 std::bad_alloc 异常。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_alloc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_alloc<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>而在 C++11 中，则使用 noexcept(false) 来进行替代。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>C++11 标准中类的析构函数默认也是 noexcept(true)。</p><h2 id="移动语义⭐"><a href="#移动语义⭐" class="headerlink" title="移动语义⭐"></a>移动语义⭐</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyString</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">char</span><span class="token operator">*</span> data_<span class="token punctuation">;</span>    size_t len_<span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// move constructor</span>    <span class="token function">MyString</span><span class="token punctuation">(</span>MyString<span class="token operator">&amp;&amp;</span> str<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>        <span class="token operator">:</span> <span class="token function">data_</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>data_<span class="token punctuation">)</span>        <span class="token punctuation">,</span> <span class="token function">len_</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>len_<span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment">// move assignment</span>    MyString<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>MyString<span class="token operator">&amp;&amp;</span> str<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span>        <span class="token comment">// ...</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>std::vector 使用移动语义时，需要确保与移动相关的函数是不会抛出异常的，否则 vector 不会调用。</strong></p><blockquote><p>You need to inform C++ (specifically std::vector) that your move constructor and destructor does not throw. Then the move constructor will be called when the vector grows. If the constructor is not noexcept, std::vector can’t use it, since then it can’t ensure the exception guarantees demanded by the standard.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new 和 delete</title>
      <link href="/2020/08/10/57563.html"/>
      <url>/2020/08/10/57563.html</url>
      
        <content type="html"><![CDATA[<p><strong>new</strong> 和 <strong>delete</strong> 是操作符，不能被重载，内部实际调用对应的 operator 函数。</p><p><strong>operator new</strong> 和 <strong>operator delete</strong> 函数有两个重载版本：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// allocate an object</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// allocate an array</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// free an object</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// free an array</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一、new"><a href="#一、new" class="headerlink" title="一、new"></a>一、new</h2><p>new 操作针对数据类型的处理，分为两种情况：</p><h3 id="1-简单数据类型"><a href="#1-简单数据类型" class="headerlink" title="1. 简单数据类型"></a>1. 简单数据类型</h3><p>包括基本数据类型和不需要构造函数的类型。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>汇编代码如下：</p><p><img src="/pic/57563_001.png" alt="new"></p><p>operator new 的源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> __CRTDECL <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token function">_THROW1</span><span class="token punctuation">(</span>_STD bad_alloc<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_callnewh</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">_THROW_NCEE</span><span class="token punctuation">(</span>_XSTD bad_alloc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用 malloc 失败后会调用 _callnewh，如果返回 0 则抛出 bad_alloc 异常；返回非零则继续申请内存。</p><p>这个 _callnewh 是一个 new handler，就是 new 失败的时候调用的回调函数。可以通过 _set_new_handler 来设置。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;new.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">int</span> <span class="token function">my_new_handler</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Allocation failed. Try again\n"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// continue to allocate</span>    <span class="token comment">// return 0;  // stop allocating, throw bad_alloc</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// Set the failure handler for new to be my_new_handler.</span>    <span class="token function">_set_new_handler</span><span class="token punctuation">(</span>my_new_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10000000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 new 基本数据类型的时候还可以指定初始化值：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>简单类型直接调用 operator new 分配内存；</li><li>可以通过 new handler 来处理 new 失败的情况；</li><li>new 分配失败的时候不像 malloc 那样返回 NULL，而是直接抛出异常。要判断是否分配成功应该用异常捕获机制。</li></ul><h3 id="2-复杂数据类型"><a href="#2-复杂数据类型" class="headerlink" title="2. 复杂数据类型"></a>2. 复杂数据类型</h3><p>需要由构造函数初始化的对象。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val_</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> val_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Object<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>汇编码如下：</p><p><img src="/pic/57563_002.png" alt="new"></p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>先调用 operator new，然后在分配的内存上调用构造函数。</p><h2 id="二、delete"><a href="#二、delete" class="headerlink" title="二、delete"></a>二、delete</h2><h3 id="1-简单数据类型-1"><a href="#1-简单数据类型-1" class="headerlink" title="1. 简单数据类型"></a>1. 简单数据类型</h3><p>包括基本数据类型和不需要析构函数的类型。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>汇编码如下：</p><p><img src="/pic/57563_003.png" alt="delete"></p><p>operator delete 的源码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">RTCCALLBACK</span><span class="token punctuation">(</span>_RTC_Free_hook<span class="token punctuation">,</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>RTCCALLBACK 默认是空的宏定义，所以这个函数默认情况下就是简单的调用 free 函数。</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>简单数据类型默认只是调用 free 函数。</p><h3 id="2-复杂数据类型-1"><a href="#2-复杂数据类型-1" class="headerlink" title="2. 复杂数据类型"></a>2. 复杂数据类型</h3><p>需要由析构函数销毁对象。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val_</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>         std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"destroy object"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> val_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Object<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> Object<span class="token punctuation">;</span>    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>部分汇编码如下：</p><p><img src="/pic/57563_004.png" alt="delete"></p><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>复杂数据类型先调用析构函数再调用 operator delete。</p><h2 id="三、new-数组"><a href="#三、new-数组" class="headerlink" title="三、new 数组"></a>三、new 数组</h2><h3 id="1-简单数据类型-2"><a href="#1-简单数据类型-2" class="headerlink" title="1. 简单数据类型"></a>1. 简单数据类型</h3><p>包括基本数据类型和不需要构造函数的类型。</p><p>new[] 调用的是 operator new[]，计算出数组总大小之后调用 operator new。可以通过 () 初始化数组为零值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 等价于</span><span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>针对简单类型，new[] 计算好大小后调用 operator new。</p><h3 id="2-复杂数据类型-2"><a href="#2-复杂数据类型-2" class="headerlink" title="2. 复杂数据类型"></a>2. 复杂数据类型</h3><p>需要由构造函数初始化对象。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val_</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>         std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"destroy object"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> val_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Object<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> Object<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>new[] 先调用 operator new[] 分配内存，然后在 p 的前四个字节写入数组大小，最后调用三次构造函数。</p><p>实际分配的内存块如下：</p><p><img src="/pic/57563_005.png" alt="new"></p><p>数组长度是对象析构时会使用的值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val_</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>         std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"destroy object"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> val_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MyObject</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Object</span></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token operator">~</span><span class="token function">MyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>         std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"destroy MyObject"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> foo_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Object <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> MyObject<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>释放内存之前会调用每个对象的析构函数，但是编译器并不知道 p 实际所指对象的大小。如果没有储存数组大小，编译器如何知道该把 p 所指的内存分为几次来调用析构函数呢？</p><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>针对复杂类型，new[] 会额外存储数组大小。</p><h2 id="四、delete-数组"><a href="#四、delete-数组" class="headerlink" title="四、delete 数组"></a>四、delete 数组</h2><h3 id="1-简单数据类型-3"><a href="#1-简单数据类型-3" class="headerlink" title="1. 简单数据类型"></a>1. 简单数据类型</h3><p>包括基本数据类型和不需要析构函数的类型。delete 和 delete[] 效果一样：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> pNum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">delete</span> pNum<span class="token punctuation">;</span>  <span class="token comment">// 等价于 delete[] pNum;</span><span class="token keyword">char</span><span class="token operator">*</span> pch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pch<span class="token punctuation">;</span>  <span class="token comment">// 等价于 delete pch;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行后不会有什么问题，内存也能被释放。operator delete[] 就是简单的调用 operator delete。</p><p>注意：虽然 delete 和 delete[] 等同，但最好还是 new 与 delete 配对使用。</p><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>针对简单类型，delete 和 delete[] 等同。</p><h3 id="2-复杂数据类型-3"><a href="#2-复杂数据类型-3" class="headerlink" title="2. 复杂数据类型"></a>2. 复杂数据类型</h3><p>需要由析构函数销毁对象，释放内存之前会先调用每个对象的析构函数。</p><p>这时 new[] 分配的内存只能由 delete[] 释放，如果由 delete 释放会崩溃。</p><p><strong>假设指针 p 指向 new[] 分配的内存。因为要 4 字节存储数组大小，实际分配的内存地址为 [p-4]，系统记录的也是这个地址。delete[] 实际释放的就是 p-4 指向的内存。而 delete 会直接释放 p 指向的内存，这个内存根本没有被系统记录，所以会崩溃。</strong></p><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p>针对复杂类型，new[] 出来的内存只能由 delete[] 释放。</p><h2 id="五、malloc-vs-new"><a href="#五、malloc-vs-new" class="headerlink" title="五、malloc() vs new"></a>五、malloc() vs new</h2><table><thead><tr><th>malloc()</th><th>new</th></tr></thead><tbody><tr><td>库函数</td><td>操作符</td></tr><tr><td>申请失败时，返回 NULL</td><td>申请失败时，抛出 bad_alloc 异常</td></tr><tr><td>返回 void*</td><td>返回准确的数据类型</td></tr><tr><td>对于类对象，不调用构造函数</td><td>对于类对象，自动调用构造函数</td></tr><tr><td>申请的内存大小必须手动计算</td><td>申请内存大小由编译器计算</td></tr><tr><td>允许使用 realloc() 更改缓冲区的大小</td><td>不允许</td></tr></tbody></table><h2 id="六、placement-new-x2F-delete"><a href="#六、placement-new-x2F-delete" class="headerlink" title="六、placement new/delete"></a>六、placement new/delete</h2><p>placement new 是 C++ 中的一种变体 new 运算符。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">new</span> <span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> initializer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>普通的 new 运算符做两件事：（1）分配内存、（2）在分配的内存中构造一个对象。</p><p>而 placement new 允许将以上两件事分开。在 placement new 中，可以传递一个预分配的内存并在传递的内存中构造一个对象。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x = "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x addr: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>x <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call placement new on x (new (&amp;x) int(100);)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">*</span> res <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x = "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"res = "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>res <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"res addr: "</span> <span class="token operator">&lt;&lt;</span> res <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><p><img src="/pic/57563_006.png" alt="new"></p><h3 id="1-placement-new-使用时机"><a href="#1-placement-new-使用时机" class="headerlink" title="1. placement new 使用时机"></a>1. placement new 使用时机</h3><p>因为它允许在已经分配的内存上构造一个对象，所以可能存在<strong>需要多次重新构造对象</strong>的情况，因此在这些情况下 placement new 运算符可能更有效。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">String</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">String</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        len_ <span class="token operator">=</span> len<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        len_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span>    size_t len_<span class="token punctuation">;</span>    <span class="token keyword">char</span> str_<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>    <span class="token comment">// 分配所需内存</span>    <span class="token keyword">void</span><span class="token operator">*</span> mem <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 在现有内存块上构造一个 String 对象</span>    String<span class="token operator">*</span> s <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span>mem<span class="token punctuation">)</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>str_<span class="token punctuation">,</span> str<span class="token punctuation">,</span> s<span class="token operator">-&gt;</span>len_<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span>    <span class="token comment">// 当不使用 String 时，在不释放内存的情况下销毁 String 对象</span>    s<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 需要新的 String 时，可以继续在 mem 上构造</span>    <span class="token comment">// ...</span>        <span class="token comment">// 当不需要使用 mem 内存时，释放内存</span>    <span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-删除-placement-new-分配的内存"><a href="#2-删除-placement-new-分配的内存" class="headerlink" title="2. 删除 placement new 分配的内存"></a>2. 删除 placement new 分配的内存</h3><p>对于类对象，需要显示调用类的析构函数。<strong>不可以使用 delete 操作符</strong>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 在现有内存块上构造一个 String 对象</span>String<span class="token operator">*</span> s <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span>mem<span class="token punctuation">)</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>str_<span class="token punctuation">,</span> str<span class="token punctuation">,</span> s<span class="token operator">-&gt;</span>len_<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ...</span><span class="token comment">// 当不使用 String 时，在不释放内存的情况下销毁 String 对象</span>s<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 释放</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++03 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重载、重写、隐藏</title>
      <link href="/2020/08/05/6031.html"/>
      <url>/2020/08/05/6031.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、重载"><a href="#一、重载" class="headerlink" title="一、重载"></a>一、重载</h2><p>重载（overload）是指同一可访问区内被声明的几个具有不同参数列表（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数的返回类型。</p><ol><li>相同的范围（在同一个作用域中）；</li><li>函数名字相同；</li><li>参数列表不同；</li><li>virtual 关键字可有可无；</li><li>返回类型可以不同。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">double</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">double</span> f<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、重写"><a href="#二、重写" class="headerlink" title="二、重写"></a>二、重写</h2><p>重写（override）是指派生类中存在重新定义的函数，也叫覆盖。其函数名、参数列表、返回值类型，都必须同基类中被重写的函数一致，只有函数体不同（花括号内）。派生类调用时会调用派生类的重写函数，不会调用基类的函数。基类中被重写的函数必须有 virtual 修饰，即虚函数。</p><ol><li>不在同一作用域（分别位于派生类与基类）；</li><li>函数名称相同；</li><li>参数列表相同（参数个数和参数类型）；</li><li>基类函数必须有 virtual 关键字，不能有 static；</li><li>返回值类型相同（或是协变），否则报错；</li><li>重写函数的访问修饰符可以不同。尽管 virtual 是 private 的，派生类中重写改写为 public，protected 也是可以的。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"base function"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derived function: Base function overwrite"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、隐藏"><a href="#三、隐藏" class="headerlink" title="三、隐藏"></a>三、隐藏</h2><p>隐藏是指派生类的函数屏蔽了与其同名的基类函数。注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。</p><ol><li>不在同一个作用域（分别位于派生类与基类）；</li><li>函数名字相同；</li><li>返回类型可以不同；</li><li>参数不同，此时不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载混淆）而不是被重写；</li><li>参数相同，但是基类函数没有 virtual 关键字。此时，基类的函数被隐藏。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">// 有 virtual 关键字，参数列表不同 </span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base function_1 with int parameter and virtual"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token keyword">double</span> f<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token comment">// 无 virtual 关键字，参数列表相同</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base function_2 with double parameter and not virtual"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derived function_1 with not parameter hide"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token keyword">double</span> f<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derived function_2 whit double parameter hide"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、区别"><a href="#四、区别" class="headerlink" title="四、区别"></a>四、区别</h2><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><ol><li>范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中；</li><li>参数区别：重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同；</li><li>virtual 的区别：重写的基类必须要有 virtual 修饰，重载函数和被重载函数可以被 virtual 修饰，也可以没有。</li></ol><h3 id="隐藏和重写，重载的区别"><a href="#隐藏和重写，重载的区别" class="headerlink" title="隐藏和重写，重载的区别"></a>隐藏和重写，重载的区别</h3><ol><li>与重载范围不同：隐藏函数和被隐藏函数在不同类中；</li><li>参数的区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定同；当参数不同时，无论基类中的函数是否被 virtual 修饰，基类函数都是被隐藏，而不是被重写。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++03 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强制类型转换</title>
      <link href="/2020/08/02/55.html"/>
      <url>/2020/08/02/55.html</url>
      
        <content type="html"><![CDATA[<p>在 C++ 基本的数据类型中，可以分为四类：整型，浮点型，字符型，布尔型。</p><ol><li>将浮点型数据赋值给整型变量时，舍弃其小数部分；</li><li>将整型数据赋值给浮点型变量时，数值不变，但是以指数形式存储；</li><li>将 double 型数据赋值给 float 型变量时，注意数值范围溢出；</li><li>字符型数据可以赋值给整型变量，此时存入的是字符的 ASCII 码；</li><li>将一个 int，short 或 long 型数据赋值给一个 char 型变量，只将低8位原封不动的送到 char 型变量中；</li><li>将有符号型数据赋值给长度相同的无符号型变量，连同原来的符号位一起传送。</li></ol><p>在 C++ 语言中新增了四个关键字 <strong>static_cast</strong>、<strong>const_cast</strong>、<strong>reinterpret_cast</strong> 和 <strong>dynamic_cast</strong>。这四个关键字都是用于强制类型转换。</p><h2 id="一、static-cast"><a href="#一、static-cast" class="headerlink" title="一、static_cast"></a>一、static_cast</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>static_cast 用于数据类型的强制转换，强制将一种数据类型转换为另一种数据类型，例如将整型数据转换为浮点型数据。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// c 语言所采用的类型转换</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">double</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>a<span class="token operator">/</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>b<span class="token punctuation">;</span><span class="token comment">// static_cast 关键字的使用</span><span class="token keyword">double</span> result <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它主要有以下几种用法：</p><ul><li><p><strong>用于类层次结构中基类和派生类之间指针或引用的转换</strong>；</p><ul><li><strong>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的</strong>；</li><li><strong>进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的</strong>；</li></ul></li><li><p><strong>用于基本数据类型之间的转换，如把 int 转换成 char。安全性由开发人员保证</strong>；</p></li><li><p><strong>把空指针转换成目标类型的空指针</strong>；</p></li><li><p><strong>把任何类型的表达式转换为 void 类型</strong>。</p></li></ul><p>注意：static_cast 不能转换掉 expression 的 const、volitale 或者 __unaligned 属性。</p><p>static_cast：实现 C++ 中内置基本数据类型之间的相互转换。如果涉及到类的话，static_cast 只能在有相互联系的类型中进行相互转换，不一定包含虚函数。</p><h2 id="二、const-cast"><a href="#二、const-cast" class="headerlink" title="二、const_cast"></a>二、const_cast</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用于强制去掉不能被修改的常量特性（去掉 const 属性），但需要特别注意的是 const_cast 不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其<strong>去除常量性的对象必须为指针或引用</strong>。</p><p>该运算符用来修改类型的 const 或 volatile 属性。除了 const 或 volatile 修饰之外，type 和 expression 的类型是一样的。</p><p><strong>常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象。</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 一个错误的例子</span><span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>  <span class="token comment">// compile error</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// compile error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有两个编译错误，第一个编译错误是 *p 具有常量性，其值是不能被修改的；另一处错误是 const_cast 强制转换对象必须为指针或引用，而代码中为一个变量，这是不允许的！</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// const_cast 关键字的使用</span><span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> q <span class="token operator">=</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span>q <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>  <span class="token comment">// a == 20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>了解了 const_cast 的使用场景后，可以知道使用 const_cast 通常是一种无奈之举，同时也建议在 C++ 程序设计过程中一定不要利用 const_cast 去掉指针或引用的常量性并且去修改原始变量的数值，这是一种非常不好的行为。</p><h2 id="三、reinterpret-cast"><a href="#三、reinterpret-cast" class="headerlink" title="三、reinterpret_cast"></a>三、reinterpret_cast</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 C++ 语言中，主要用于三种强制转换：</p><ul><li><strong>改变指针或引用的类型</strong>；</li><li><strong>将指针或引用转换为一个足够长度的整形</strong>；</li><li><strong>将整型转换为指针或引用类型</strong>。</li></ul><p>type 必须是一个指针、引用、算术类型、函数指针或者成员指针。</p><p>它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，再把该整数转换成原类型的指针，还可以得到原先的指针值）。</p><p>在使用 reinterpret_cast 强制转换过程仅仅只是比特位的拷贝，因此在使用过程中需要特别谨慎！</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span class="token keyword">double</span><span class="token operator">*</span> d <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>reinterpret_cast 可以将指针或引用转换为一个足够长度的整形，此中的足够长度具体长度需要多少则取决于操作系统，如果是32位的操作系统，就需要4个字节及以上的整型，如果是64位的操作系统则需要8个字节及以上的整型。</p><h2 id="四、dynamic-cast"><a href="#四、dynamic-cast" class="headerlink" title="四、dynamic_cast"></a>四、dynamic_cast</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>其他三种都是编译时完成的，dynamic_cast 是运行时处理的，运行时要进行类型检查；</li><li>不能用于内置的基本数据类型的强制转换；</li><li>dynamic_cast 转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回 nullptr；</li><li>使用 dynamic_cast 进行转换的，<strong>基类中一定要有虚函数</strong>，否则编译不通过；<ul><li>需要检测有虚函数的原因：类中存在虚函数，就说明它有基类指针或引用指向派生类对象的情况，此时转换才有意义；</li><li>这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表（关于虚函数表的概念，详细可见&lt;Inside c++ object model&gt;）中；</li><li>只有定义了虚函数的类才有虚函数表；</li></ul></li><li>在类的转换时，在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的。在进行下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全；<ul><li>向上转换，即为子类指针指向父类指针（一般不会出问题）；向下转换，即将父类指针转化子类指针；</li><li>向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。</li></ul></li></ol><p>在 C++ 中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。dynamic_cast 操作符则可以在运行期对可能产生问题的类型转换进行测试。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>         std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func1"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>         std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func2"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Derived <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> Base<span class="token punctuation">;</span>  <span class="token comment">// error</span>    p <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Derived<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> Base<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 不安全</span>    p<span class="token operator">-&gt;</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token operator">-&gt;</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主函数中定义的是一个派生类指针，当将其指向一个基类对象时，这是错误的，会导致编译错误。但是通过强制类型转换可以将派生类指针指向一个基类对象，这样的一种强制类型转换是合乎 C++ 语法规定的，但是是非常不明智的，它会带来一定的危险。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//Derived *p = new Base;</span>    Derived<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Derived<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> Base<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token operator">-&gt;</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token operator">-&gt;</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用 dynamic_cast 进行强制类型转换，会转换失败，p 为 nullptr。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++03 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全字符串(window)</title>
      <link href="/2020/08/01/21.html"/>
      <url>/2020/08/01/21.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、strsafe-功能的优点"><a href="#一、strsafe-功能的优点" class="headerlink" title="一、strsafe 功能的优点"></a>一、strsafe 功能的优点</h2><ol><li>始终向函数提供目标缓冲区的大小，以确保函数不会写入缓冲区的末尾；</li><li>即使操作截断预期结果，也保证缓冲区以空值终止；</li><li>所有函数都返回一个 HRESULT 值，只有一个可能的成功代码（S_OK）；</li><li>每个函数都有相应的字符数（”cch”）或字节数（”cb”）版本；</li><li>大多数功能都具有扩展（”Ex”）版本，可用于高级功能。</li></ol><h2 id="二、字符计数功能"><a href="#二、字符计数功能" class="headerlink" title="二、字符计数功能"></a>二、字符计数功能</h2><p>以下函数使用字符计数而不是字节计数。</p><table><thead><tr><th>Function</th><th>Replaces</th></tr></thead><tbody><tr><td>StringCchCat StringCchCatEx</td><td>strcat, wcscat, _tcsat lstrcat StrCat StrCatBuff</td></tr><tr><td>StringCchCatN StringCchCatNEx</td><td>strncatStrNCat</td></tr><tr><td>StringCchCopy StringCchCopyEx</td><td>strcpy, wcscpy, _tcscpylstrcpyStrCpy</td></tr><tr><td>StringCchCopyN StringCchCopyNEx</td><td>strncpy, wcsncpy, _tcsncpy</td></tr><tr><td>StringCchGets StringCchGetsEx</td><td>gets, _getws, _getts</td></tr><tr><td>StringCchPrintf StringCchPrintfEx</td><td>sprintf, swprintf, _stprintf wsprintf wnsprintf _snprintf, _snwprintf, _sntprintf</td></tr><tr><td>StringCchVPrintf StringCchVPrintfEx</td><td>vsprintf, vswprintf, _vstprintf vsnprintf, _vsnwprintf, _vsntprintf wvsprintf wvnsprintf</td></tr><tr><td>StringCchLength</td><td>strlen, wcslen, _tcslen</td></tr></tbody></table><h2 id="三、字节计数功能"><a href="#三、字节计数功能" class="headerlink" title="三、字节计数功能"></a>三、字节计数功能</h2><p>以下函数使用字节计数而不是字符计数。</p><table><thead><tr><th>Function</th><th>Replaces</th></tr></thead><tbody><tr><td>StringCbCat StringCbCatEx</td><td>strcat, wcscat, _tcsat lstrcat StrCat StrCatBuff</td></tr><tr><td>StringCbCatN StringCbCatNEx</td><td>strncat StrNCat</td></tr><tr><td>StringCbCopy StringCbCopyEx</td><td>strcpy, wcscpy, _tcscpy lstrcpy StrCpy</td></tr><tr><td>StringCbCopyN StringCbCopyNEx</td><td>strncpy, wcsncpy, _tcsncpy</td></tr><tr><td>StringCbGets StringCbGetsEx</td><td>gets, _getws, _getts</td></tr><tr><td>StringCbPrintf StringCbPrintfEx</td><td>sprintf, swprintf, _stprintf wsprintf wnsprintf _snprintf, _snwprintf, _sntprintf</td></tr><tr><td>StringCbVPrintf StringCbVPrintfEx</td><td>vsprintf, vswprintf, _vstprintf vsnprintf, _vsnwprintf, _vsntprintf wvsprintf wvnsprintf</td></tr><tr><td>StringCbLength</td><td>strlen, wcslen, _tcslen</td></tr></tbody></table><h2 id="四、使用-strsafe-h"><a href="#四、使用-strsafe-h" class="headerlink" title="四、使用 strsafe.h"></a>四、使用 strsafe.h</h2><ol><li>头文件；</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;strsafe.h&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>在文件中包含 strsafe.h 时，将用 strsafe.h 函数替换旧函数。尝试使用旧函数将导致编译错误，需使用较新的函数。如果要避免此错误，请在包含 strsafe.h 之前包含以下语句；</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">STRSAFE_NO_DEPRECATE</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要仅允许<strong>字符计数</strong>功能，请在包含 strsafe.h 之前包含以下语句。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">STRSAFE_NO_CB_FUNCTIONS</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要仅允许<strong>字节计数</strong>功能，请在包含 strsafe.h 之前包含以下语句。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">STRSAFE_NO_CCH_FUNCTIONS</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：可以单独定义 STRSAFE_NO_CB_FUNCTIONS 或 STRSAFE_NO_CCH_FUNCTIONS，但不能同时定义两者。</p><ol start="3"><li>某些 strsafe 函数具有区域设置感知版本。默认情况下，标头不会声明这些功能。要启用这些声明，请在包含 strsafe.h 之前包含以下宏语句。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">STRSAFE_LOCALE_FUNCTIONS</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>支持的最大字符串长度为 2,147,483,647（STRSAFE_MAX_CCH）个字符，ANSI 或 Unicode。</p><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><p><a href="https://docs.microsoft.com/zh-cn/windows/desktop/menurc/strsafe-ovw">About Strsafe.h</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++03 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神奇的代码</title>
      <link href="/2020/07/16/15749.html"/>
      <url>/2020/07/16/15749.html</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> _<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token number">0</span><span class="token operator">&lt;</span>t<span class="token operator">?</span>t<span class="token operator">&lt;</span><span class="token number">3</span><span class="token operator">?</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">79</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">13</span><span class="token punctuation">,</span>a<span class="token operator">+</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">87</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">-</span>_<span class="token punctuation">,</span>         <span class="token function">main</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">86</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>t<span class="token operator">&lt;</span>_<span class="token operator">?</span><span class="token function">main</span><span class="token punctuation">(</span>t<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>_<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">94</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">27</span><span class="token operator">+</span>t<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>t<span class="token operator">==</span><span class="token number">2</span><span class="token operator">?</span>_<span class="token operator">&lt;</span><span class="token number">13</span><span class="token operator">?</span>         <span class="token function">main</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>_<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"%s %d %d\n"</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token number">9</span><span class="token operator">:</span><span class="token number">16</span><span class="token operator">:</span>t<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">?</span>t<span class="token operator">&lt;</span><span class="token operator">-</span><span class="token number">72</span><span class="token operator">?</span><span class="token function">main</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span>t<span class="token punctuation">,</span>         <span class="token string">"@n'+,#'/*{}w+/w#cdnr/+,{}r/*de}+,/*{*+,/w{%+,/w#q#n+,/#{l+,/n{n+,/+#n+,/#;#q#n+,/+k#;*+,/'r :'d*'3,}{w+K w'K:'+}e#';dq#'l q#'+d'K#!/+k#;q#'r}eKK#}w'r}eKK{nl]'/#;#q#n'){)#}w'){){nl]'/+#n';d}rw' i;# ){nl]!/n{n#'; r{#w'r nc{nl]'/#{l,+'K {rw' iK{;[{nl]'/w#q#n'wk nw' iwk{KK{nl]!/w{%'l##w#' i; :{nl]'/*{q#'ld;r'}{nlwb!/*de}'c ;;{nl'-{}rw]'/+,}##'*}#nc,',#nw]'/+kd'+e}+;#'rdq#w! nr'/ ') }+}{rl#'{n' ')# }'+}##(!!/"</span><span class="token punctuation">)</span>         <span class="token operator">:</span>t<span class="token operator">&lt;</span><span class="token operator">-</span><span class="token number">50</span><span class="token operator">?</span>_<span class="token operator">==</span><span class="token operator">*</span>a<span class="token operator">?</span><span class="token function">putchar</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">65</span><span class="token punctuation">,</span>_<span class="token punctuation">,</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token operator">==</span><span class="token char">'/'</span><span class="token punctuation">)</span><span class="token operator">+</span>t<span class="token punctuation">,</span>_<span class="token punctuation">,</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token operator">:</span><span class="token number">0</span><span class="token operator">&lt;</span>t<span class="token operator">?</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"%s"</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token operator">*</span>a<span class="token operator">==</span><span class="token char">'/'</span><span class="token operator">||</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">61</span><span class="token punctuation">,</span><span class="token operator">*</span>a<span class="token punctuation">,</span>         <span class="token string">"!ek;dc i@bK'(q)-[w]*%n+r3#l,{}:\nuwloca-O;m .vpbks,fxntdCeghiry"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/pic/15749_001.png" alt="输出"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile 关键字</title>
      <link href="/2020/07/16/38250.html"/>
      <url>/2020/07/16/38250.html</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-C" data-language="C"><code class="language-C">int a = 100;while (a == 100) {// code}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这段程序编译时，如果编译器发现程序始终没有企图改变a的值，那它可能就会优化这段代码，变成 while(true) 的死循环使得程序执行的更快，然而这种优化有时候会变成过度优化，编译器有时候可能没有意识到程序会改变 a 的值，却做了这种优化导致程序没有产生预期的行为。</p><p>这里为了产生预期的行为，需要阻止编译器做这种优化，可以<strong>使用 volatile 关键字修饰</strong>。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">volatile int a = 100;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>volatile 关键字和 const 关键字相对应，const 关键字告诉编译器其修饰的变量是只读的，编译器根据只读属性做一些操作，而 volatile 关键字告诉编译器其修饰的变量是易变的，编译器根据易变属性也会做一些操作。volatile 会确保修饰的变量每次的读操作都从内存里读取，每次写操作都将值写到内存里。volatile 关键字就是给编译器做个提示，告诉编译器不要对修饰的变量做过度的优化，提示编译器该变量的值可能会以其它形式被改变。</p><p><strong>volatile 修饰结构体时，结构体内所有成员都是 volatile。</strong></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _TEST{    int data;}Test;volatile Test a;const Test b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Note: volatile is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might be changed by means undetectable by an implementation. See 1.9 for detailed semantics. In general, the semantics of volatile are intended to be the same in C + + as they are in C.</p></blockquote><p>这里大体可以理解为一个对象是 volatile，那对象里所有的成员也都是 volatile。经常听到看到的 CV 修饰词就是 const 和 volatile 关键字。</p><p><strong>volatile 无法保证原子性。</strong></p><p>volatile 只保证内存可见性，不能保证操作是原子的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">volatile int i = 0;i++;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>i++ 相当于 i=i+1，而 i=i+1 其实可以分解为好几步：</p><ol><li>先读取 i 的值到 tmp；</li><li>增加 tmp 的值；</li><li>把 tmp 的值写回到 i 的地址里。</li></ol><p>而 volatile 只能保证内存可见，可以理解为上述三步中的每一步都是原子的，但是三步合起来却不一定是原子的，因为在多线程中三步中间可能插入一些其它操作改变了预期的行为，所以 volatile 不能用在多线程中，多线程中的原子操作还是需要使用 atomic。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间函数</title>
      <link href="/2020/07/15/51612.html"/>
      <url>/2020/07/15/51612.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、clock-函数"><a href="#一、clock-函数" class="headerlink" title="一、clock 函数"></a>一、clock 函数</h2><p>通过 clock 拿到程序执行时处理器所使用的时钟数来计时：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">clock_t</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// clock_t == long</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。也可获取 CPU 所使用的秒数，除以 CLOCKS_PER_SEC 即可。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">clock_t</span> <span class="token class-name">start_t</span> <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%ld 个时钟\n"</span><span class="token punctuation">,</span> <span class="token class-name">start_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token class-name">clock_t</span> <span class="token class-name">end_t</span> <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%ld 个时钟\n"</span><span class="token punctuation">,</span> <span class="token class-name">end_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"循环的秒数：%f\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token class-name">end_t</span> <span class="token operator">-</span> <span class="token class-name">start_t</span><span class="token punctuation">)</span> <span class="token operator">/</span> CLOCKS_PER_SEC<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、time-函数"><a href="#二、time-函数" class="headerlink" title="二、time 函数"></a>二、time 函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">time_t</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token class-name">time_t</span><span class="token operator">*</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// time_t == int64_t</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该函数返回系统的当前时间，返回的是自1970年1月1日以来所经过的秒数，参数一般传空即可。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 获取当前时间戳，单位为秒</span>    <span class="token class-name">time_t</span> now <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lds\n"</span><span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、gettimeofday-函数"><a href="#三、gettimeofday-函数" class="headerlink" title="三、gettimeofday 函数"></a>三、gettimeofday 函数</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">int gettimeofday(struct timeval *tv, struct timezone *tz);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回当前距离1970年的秒数和微妙数，后面的tz是时区，一般不用。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/time.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 获取当前时间戳，单位为秒</span>    <span class="token keyword">struct</span> <span class="token class-name">timeval</span> t<span class="token punctuation">;</span>    <span class="token function">gettimeofday</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lds\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>tv_sec<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取当前时间戳，单位为毫秒</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%ldms\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>tv_sec <span class="token operator">*</span> <span class="token number">1000</span> <span class="token operator">+</span> t<span class="token punctuation">.</span>tv_usec <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、ctime-函数"><a href="#四、ctime-函数" class="headerlink" title="四、ctime 函数"></a>四、ctime 函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">ctime</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">time_t</span><span class="token operator">*</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// day month year hours:minutes:seconds year\n\0。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>显示当前时间，该函数返回一个表示当地时间的字符串指针。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">time_t</span> now <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token operator">*</span> dt <span class="token operator">=</span> <span class="token function">ctime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"cur time is %s\n"</span><span class="token punctuation">,</span> dt<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出：Tue Sep 22 22:01:40 2020</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、localtime-和-gmtime-函数"><a href="#五、localtime-和-gmtime-函数" class="headerlink" title="五、localtime 和 gmtime 函数"></a>五、localtime 和 gmtime 函数</h2><p>可以使用 tm 结构自定义显示当前时间的格式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">tm</span><span class="token operator">*</span> <span class="token function">localtime</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">time_t</span><span class="token operator">*</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将日历时间转换为本地时间，从 1970 年起始的时间戳转换为 1900 年起始的时间数据结构。</p><p>另一个类似的函数是 gmtime 函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">tm</span><span class="token operator">*</span> <span class="token function">gmtime</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">time_t</span><span class="token operator">*</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只是该函数返回的是 UTC 时间，协调世界时（UTC）也被称为格林尼治标准时间（GMT）。</p><p>tm 结构如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">tm</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> tm_sec<span class="token punctuation">;</span>   <span class="token comment">// 秒，正常范围从 0 到 59，但允许至 61  </span>    <span class="token keyword">int</span> tm_min<span class="token punctuation">;</span>   <span class="token comment">// 分，范围从 0 到 59  </span>    <span class="token keyword">int</span> tm_hour<span class="token punctuation">;</span>  <span class="token comment">// 小时，范围从 0 到 23</span>    <span class="token keyword">int</span> tm_mday<span class="token punctuation">;</span>  <span class="token comment">// 一月中的第几天，范围从 1 到 31</span>    <span class="token keyword">int</span> tm_mon<span class="token punctuation">;</span>   <span class="token comment">// 月，范围从 0 到 11 </span>    <span class="token keyword">int</span> tm_year<span class="token punctuation">;</span>  <span class="token comment">// 自 1900 年起的年数 </span>    <span class="token keyword">int</span> tm_wday<span class="token punctuation">;</span>  <span class="token comment">// 一周中的第几天，范围从 0 到 6，从星期日算起 </span>    <span class="token keyword">int</span> tm_yday<span class="token punctuation">;</span>  <span class="token comment">// 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起 </span>    <span class="token keyword">int</span> tm_isdst<span class="token punctuation">;</span> <span class="token comment">// 夏令时</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tm_sec 在 C89 的范围是[0-61]，在 C99 更正为[0-60]。通常范围是[0-59]，貌似有些系统会出现 60 秒的跳跃。</p><p>tm_mon 是从零开始的，所以一月份为0，十二月份为11。</p><p>tm_year 是从1900年开始计算，所以显示年份的时候需要加上1900。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">time_t</span> rawtime <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">tm</span><span class="token operator">*</span> ptminfo <span class="token operator">=</span> <span class="token function">localtime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rawtime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"cur time is: %02d-%02d-%02d %02d:%02d:%02d\n"</span><span class="token punctuation">,</span> ptminfo<span class="token operator">-&gt;</span>tm_year <span class="token operator">+</span> <span class="token number">1900</span><span class="token punctuation">,</span> ptminfo<span class="token operator">-&gt;</span>tm_mon <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> ptminfo<span class="token operator">-&gt;</span>tm_mday<span class="token punctuation">,</span> ptminfo<span class="token operator">-&gt;</span>tm_hour<span class="token punctuation">,</span> ptminfo<span class="token operator">-&gt;</span>tm_min<span class="token punctuation">,</span> ptminfo<span class="token operator">-&gt;</span>tm_sec<span class="token punctuation">)</span><span class="token punctuation">;</span>    ptminfo <span class="token operator">=</span> <span class="token function">gmtime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rawtime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"cur time is: %02d-%02d-%02d %02d:%02d:%02d\n"</span><span class="token punctuation">,</span> ptminfo<span class="token operator">-&gt;</span>tm_year <span class="token operator">+</span> <span class="token number">1900</span><span class="token punctuation">,</span> ptminfo<span class="token operator">-&gt;</span>tm_mon <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> ptminfo<span class="token operator">-&gt;</span>tm_mday<span class="token punctuation">,</span> ptminfo<span class="token operator">-&gt;</span>tm_hour<span class="token punctuation">,</span> ptminfo<span class="token operator">-&gt;</span>tm_min<span class="token punctuation">,</span> ptminfo<span class="token operator">-&gt;</span>tm_sec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 输出：cur time is: 2020-09-23 21:27:37   cur time is: 2020-09-23 13:27:37</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、asctime-函数"><a href="#六、asctime-函数" class="headerlink" title="六、asctime 函数"></a>六、asctime 函数</h2><p>可以通过 asctime 显示 tm 结构的时间：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">asctime</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tm</span><span class="token operator">*</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>和 ctime 类似，返回的都是一个固定时间格式的字符串，只是传入的参数不同。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">time_t</span> rawtime <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">tm</span><span class="token operator">*</span> info <span class="token operator">=</span> <span class="token function">localtime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rawtime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"正常 日期和时间：%s\n"</span><span class="token punctuation">,</span> <span class="token function">asctime</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 正常 日期和时间：Wed Sep 23 21:47:44 2020</span>    info <span class="token operator">=</span> <span class="token function">gmtime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rawtime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"UTC 日期和时间：%s\n"</span><span class="token punctuation">,</span> <span class="token function">asctime</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// UTC 日期和时间：Wed Sep 23 13:47:44 2020</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、strftime-函数"><a href="#七、strftime-函数" class="headerlink" title="七、strftime 函数"></a>七、strftime 函数</h2><p>该函数可用于格式化日期和时间为指定的格式，如果产生的 C 字符串小于 size 个字符（包括空结束字符），则会返回复制到 str 中的字符总数（不包括空结束字符），否则返回零。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">size_t</span> <span class="token function">strftime</span><span class="token punctuation">(</span>    <span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">,</span> <span class="token comment">// 指向目标数组的指针，用来复制产生的C字符串</span>    <span class="token class-name">size_t</span> maxsize<span class="token punctuation">,</span> <span class="token comment">// 最多传出字符数量</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> format<span class="token punctuation">,</span> <span class="token comment">// 格式化方式</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tm</span><span class="token operator">*</span> timeptr <span class="token comment">// tm指针</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>format 格式如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">%a 星期几的缩写%A 星期几的全称%b 月份的缩写%B 月份的全称%c 标准的日期的时间串%C 年份的前两位数字%d 十进制表示的每月的第几天（值从1到31）%D 月/天/年%e 在两字符域中，十进制表示的每月的第几天%F 年-月-日%g 年份的后两位数字，使用基于周的年%G 年份，使用基于周的年%h 简写的月份名%H 24小时制的小时（值从0到23）%I 12小时制的小时（值从1到12）%j 十进制表示的每年的第几天（值从1到366）%m 十进制表示的月份（值从1到12）%M 十时制表示的分钟数（值从0到59）%n 换行符%p 本地的AM或PM的等价显示%r 12小时的时间%R 显示小时和分钟：hh:mm%S 十进制的秒数（值从0到61）%t 水平制表符%T 显示时分秒：hh:mm:ss%u 每周的第几天，星期一为第一天 （值从1到7，星期一为1）%U 第年的第几周，把星期日作为第一天（值从0到53）%V 每年的第几周，使用基于周的年%w 十进制表示的星期几（值从0到6，星期天为0）%W 每年的第几周，把星期一做为第一天（值从0到53）%x 标准的日期串%X 标准的时间串%y 不带世纪的十进制年份（值从0到99）%Y 带世纪部分的十制年份%Z 时区名称，如果不能得到时区名称则返回空字符。%% 一个%符号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">time_t</span> rawtime <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">strftime</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"%Y-%m-%d %H:%M:%S"</span><span class="token punctuation">,</span> <span class="token function">localtime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rawtime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>柔性数组</title>
      <link href="/2020/07/13/63938.html"/>
      <url>/2020/07/13/63938.html</url>
      
        <content type="html"><![CDATA[<p>先看下面的代码，对于包含动态字符串成员的两个结构体 TestA 和 TestB 占用空间分别是多少呢？</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_TEST_A</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token operator">*</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span>TestA<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_TEST_B</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token keyword">char</span> c<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>TestB<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(struct _TEST_A) = %zd\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>TestA<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(struct _TEST_B) = %zd\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>TestB<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在64位系统上，其输出结果为：</p><pre class="line-numbers language-none"><code class="language-none">sizeof(struct _TEST_A) = 16sizeof(struct _TEST_B) = 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于 TestA 的结果是 16，通常没有什么疑问，因为 4(int)+4(int)+8(指针)=16，但是对于 TestB 结构体占用 8 字节，可能会有疑问。</p><h2 id="一、柔性数组（flexible-array）"><a href="#一、柔性数组（flexible-array）" class="headerlink" title="一、柔性数组（flexible array）"></a>一、柔性数组（flexible array）</h2><p>C99 中引入的柔性数组的特性。即结构体的最后一个成员，可以是<strong>不完整类型</strong>（一种缺乏足够的信息去描述一个完整对象的类型）的数组，但它使得整个结构体的大小就像没有这个成员一样。但是，当通过这个名字访问这个成员时，就像访问一个普通数组成员一样。</p><p>如果数组内一个元素都没有的话，那么访问这个数组将会是未定义行为。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_TEST_B</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token keyword">char</span> c<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>TestB<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成员 c 是一个数组，但是并没有指定大小，使用 sizeof 计算 TestB，其占用空间也仅仅是 8 字节。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h4 id="内存申请和释放"><a href="#内存申请和释放" class="headerlink" title="内存申请和释放"></a>内存申请和释放</h4><p>假设分别使用两种类型的结构体，存储 16 字节的字符数据，需要申请内存。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// struct _TEST_A:</span>TestA<span class="token operator">*</span> ta <span class="token operator">=</span> <span class="token punctuation">(</span>TestA<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">_TEST_A</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 为结构体申请内存</span>ta<span class="token operator">-&gt;</span>c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 为成员指向的数据申请内存</span><span class="token comment">// struct _TEST_B:</span>TestB<span class="token operator">*</span> tb <span class="token operator">=</span> <span class="token punctuation">(</span>TestB<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">_TEST_B</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前者需要两次内存申请，而后者只需要一次。前者地址不连续（两次 malloc），后者地址连续。而访问成员 c 的时候，只需要：<code>tb-&gt;c</code>，和普通成员无异。</p><p>对于<strong>内存释放</strong>，前面需要单独释放成员 c 申请的内存，而后者可以一起释放。</p><h4 id="数据拷贝"><a href="#数据拷贝" class="headerlink" title="数据拷贝"></a>数据拷贝</h4><p>由于前面的差别，导致数据拷贝时，也有区别。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// struct _TEST_A：</span>TestA<span class="token operator">*</span> ta_copy<span class="token punctuation">;</span><span class="token comment">// memcpy(ta_copy, ta, sizeof(struct _TEST_A));  // 不可，这样导致 ta_copy 的 c 和 ta 的 c 指向同一片内存区域。（浅拷贝）</span>ta_copy<span class="token operator">-&gt;</span>a <span class="token operator">=</span> ta<span class="token operator">-&gt;</span>a<span class="token punctuation">;</span>ta_copy<span class="token operator">-&gt;</span>b <span class="token operator">=</span> ta<span class="token operator">-&gt;</span>b<span class="token punctuation">;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>ta_copy<span class="token operator">-&gt;</span>c<span class="token punctuation">,</span> ta<span class="token operator">-&gt;</span>c<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里无法一次拷贝，因为它的成员 c 是一个指针类型，需要深拷贝，因此必须拷贝它指向的内存。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// struct _TEST_B:</span>TestB<span class="token operator">*</span> tb_copy<span class="token punctuation">;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>tb_copy<span class="token punctuation">,</span> tb<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">_TEST_B</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于柔性数组的内存，它的数据内容和结构体数据成员的地址是连续的，因此可以直接拷贝。</p><h4 id="减少内存碎片"><a href="#减少内存碎片" class="headerlink" title="减少内存碎片"></a>减少内存碎片</h4><p>由于结构体的柔性数组和结构体成员的地址是连续的，即可一同申请内存，因此更大程度地避免了内存碎片。另外由于该成员本身不占结构体空间，因此，整体而言，比普通的数组成员占用空间要会稍微小点。</p><h2 id="二、零长数组"><a href="#二、零长数组" class="headerlink" title="二、零长数组"></a>二、零长数组</h2><p>与柔性数组功能类似，还有一个 0 长数组，不过它并不是标准中的，但是它可以实现类似的功能，使用方式如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_TEST_C</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token keyword">char</span> c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>TestC<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>差别在于使得数组长度为 0。但是由于它并非 C 标准中的，因此从可移植性考虑，不建议使用这种方式，除非还无法使用 C99。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>柔性数组的使用：</p><ul><li>位于结构体最后一个位置</li><li>不完整数组类型</li><li>不是唯一成员</li></ul><p>普通和柔性数组内存情况：</p><p><img src="/pic/63938_001.png" alt="区别"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宏定义与别名</title>
      <link href="/2020/07/13/47716.html"/>
      <url>/2020/07/13/47716.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、别名"><a href="#一、别名" class="headerlink" title="一、别名"></a>一、别名</h2><ul><li>掩饰符合类型，如指针和数组</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 数组</span><span class="token keyword">char</span> text1<span class="token punctuation">[</span><span class="token number">81</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span> text2<span class="token punctuation">[</span><span class="token number">81</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">char</span> Line<span class="token punctuation">[</span><span class="token number">81</span><span class="token punctuation">]</span><span class="token punctuation">;</span>Line text1<span class="token punctuation">,</span> text2<span class="token punctuation">;</span>  <span class="token comment">// 等同于上面的两个数组</span><span class="token comment">// 指针</span><span class="token keyword">typedef</span> <span class="token keyword">char</span><span class="token operator">*</span> pStr<span class="token punctuation">;</span>pStr p1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>与结构结合使用</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">tagMyStruct</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">long</span> length<span class="token punctuation">;</span><span class="token punctuation">}</span> MyStruct<span class="token punctuation">;</span><span class="token comment">// 等价于</span><span class="token keyword">struct</span> <span class="token class-name">tagMyStruct</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">long</span> length<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">tagMyStruct</span> MyStruct<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析：tagMyStruct 称为“tag”，即“标签”，实际上是一个临时名字，struct 关键字和 tagMyStruct 一起，构成了这个结构类型，不论是否有 typedef，这个结构都存在。</p><p>所以，若没有 typedef，则使用 <code>struct tagMyStruct varName</code> 来定义变量，但要注意，使用 <code>tagMyStruct varName</code> 来定义变量是不对的，因为 struct 和 tagMyStruct 合在一起才能表示一个结构类型。</p><h2 id="二、宏定义"><a href="#二、宏定义" class="headerlink" title="二、宏定义"></a>二、宏定义</h2><ul><li>宏的单行定义</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">A</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  T_</span><span class="token punctuation">##</span><span class="token expression">x</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">B</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  #@x</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">C</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  #x</span></span><span class="token function">A</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 结果: T_1 直接把 1 黏贴上去</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 结果: '1' 把 1 带上单引号后黏贴上去</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 结果: "1" 把 1 带上双引号后黏贴上去</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>条件编译</li></ul><p>在跨平台和系统的软件里，条件编译就很重要了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">WINDOWS</span></span>    <span class="token comment">// 如果 WINDOWS 宏被定义，就执行这里的内容</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">LINUX</span></span>    <span class="token comment">// 如果 LINUX 宏被定义，执行这里的内容</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>    <span class="token comment">// 如果 LINUX 宏没有被定义，执行这里的内容</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>防止头文件被重复编译</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_SOMEFILE_H_</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_SOMEFILE_H_</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>得到指定地址上的一个字节或字</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MEM_B</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>byte<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MEM_W</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>word<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>常用的宏</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token constant">__FILE__</span>  <span class="token comment">// 文件全路径</span>__FUNCTION__  <span class="token comment">// 函数名</span><span class="token constant">__LINE__</span>  <span class="token comment">// 行号</span><span class="token comment">// __FILE__ 过长，可以只获取文件名(运行期)</span><span class="token comment">// windows:</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__FILENAME__</span> <span class="token expression"><span class="token punctuation">(</span><span class="token function">strrchr</span><span class="token punctuation">(</span></span><span class="token string">"\\"</span> <span class="token expression"><span class="token constant">__FILE__</span><span class="token punctuation">,</span> </span><span class="token char">'\\'</span><span class="token expression"><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span><span class="token comment">// linux:</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__FILENAME__</span> <span class="token expression"><span class="token punctuation">(</span><span class="token function">strrchr</span><span class="token punctuation">(</span></span><span class="token string">"/"</span> <span class="token expression"><span class="token constant">__FILE__</span><span class="token punctuation">,</span> </span><span class="token char">'/'</span><span class="token expression"><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span><span class="token comment">// 编译期(未测试)</span><span class="token comment">// 使用 cmake</span><span class="token comment">// set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -D__FILENAME__='"$(notdir $&lt;)"'")</span><span class="token comment">// 使用 makefile</span><span class="token comment">// CXX_FLAGS+=-D__FILENAME__='\"$(subst $(SOURCE_PREFIX)/,,$(abspath $&lt;))\"'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数指针与指针函数</title>
      <link href="/2020/07/10/9437.html"/>
      <url>/2020/07/10/9437.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于 * 的优先级低于 () 的优先级，因此 func 首先和后面的 () 结合，即 func 是一个函数，返回值的类型是 int*。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>pfunc<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(*pfunc) 说明 <strong>pfunc是一个指针</strong>，然后后面跟着 ()，说明这个指针指向一个函数，即指向函数的指针。</p><ul><li><strong>函数指针：</strong>首先是一个指针，这个指针指向一个函数</li><li><strong>指针函数：</strong>首先是一个函数，这个函数的返回值一个指针</li></ul><h2 id="二、声明一个函数指针"><a href="#二、声明一个函数指针" class="headerlink" title="二、声明一个函数指针"></a>二、声明一个函数指针</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>pfunc<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当命名很多个函数指针的时候，用上面的方法显得非常不方便，所以可以这样写：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>PF<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>PF pfunc<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    PF pfunc <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    pfunc <span class="token operator">=</span> add<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"add(3, 4): %d\n"</span><span class="token punctuation">,</span> <span class="token function">pfunc</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pfunc <span class="token operator">=</span> sub<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sub(3, 4): %d\n"</span><span class="token punctuation">,</span> <span class="token function">pfunc</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 输出：</span><span class="token comment">// add(3, 4): 7</span><span class="token comment">// sub(3, 4): -1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h2><h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>f<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>[] 的优先级比 * 的优先级高，所以 f 首先是修饰了数组，然后跟 * 组合，就说明这个数组里面都是指针，这个指针是一个函数，参数类型是 char*，返回值类型是 void。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>f<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> print<span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 输出：</span><span class="token comment">// hello world</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>有个方法：<strong>右左原则</strong>，从 p 开始看，往右走直到遇到 )，再往左走遇到 (，(*p) 就可以看出 p 是一个指针，继续分析往右走，遇到 ()，说明 p 指向一个无参数的函数，往左走，p 指向的函数返回值是 void。</p><p>然后分析 <code>(*(void(*) ())0)();</code></p><ol><li>void(*)()：上面分析了这是一个函数指针，只是把 p 去掉了而已；</li><li>把上面的 void (*)() 用 PN 代替，上面的表达式变成 <code>(*(PN)0)();</code>，PN 后面有一个 0，想一下 (char)a; 这样的表达式，所以 *(PN)0 就是把 0 当成一个地址，强制转换为 PN 类型，用 * 取出这个地址区域的值；</li><li>把 (*(PN)0)() 替换成 PM，原来的表达式变成 PM()，这就是正常的函数调用。</li></ol><h3 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">func3</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    pf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> func1<span class="token punctuation">;</span>  <span class="token comment">// 可以直接用函数名</span>    pf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>func2<span class="token punctuation">;</span> <span class="token comment">// 可以用函数名加上取地址符</span>    pf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>func3<span class="token punctuation">;</span>    pf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token string">"func1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token string">"func2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token string">"func3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数调用方式</title>
      <link href="/2020/07/10/23647.html"/>
      <url>/2020/07/10/23647.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、x86-函数调用约定"><a href="#一、x86-函数调用约定" class="headerlink" title="一、x86 函数调用约定"></a>一、x86 函数调用约定</h2><h3 id="1-cdecl-函数调用约定"><a href="#1-cdecl-函数调用约定" class="headerlink" title="1. __cdecl 函数调用约定"></a>1. __cdecl 函数调用约定</h3><p>__cdecl 是 C Declaration 的缩写，表示 C 语言默认的函数调用方法：所有<strong>参数从右到左依次入栈</strong>，这些<strong>参数由调用者清除</strong>，称为<strong>手动清栈</strong>，返回值存放在 EAX 中。被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">20: int cdecl_sum = cdecl_add(1, 2, 3, 4, 5, 6, 7);00401138   push     70040113A   push     60040113C   push     50040113E   push     400401140   push     300401142   push     200401144   push     100401146   call     @ILT+5(_cdecl_add) (0040100a)0040114B   add      esp,1Ch    # 栈平衡0040114E   mov      dword ptr [ebp-4],eax    # 返回值3:  int __cdecl cdecl_add(int a, int b, int c, int d, int e, int f, int g)4:  {00401030   push     ebp00401031   mov      ebp,esp00401033   sub      esp,44h00401036   push     ebx00401037   push     esi00401038   push     edi00401039   lea      edi,[ebp-44h]0040103C   mov      ecx,11h00401041   mov      eax,0CCCCCCCCh00401046   rep stos   dword ptr [edi]5:  int sum = a+b+c+d+e+f+g;00401048   mov      eax,dword ptr [ebp+8]0040104B   add      eax,dword ptr [ebp+0Ch]0040104E   add      eax,dword ptr [ebp+10h]00401051   add      eax,dword ptr [ebp+14h]00401054   add      eax,dword ptr [ebp+18h]00401057   add      eax,dword ptr [ebp+1Ch]0040105A   add      eax,dword ptr [ebp+20h]0040105D   mov      dword ptr [ebp-4],eax6:  return sum;00401060   mov      eax,dword ptr [ebp-4]   # 存放返回值7:  }00401063   pop      edi00401064   pop      esi00401065   pop      ebx00401066   mov      esp,ebp00401068   pop      ebp00401069   ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-stdcall-函数调用约定"><a href="#2-stdcall-函数调用约定" class="headerlink" title="2. __stdcall 函数调用约定"></a>2. __stdcall 函数调用约定</h3><p>__stdcall 是 Standard Call 的缩写，是 C++ 的标准调用方式：所有<strong>参数从右到左依次入栈</strong>，如果是<strong>调用类成员</strong>的话，最后一个入栈的是 <strong>this</strong> <strong>指针</strong>。这些<strong>参数由被调用的函数在返回后清除</strong>，使用的指令是 retn X，X 表示参数占用的字节数，CPU 在 ret 之后自动弹出 X 个字节的堆栈空间，称为<strong>自动清栈</strong>，返回值存放在 EAX 中。函数在编译的时候就必须确定参数个数，并且调用者必须严格的控制参数的生成，不能多，也不能少，否则返回后会出错。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">21:  int stdcall_sum = stdcall_add(1, 2, 3, 4, 5, 6, 7);00401151   push     700401153   push     600401155   push     500401157   push     400401159   push     30040115B   push     20040115D   push     10040115F   call     @ILT+15(_stdcall_add@28) (00401014)00401164   mov      dword ptr [ebp-8],eax   # 返回值9:   int __stdcall stdcall_add(int a, int b, int c, int d, int e, int f, int g)10:  {00401080   push     ebp00401081   mov      ebp,esp00401083   sub      esp,44h00401086   push     ebx00401087   push     esi00401088   push     edi00401089   lea      edi,[ebp-44h]0040108C   mov      ecx,11h00401091   mov      eax,0CCCCCCCCh00401096   rep stos  dword ptr [edi]11:  int sum = a+b+c+d+e+f+g;00401098   mov      eax,dword ptr [ebp+8]0040109B   add      eax,dword ptr [ebp+0Ch]0040109E   add      eax,dword ptr [ebp+10h]004010A1   add      eax,dword ptr [ebp+14h]004010A4   add      eax,dword ptr [ebp+18h]004010A7   add      eax,dword ptr [ebp+1Ch]004010AA   add      eax,dword ptr [ebp+20h]004010AD   mov      dword ptr [ebp-4],eax12:  return sum;004010B0   mov      eax,dword ptr [ebp-4]   # 存放返回值13:  }004010B3   pop      edi004010B4   pop      esi004010B5   pop      ebx004010B6   mov      esp,ebp004010B8   pop      ebp004010B9   ret      1Ch  # 栈平衡（等价于先 add esp, 1Ch 再 ret）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-pascal-函数调用约定"><a href="#3-pascal-函数调用约定" class="headerlink" title="3. __pascal 函数调用约定"></a>3. __pascal 函数调用约定</h3><p>__pascal 是 Pascal 语言（Delphi）的函数调用方式，也可以在 C/C++ 中使用，<strong>参数从左到右依次入栈</strong>，<strong>清栈方式与 __stdcall 相同</strong>。</p><h3 id="4-fastcall-函数调用约定"><a href="#4-fastcall-函数调用约定" class="headerlink" title="4. __fastcall 函数调用约定"></a>4. __fastcall 函数调用约定</h3><p>__fastcall 是编译器指定的快速调用方式。由于大多数的函数参数个数很少，使用堆栈传递比较费时。因此 __fastcall 通常规定将<strong>前两个（或若干个）参数由寄存器传递</strong>，其余参数还是通过堆栈传递。不同编译器规定的寄存器不同，<strong>清栈方式和 __stdcall 相同</strong>。</p><h3 id="5-thiscall-函数调用约定"><a href="#5-thiscall-函数调用约定" class="headerlink" title="5. __thiscall 函数调用约定"></a>5. __thiscall 函数调用约定</h3><p>__thiscall 是为了解决类成员调用中 this 指针传递而规定的。__thiscall 要求把 this 指针放在特定寄存器中，该寄存器由编译器决定。VC 使用 ecx，Borland 的 C++ 编译器使用 eax。<strong>清栈方式和 __stdcall 相同</strong>。</p><h2 id="二、x64-函数调用约定"><a href="#二、x64-函数调用约定" class="headerlink" title="二、x64 函数调用约定"></a>二、x64 函数调用约定</h2><p>X64 只有一种 __fastcall 函数调用约定。</p><p>普通函数：参数1、参数2、参数3、参数4分别保存在 RCX、RDX、R8D、R9D，剩下的参数从右往左依次入栈，被调用者实现栈平衡，返回值存放在 RAX 中。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># 该代码是 msvc 2017 x64 生成的汇编代码int fastcall_sum = fastcall_add(1, 2, 3, 4, 5, 6, 7);00007FF6577A366E  mov      dword ptr [rsp+30h],700007FF6577A3676  mov      dword ptr [rsp+28h],6 00007FF6577A367E  mov      dword ptr [rsp+20h],5 00007FF6577A3686  mov      r9d,4 00007FF6577A368C  mov      r8d,3 00007FF6577A3692  mov      edx,2 00007FF6577A3697  mov      ecx,1 00007FF6577A369C  call     fastcall_add (07FF6577A11C2h) 00007FF6577A36A1  mov      dword ptr [fastcall_sum],eax  # 返回值int __fastcall fastcall_add(int a, int b, int c, int d, int e, int f, int g){00007FF6D22D1790  mov      dword ptr [rsp+20h],r9d 00007FF6D22D1795  mov      dword ptr [rsp+18h],r8d 00007FF6D22D179A  mov      dword ptr [rsp+10h],edx 00007FF6D22D179E  mov      dword ptr [rsp+8],ecx 00007FF6D22D17A2  push     rbp 00007FF6D22D17A3  push     rdi 00007FF6D22D17A4  sub      rsp,0E8h 00007FF6D22D17AB  mov      rbp,rsp 00007FF6D22D17AE  mov      rdi,rsp 00007FF6D22D17B1  mov      ecx,3Ah 00007FF6D22D17B6  mov      eax,0CCCCCCCCh 00007FF6D22D17BB  rep stos  dword ptr [rdi] 00007FF6D22D17BD  mov      ecx,dword ptr [rsp+108h] int sum = a+b+c+d+e+f+g;00007FF6D22D17C4  mov      eax,dword ptr [b] 00007FF6D22D17CA  mov      ecx,dword ptr [a] 00007FF6D22D17D0  add      ecx,eax 00007FF6D22D17D2  mov      eax,ecx 00007FF6D22D17D4  add      eax,dword ptr [c] 00007FF6D22D17DA  add      eax,dword ptr [d] 00007FF6D22D17E0  add      eax,dword ptr [e] 00007FF6D22D17E6  add      eax,dword ptr [f] 00007FF6D22D17EC  add      eax,dword ptr [g] 00007FF6D22D17F2  mov      dword ptr [sum],eax    return sum;00007FF6D22D17F5  mov      eax,dword ptr [sum]     # 存放返回值}00007FF6D22D17F8  lea      rsp,[rbp+0E8h] 00007FF6D22D17FF  pop      rdi 00007FF6D22D1800  pop      rbp 00007FF6D22D1801  ret                        # 没做栈平衡<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类的成员函数：参数1、参数2、参数3 分别保存在 RDX、R8D、R9D 中，this 指针存放 RCX 中，剩下的参数从右往左依次入栈，被调用者实现栈平衡，返回值存放在 RAX 中。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># 该代码是 msvc 2017 x64 生成的汇编代码int sum = calc.thiscall_add(1, 2, 3, 4, 5, 6, 7);00007FF602E6190F  mov      dword ptr [rsp+38h],7 00007FF602E61917  mov      dword ptr [rsp+30h],6 00007FF602E6191F  mov      dword ptr [rsp+28h],5 00007FF602E61927  mov      dword ptr [rsp+20h],4 00007FF602E6192F  mov      r9d,3 00007FF602E61935  mov      r8d,2 00007FF602E6193B  mov      edx,1 00007FF602E61940  lea      rcx,[calc]          # this指针00007FF602E61944  call     Calc::thiscall_add (07FF602E610A0h) 00007FF602E61949  mov      dword ptr [sum],eax   # 返回值int Calc::thiscall_add(int a, int b, int c, int d, int e, int f, int g){00007FF602E61770  mov      dword ptr [rsp+20h],r9d 00007FF602E61775  mov      dword ptr [rsp+18h],r8d 00007FF602E6177A  mov      dword ptr [rsp+10h],edx 00007FF602E6177E  mov      qword ptr [rsp+8],rcx 00007FF602E61783  push     rbp 00007FF602E61784  push     rdi 00007FF602E61785  sub      rsp,0E8h 00007FF602E6178C  mov      rbp,rsp 00007FF602E6178F  mov      rdi,rsp 00007FF602E61792  mov      ecx,3Ah 00007FF602E61797  mov      eax,0CCCCCCCCh 00007FF602E6179C  rep stos  dword ptr [rdi] 00007FF602E6179E  mov      rcx,qword ptr [rsp+108h]    int sum = a+b+c+d+e+f+g;00007FF602E617A6  mov      eax,dword ptr [b] 00007FF602E617AC  mov      ecx,dword ptr [a] 00007FF602E617B2  add      ecx,eax 00007FF602E617B4  mov      eax,ecx 00007FF602E617B6  add      eax,dword ptr [c] 00007FF602E617BC  add      eax,dword ptr [d] 00007FF602E617C2  add      eax,dword ptr [e] 00007FF602E617C8  add      eax,dword ptr [f] 00007FF602E617CE  add      eax,dword ptr [g] 00007FF602E617D4  mov      dword ptr [sum],eax    return sum;00007FF602E617D7  mov      eax,dword ptr [sum] # 存放返回值}00007FF602E617DA  lea      rsp,[rbp+0E8h]00007FF602E617E1  pop      rdi00007FF602E617E2  pop      rbp00007FF602E617E3  ret                      # 没做栈平衡<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、ARM-x2F-ARM64-函数调用约定"><a href="#三、ARM-x2F-ARM64-函数调用约定" class="headerlink" title="三、ARM/ARM64 函数调用约定"></a>三、ARM/ARM64 函数调用约定</h2><p>ARM 和 ARM64 使用的是 ATPCS（ARM-Thumb Procedure Call Standard/ARM-Thumb 过程调用标准）的函数调用约定。</p><h3 id="1-ARM"><a href="#1-ARM" class="headerlink" title="1. ARM"></a>1. ARM</h3><p>参数1 ~ 参数4 分别保存到 R0 ~ R3 寄存器中，剩下的<strong>参数从右往左依次入栈</strong>，<strong>被调用者实现栈平衡</strong>，返回值存放在 R0 中。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; 该代码是 arm-linux-androideabi-gcc + IDA PRO 生成的反汇编代码.text:00008438            MOV         R3, #5.text:0000843C            STR         R3, [SP].text:00008440            MOV         R3, #6.text:00008444            STR         R3, [SP,#4].text:00008448            MOV         R3, #7.text:0000844C            STR         R3, [SP,#8].text:00008450            MOV         R3, #8.text:00008454            STR         R3, [SP,#12].text:00008458            MOV         R3, #9.text:0000845C            STR         R3, [SP,#16].text:00008460            MOV         R3, #10.text:00008464            STR         R3, [SP,#20].text:00008468            MOV         R0, #1.text:0000846C            MOV         R1, #2.text:00008470            MOV         R2, #3.text:00008474            MOV         R3, #4.text:00008478            BL          add.text:0000847C            STR         R0, [R11,#-8].text:000083C4            EXPORT add.text:000083C4.text:000083C4            STR         R11, [SP,#-4]!.text:000083C8            ADD         R11, SP, #0.text:000083CC            SUB         SP, SP, #0x1C.text:000083D0            STR         R0, [R11,#-16].text:000083D4            STR         R1, [R11,#-20].text:000083D8            STR         R2, [R11,#-24].text:000083DC            STR         R3, [R11,#-28].text:000083E0            LDR         R2, [R11,#-16].text:000083E4            LDR         R3, [R11,#-20].text:000083E8            ADD         R2, R2, R3.text:000083EC            LDR         R3, [R11,#-24].text:000083F0            ADD         R2, R2, R3.text:000083F4            LDR         R3, [R11,#-28].text:000083F8            ADD         R2, R2, R3.text:000083FC            LDR         R3, [R11,#4].text:00008400            ADD         R2, R2, R3.text:00008404            LDR         R3, [R11,#8].text:00008408            ADD         R2, R2, R3.text:0000840C            LDR         R3, [R11,#12].text:00008410            ADD         R3, R2, R3.text:00008414            STR         R3, [R11,#-8].text:00008418            LDR         R3, [R11,#-8].text:0000841C            MOV         R0, R3.text:00008420            SUB         SP, R11, #0.text:00008424            LDR         R11, [SP],#4.text:00008428            BX          LR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-ARM64"><a href="#2-ARM64" class="headerlink" title="2. ARM64"></a>2. ARM64</h3><p>参数1 ~ 参数8 分别保存到 X0 ~ X7 寄存器中 ，剩下的<strong>参数从右往左依次入栈</strong>，<strong>被调用者实现栈平衡</strong>，返回值存放在 X0 中。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; 该代码是 aarch64-linux-android-gcc + IDA PRO 生成的反汇编代码.text:000000000040065C            MOV         W0, #9.text:0000000000400660            STR         W0, [SP].text:0000000000400664            MOV         W0, #10.text:0000000000400668            STR         W0, [SP,#8].text:000000000040066C            MOV         W0, #1.text:0000000000400670            MOV         W1, #2.text:0000000000400674            MOV         W2, #3.text:0000000000400678            MOV         W3, #4.text:000000000040067C            MOV         W4, #5.text:0000000000400680            MOV         W5, #6.text:0000000000400684            MOV         W6, #7.text:0000000000400688            MOV         W7, #8.text:000000000040068C            BL          add.text:0000000000400690            STR         W0, [X29,#28].text:00000000004005E8            EXPORT add.text:00000000004005E8.text:00000000004005E8            SUB         SP, SP, #0x30.text:00000000004005EC            STR         W0, [SP,#28].text:00000000004005F0            STR         W1, [SP,#24].text:00000000004005F4            STR         W2, [SP,#20].text:00000000004005F8            STR         W3, [SP,#16].text:00000000004005FC            STR         W4, [SP,#12].text:0000000000400600            STR         W5, [SP,#8].text:0000000000400604            STR         W6, [SP,#4].text:0000000000400608            STR         W7, [SP].text:000000000040060C            LDR         W1, [SP,#28].text:0000000000400610            LDR         W0, [SP,#24].text:0000000000400614            ADD         W1, W1, W0.text:0000000000400618            LDR         W0, [SP,#20].text:000000000040061C            ADD         W1, W1, W0.text:0000000000400620            LDR         W0, [SP,#16].text:0000000000400624            ADD         W1, W1, W0.text:0000000000400628            LDR         W0, [SP,#12].text:000000000040062C            ADD         W1, W1, W0.text:0000000000400630            LDR         W0, [SP,#8].text:0000000000400634            ADD         W1, W1, W0.text:0000000000400638            LDR         W0, [SP,#4].text:000000000040063C            ADD         W0, W1, W0.text:0000000000400640            STR         W0, [SP,#44].text:0000000000400644            LDR         W0, [SP,#44].text:0000000000400648            ADD         SP, SP, #0x30.text:000000000040064C            RET<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类(Python)</title>
      <link href="/2020/05/14/34796.html"/>
      <url>/2020/05/14/34796.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、类基础"><a href="#一、类基础" class="headerlink" title="一、类基础"></a>一、类基础</h2><h3 id="1-构造方法：-init-函数"><a href="#1-构造方法：-init-函数" class="headerlink" title="1. 构造方法：__init__ 函数"></a>1. 构造方法：__init__ 函数</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'不带参数的__init__方法'</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> param<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'带参数的__init__方法, 参数值为: </span><span class="token interpolation"><span class="token punctuation">{</span>param<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>Test<span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span> <span class="token comment"># 正确</span>Test<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 错误，运行报错</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'类实例化结束'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个类中可定义多个构造方法，但实例化类时只实例化最后的构造方法，即后面的构造方法会覆盖前面的构造方法，并且需要根据最后一个构造方法的形式进行实例化。</p><p>建议：<strong>一个类中只定义一个构造函数</strong>。</p><h3 id="2-类属性和实例属性"><a href="#2-类属性和实例属性" class="headerlink" title="2. 类属性和实例属性"></a>2. 类属性和实例属性</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">:</span>    <span class="token comment"># 类属性</span>    address <span class="token operator">=</span> <span class="token string">'中国'</span>    <span class="token comment"># 构造方法</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 实例属性</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name        self<span class="token punctuation">.</span>age <span class="token operator">=</span> age    <span class="token keyword">def</span> <span class="token function">info</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"name: </span><span class="token interpolation"><span class="token punctuation">{</span>self<span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string">, age: </span><span class="token interpolation"><span class="token punctuation">{</span>self<span class="token punctuation">.</span>age<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token triple-quoted-string string">"""当前这个类中的 self.name 和 self.age 被称之为实例属性只有实例对象能调用的属性被称之为实例属性"""</span><span class="token comment"># 实例对象可以调用类属性与实例属性，但是类只能调用类属性而不能调用实例属性</span><span class="token comment"># 实例对象</span><span class="token keyword">print</span><span class="token punctuation">(</span>Test<span class="token punctuation">(</span><span class="token string">'XXX'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">.</span>address<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>Test<span class="token punctuation">(</span><span class="token string">'XXX'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>Test<span class="token punctuation">(</span><span class="token string">'XXX'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>Test<span class="token punctuation">.</span>address<span class="token punctuation">)</span> <span class="token comment"># 类属性</span><span class="token keyword">print</span><span class="token punctuation">(</span>Test<span class="token punctuation">.</span>age<span class="token punctuation">)</span>  <span class="token comment"># error: 因为类本身是没有权限去使用实例属性的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-访问权限"><a href="#3-访问权限" class="headerlink" title="3. 访问权限"></a>3. 访问权限</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>__name <span class="token operator">=</span> name  <span class="token comment"># 私有变量</span>        self<span class="token punctuation">.</span>__age <span class="token operator">=</span> age  <span class="token comment"># 私有变量</span>    <span class="token keyword">def</span> <span class="token function">__info</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 私有方法</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'name: </span><span class="token interpolation"><span class="token punctuation">{</span>self<span class="token punctuation">.</span>__name<span class="token punctuation">}</span></span><span class="token string">, age: </span><span class="token interpolation"><span class="token punctuation">{</span>self<span class="token punctuation">.</span>__age<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>            <span class="token keyword">def</span> <span class="token function">info</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'name: </span><span class="token interpolation"><span class="token punctuation">{</span>self<span class="token punctuation">.</span>__name<span class="token punctuation">}</span></span><span class="token string">, age: </span><span class="token interpolation"><span class="token punctuation">{</span>self<span class="token punctuation">.</span>__age<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>        stu <span class="token operator">=</span> Test<span class="token punctuation">(</span><span class="token string">'XXX'</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'age: </span><span class="token interpolation"><span class="token punctuation">{</span>stu<span class="token punctuation">.</span>__age<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>  <span class="token comment"># error: 无法访问私有变量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让内部属性不被外部访问，可以在属性名称前加两个下画线（__）。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 可以通过以下方法访问私有变量</span>stu <span class="token operator">=</span> Test<span class="token punctuation">(</span><span class="token string">'XXX'</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token comment"># 直接对私有属性的值进行操作</span><span class="token keyword">print</span><span class="token punctuation">(</span>stu<span class="token punctuation">.</span>_Test__name<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>stu<span class="token punctuation">.</span>_Test__age<span class="token punctuation">)</span>stu<span class="token punctuation">.</span>_Test__info<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实在 python 中声明私有属性的本质其实就是对当前的实例属性的名称进行了一个前缀的装饰。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># __name  -&gt; _类名__name</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-专有方法"><a href="#4-专有方法" class="headerlink" title="4. 专有方法"></a>4. 专有方法</h3><p><strong>__str__<strong>、</strong>__iter__<strong>、</strong>__next__<strong>、</strong>__getattr__<strong>、</strong>__getattr__<strong>、</strong>__call__</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name        self<span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>record <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment"># 用于 python 的 print</span>    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string-interpolation"><span class="token string">f"name: </span><span class="token interpolation"><span class="token punctuation">{</span>self<span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string">"</span></span>    <span class="token comment"># 在 python 交互式环境中使用, 用于输出对象内容</span>    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__str__<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">add_record</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> record<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>record<span class="token punctuation">.</span>append<span class="token punctuation">(</span>record<span class="token punctuation">)</span>        <span class="token comment"># 可迭代对象，用于 for 循环</span>    <span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">return</span> self    <span class="token keyword">def</span> <span class="token function">__next__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        index <span class="token operator">=</span> self<span class="token punctuation">.</span>index        self<span class="token punctuation">.</span>index <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> index <span class="token operator">&gt;=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>record<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> StopIteration        <span class="token keyword">return</span> self<span class="token punctuation">.</span>record<span class="token punctuation">[</span>index<span class="token punctuation">]</span>    <span class="token comment"># 可以获取用户所调用的属性，如果属性不存在，则被 __getattr__ 捕获，并进行下一步操作</span>    <span class="token keyword">def</span> <span class="token function">__getattr__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> name <span class="token operator">==</span> <span class="token string">'address'</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">'北京'</span>    <span class="token comment"># 当类没有实现 __iter__，但是实现了 __getitem__ 方法，也可以作用于 for 循环，不是可迭代对象</span>    <span class="token comment"># 两个都存在，则调用 __iter__ 方法</span>    <span class="token keyword">def</span> <span class="token function">__getitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 默认从 0 开始</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>sorce<span class="token punctuation">[</span>item<span class="token punctuation">]</span>    <span class="token comment"># 如果在实例对象本身打上小括号，代表调用这个类的 __call__ 方法</span>    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"name: </span><span class="token interpolation"><span class="token punctuation">{</span>self<span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token comment"># __str__</span>test <span class="token operator">=</span> Test<span class="token punctuation">(</span><span class="token string">"Test"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span>test<span class="token punctuation">.</span>add_record<span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span>test<span class="token punctuation">.</span>add_record<span class="token punctuation">(</span><span class="token number">99.0</span><span class="token punctuation">)</span>test<span class="token punctuation">.</span>add_record<span class="token punctuation">(</span><span class="token number">60.0</span><span class="token punctuation">)</span><span class="token comment"># __iter__, __next__</span><span class="token keyword">for</span> item <span class="token keyword">in</span> test<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token comment"># __getattr__</span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>address<span class="token punctuation">)</span><span class="token comment"># __call__</span>test<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 斐波那契数列</span><span class="token keyword">class</span> <span class="token class-name">Fib</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>a<span class="token punctuation">,</span> self<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>    <span class="token comment"># 可迭代对象</span>    <span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self  <span class="token comment"># 实例本身就是迭代对象，所以返回自身</span>    <span class="token comment"># 迭代器: 取值方式</span>    <span class="token keyword">def</span> <span class="token function">__next__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>a<span class="token punctuation">,</span> self<span class="token punctuation">.</span>b <span class="token operator">=</span> self<span class="token punctuation">.</span>b<span class="token punctuation">,</span> self<span class="token punctuation">.</span>a <span class="token operator">+</span> self<span class="token punctuation">.</span>b        <span class="token keyword">if</span> self<span class="token punctuation">.</span>a <span class="token operator">&gt;</span> <span class="token number">100000</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> StopIteration <span class="token comment"># 抛出异常</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>a  <span class="token comment"># 返回计算的值</span>fib <span class="token operator">=</span> Fib<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> item <span class="token keyword">in</span> fib<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">DerivedClassName</span><span class="token punctuation">(</span>BaseClassName<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">&lt;</span>statement<span class="token operator">-</span><span class="token number">1</span><span class="token operator">&gt;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token operator">&lt;</span>statement<span class="token operator">-</span>n<span class="token operator">&gt;</span>    <span class="token comment"># 多重继承</span><span class="token keyword">class</span> <span class="token class-name">DerivedClassName</span><span class="token punctuation">(</span>Base1<span class="token punctuation">,</span> Base2<span class="token punctuation">,</span> Base3<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">&lt;</span>statement<span class="token operator">-</span><span class="token number">1</span><span class="token operator">&gt;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token operator">&lt;</span>statement<span class="token operator">-</span>n<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Python 中，继承有以下特点：</p><ol><li>在继承中，基类的构造方法（__init__方法）不会被自动调用，需要在子类的构造方法中专门调用；</li><li>在调用基类的方法时需要加上基类的类名前缀，并带上 self 参数变量。区别于在类中调用普通函数时不需要带 self 参数；</li><li>在 Python 中，首先查找对应类型的方法，如果在子类中找不到对应的方法，才到基类中逐个查找。</li></ol><p>可以通过 <strong>类名.__mro__</strong> 查看当前类的继承顺序。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">play_game</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"父类中的play_game"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">play_game</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>play_game<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 先调用父类被重写的方法</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"子类中的play_game"</span><span class="token punctuation">)</span>  <span class="token comment"># 然后再添加子类需要的新功能</span>sub <span class="token operator">=</span> Sub<span class="token punctuation">(</span><span class="token punctuation">)</span>son<span class="token punctuation">.</span>play_game<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 调用子类中的方法，因为在子类中重写了play_game方法</span><span class="token comment"># 输出</span><span class="token comment"># 父类中的play_game</span><span class="token comment"># 子类中的play_game</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、静态方法"><a href="#三、静态方法" class="headerlink" title="三、静态方法"></a>三、静态方法</h2><p>类中定义的方法是实例方法，即这个方法有一个默认的形参 <code>self</code>，这个 <code>self</code> 会在方法被调用的时候指向对象。</p><p>如果一个方法不写 <code>self</code> 即不需要实例对象的引用，此时在定义方法的时候可以用 <code>@staticmethod</code> 对函数进行修饰，被修饰的函数就可以不写 <code>self</code>。</p><p>被 <code>@staticmethod</code> 修饰的方法，就是<strong>静态方法</strong>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Calculator</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""计算器类"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>num1 <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>num2 <span class="token operator">=</span> <span class="token number">0</span>    <span class="token decorator annotation punctuation">@staticmethod</span>    <span class="token keyword">def</span> <span class="token function">show_menu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"1. 加法"</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"2. 减法"</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"3. 乘法"</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"4. 除法"</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"5. 退出"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">get_nums</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>num1 <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入第1个数:"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>num2 <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入第2个数:"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>num1 <span class="token operator">+</span> self<span class="token punctuation">.</span>num2<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>num1 <span class="token operator">-</span> self<span class="token punctuation">.</span>num2<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">mul</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>num1 <span class="token operator">*</span> self<span class="token punctuation">.</span>num2<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">div</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>num1 <span class="token operator">/</span> self<span class="token punctuation">.</span>num2<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>show_menu<span class="token punctuation">(</span><span class="token punctuation">)</span>            op <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入要进行的操作:"</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> op <span class="token operator">==</span> <span class="token string">"1"</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>get_nums<span class="token punctuation">(</span><span class="token punctuation">)</span>                self<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">elif</span> op <span class="token operator">==</span> <span class="token string">"2"</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>get_nums<span class="token punctuation">(</span><span class="token punctuation">)</span>                self<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">elif</span> op <span class="token operator">==</span> <span class="token string">"3"</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>get_nums<span class="token punctuation">(</span><span class="token punctuation">)</span>                self<span class="token punctuation">.</span>mul<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">elif</span> op <span class="token operator">==</span> <span class="token string">"4"</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>get_nums<span class="token punctuation">(</span><span class="token punctuation">)</span>                self<span class="token punctuation">.</span>div<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">elif</span> op <span class="token operator">==</span> <span class="token string">"5"</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>cal <span class="token operator">=</span> Calculator<span class="token punctuation">(</span><span class="token punctuation">)</span>cal<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、类方法"><a href="#四、类方法" class="headerlink" title="四、类方法"></a>四、类方法</h2><p>为了更好的对<strong>类属性</strong>进行操作，Python 中提供了另外一种方法<strong>类方法</strong>。</p><p>如果想要让一个方法成为<strong>类方法</strong>，只需要在这个方法的前面添加 <code>@classmethod</code> 即可，与此同时需要在方法的第1个形参位置添加 <code>cls</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> 类名<span class="token punctuation">:</span>    <span class="token decorator annotation punctuation">@classmethod</span>    <span class="token keyword">def</span> 类方法名<span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例</strong>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Tool</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    tools_num <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 定义一个类属性，用来存储共享的数据</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name        Tool<span class="token punctuation">.</span>tools_num <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">info1</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"工具的总数为："</span><span class="token punctuation">,</span> Tool<span class="token punctuation">.</span>tools_num<span class="token punctuation">)</span>    <span class="token decorator annotation punctuation">@classmethod</span>    <span class="token keyword">def</span> <span class="token function">info2</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"工具的总数为："</span><span class="token punctuation">,</span> cls<span class="token punctuation">.</span>tools_num<span class="token punctuation">)</span>tieqiao <span class="token operator">=</span> Tool<span class="token punctuation">(</span><span class="token string">"铁锹"</span><span class="token punctuation">)</span>chutou <span class="token operator">=</span> Tool<span class="token punctuation">(</span><span class="token string">"锄头"</span><span class="token punctuation">)</span>diancilu <span class="token operator">=</span> Tool<span class="token punctuation">(</span><span class="token string">"电磁炉"</span><span class="token punctuation">)</span>tieqiao<span class="token punctuation">.</span>info1<span class="token punctuation">(</span><span class="token punctuation">)</span>tieqiao<span class="token punctuation">.</span>info2<span class="token punctuation">(</span><span class="token punctuation">)</span>diancilu<span class="token punctuation">.</span>info1<span class="token punctuation">(</span><span class="token punctuation">)</span>diancilu<span class="token punctuation">.</span>info2<span class="token punctuation">(</span><span class="token punctuation">)</span>Tool<span class="token punctuation">.</span>info2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 输出：</span><span class="token comment"># 工具的总数为： 3</span><span class="token comment"># 工具的总数为： 3</span><span class="token comment"># 工具的总数为： 3</span><span class="token comment"># 工具的总数为： 3</span><span class="token comment"># 工具的总数为： 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结</strong>：</p><ul><li>定义类方法时，前面添加 <code>@classmethod</code>；</li><li>类方法的第1个形参，一般都叫做 <code>cls</code>（任意名字，但一般都用<code>cls</code>）;</li><li>调用类方法的时候，可以用<strong>实例对象</strong>、<strong>类对象</strong>调用，但无论用哪种方式调用，类方法中的 <code>cls</code> 指向类对象。</li></ul><h2 id="五、动态绑定"><a href="#五、动态绑定" class="headerlink" title="五、动态绑定"></a>五、动态绑定</h2><h3 id="1-运行时-对象-添加属性"><a href="#1-运行时-对象-添加属性" class="headerlink" title="1. 运行时 对象 添加属性"></a>1. 运行时 对象 添加属性</h3><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Person(object):    def __init__(self, name=None, age=None):        self.name = name        self.age = agep = Person("Bob", 20)p.sex = 'male'print(p.sex)  # 输出：male<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义的类里面没有 <code>sex</code> 这个属性啊！这就是动态语言的魅力和坑！</p><p>这里实际上就是<strong>动态给实例绑定属性</strong>！</p><h3 id="2-运行时-类-添加属性"><a href="#2-运行时-类-添加属性" class="headerlink" title="2. 运行时 类 添加属性"></a>2. 运行时 类 添加属性</h3><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">p1 = Person("Alice", 25)print(p1.sex)  # error: Person object has no attribute 'sex'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>尝试输出<code>p1.sex</code>，发现报错，<code>p1</code>没有<code>sex</code>这个属性！—— 给<code>p</code>这个实例绑定属性对<code>p1</code>这个实例不起作用。</p><p>需要直接给<code>Person</code>类绑定属性。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">Person.sex = None  # 给类Person添加一个属性p1 = Person("Alice", "25")print(p1.sex)  # 输出：None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-运行时-对象-添加方法"><a href="#3-运行时-对象-添加方法" class="headerlink" title="3. 运行时 对象 添加方法"></a>3. 运行时 对象 添加方法</h3><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Person(object):    def __init__(self, name=None, age=None):        self.name = name        self.age = age    def eat(self):        print("eat food")def run(self, speed):    print("%s moving, speed is %dkm/h" % (self.name, speed))p = Person("Bob", 20)p.eat()  # 输出: eat foodp.run(50)  # error: Person object has no attribute 'run'import typesp.run = types.MethodType(run, p)p.run(60)  # 输出: Bob moving, speed is 60km/h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import typesclass Person(object):    num = 0    def __init__(self, name=None, age=None):        self.name = name        self.age = age        def eat(self):        print("eat food")def run(self, speed):    print("%s moving, speed is %dkm/h" % (self.name, speed))# 类方法@classmethoddef test_class(cls):    print("----class method----")    print("num=%d" % cls.num)    cls.num = 100    print("num=%d" % cls.num)# 静态方法@staticmethoddef test_static():    print("---static method----")# 创建一个实例对象p = Person("Bob", 20)p.eat()# 添加实例方法p.run = types.MethodType(run, p)p.run(180)# 添加类方法Person.test_class = test_classPerson.test_class()# 添加静态方法Person.test_static = test_staticPerson.test_static()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-运行时删除属性与方法"><a href="#4-运行时删除属性与方法" class="headerlink" title="4. 运行时删除属性与方法"></a>4. 运行时删除属性与方法</h3><p>删除的方法:</p><ol><li><code>del 对象.属性名</code></li><li><code>delattr(对象, "属性名")</code></li></ol><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ol><li>Python可以在运行的过程中，修改程序的运行结构，例如可以修改调用的函数等；</li><li>对象中一切皆属性，方法也是属性，只不过这个可以进行调用而已，例如<code>实例对象名.属性名()</code>。</li></ol><p>那么怎么避免这种情况呢？ 请使用<code>__slots__</code></p><h2 id="六、-slots"><a href="#六、-slots" class="headerlink" title="六、_slots_"></a>六、<em>_slots</em>_</h2><p>动态语言：可以在运行的过程中，修改代码。</p><p>静态语言：编译时已经确定好代码，运行过程中不能修改。</p><p>如果想要限制实例的属性怎么办？比如，只允许对<code>Person</code>实例添加<code>name</code>和<code>age</code>属性。</p><h3 id="1-限制属性的创建"><a href="#1-限制属性的创建" class="headerlink" title="1. 限制属性的创建"></a>1. 限制属性的创建</h3><p>为了达到限制的目的，在定义类的时候，定义一个特殊的 <code>__slots__</code> 属性，来限制该类创建的实例对象可以添加的属性。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Person(object):    __slots__ = ("name", "age")p = Person()p.name = "Bob"  # okp.age = 20  # okp.sex = "male"  # error: 'Person' object has no attribute 'sex'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2. 注意事项"></a>2. 注意事项</h3><ul><li>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的</li></ul><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Test(Person):    passt = Test()t.sex = "male"print(t.sex)  # 输出：male<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、property-属性"><a href="#七、property-属性" class="headerlink" title="七、property 属性"></a>七、property 属性</h2><h3 id="1-property"><a href="#1-property" class="headerlink" title="1. @property"></a>1. @property</h3><p>一种用起来像是使用的实例属性一样的特殊属性，可以对应于某个方法。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Test:    def func(self):        pass    @property    def prop(self):        pass    @property    def car(self):        return "UU"    test = Test()test.func()  # 调用实例方法test.prop  # 调用 property 属性print(test.car)  # 输出 UU<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>property 属性的定义和调用要注意一下几点：</p><ul><li>定义时，在实例方法的基础上添加 @property 装饰器；并且仅有一个 self 参数</li><li>调用时，无需括号</li></ul><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Pager:    def __init__(self, current_page):        # 用户当前请求的页码（第一页、第二页...）        self.current_page = current_page        # 每页默认显示10条数据        self.per_items = 10    @property    def start(self):        val = (self.current_page - 1) * self.per_items        return val    @property    def end(self):        val = self.current_page * self.per_items        return valp = Pager(1)print(p.start)  # 就是起始值print(p.end)  # 就是结束值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>property 属性的功能是：property 属性内部进行一系列的逻辑计算，最终将计算结果返回。</p><h3 id="3-property-属性的两种方式"><a href="#3-property-属性的两种方式" class="headerlink" title="3. property 属性的两种方式"></a>3. property 属性的两种方式</h3><ul><li>装饰器：在方法上应用装饰器</li><li>类属性：在类中定义值为 property 对象的类属性</li></ul><h4 id="3-1-装饰器方式"><a href="#3-1-装饰器方式" class="headerlink" title="3.1 装饰器方式"></a>3.1 装饰器方式</h4><p>在类的实例方法上应用@property装饰器，Python中的类有<strong>经典类</strong>和<strong>新式类</strong>，新式类的属性比经典类的属性丰富（ 如果类继object，那么该类是新式类 ）。</p><h5 id="经典类：只有一种-property装饰器："><a href="#经典类：只有一种-property装饰器：" class="headerlink" title="经典类：只有一种@property装饰器："></a>经典类：只有一种@property装饰器：</h5><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Goods:    @property    def price(self):        return 100obj = Goods()result = obj.price  # 自动执行 @property 修饰的 price 方法，并获取方法的返回值print(result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="新式类：具有三种-property装饰器"><a href="#新式类：具有三种-property装饰器" class="headerlink" title="新式类：具有三种@property装饰器"></a>新式类：具有三种@property装饰器</h5><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Goods(object):    def __init__(self):        self.value = 100    @property    def price(self):        print('get price')        return self.value    @price.setter    def price(self, value):        print('set price')        self.value = value    @price.deleter    def price(self):        print('del price')obj = Goods()print(obj.price)   # 自动执行 @property 修饰的 price 方法，并获取方法的返回值obj.price = 123    # 自动执行 @price.setter 修饰的 price 方法，并将 123 赋值给方法的参数del obj.price      # 自动执行 @price.deleter 修饰的 price 方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于新式类中具有三种访问方式，可以根据它们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Goods(object):    def __init__(self):        # 原价        self.original_price = 100        # 折扣        self.discount = 0.8    @property    def price(self):        new_price = self.original_price * self.discount        return new_price    @price.setter    def price(self, value):        self.original_price = value    @price.deleter    def price(self):        del self.original_priceobj = Goods()print(obj.price)  # 获取商品价格obj.price = 200  # 修改商品原价print(obj.price)del obj.price  # 删除商品原价# 当前属性被删除之后再获取则报错# print(obj.price)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-类属性方式"><a href="#3-2-类属性方式" class="headerlink" title="3.2 类属性方式"></a>3.2 类属性方式</h4><p>创建值为 property 对象的类属性。当使用类属性的方式创建 property 属性时，经典类和新式类无区别。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Goods:    def get_price(self):        return 100    price = property(get_price)obj = Goods()result = obj.price  # 自动调用get_price方法，并获取方法的返回值print(result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>property 方法中有个四个参数</p><ul><li>第一个参数是方法名，调用 对象.属性 时自动触发执行方法；</li><li>第二个参数是方法名，调用 对象.属性 ＝ XXX 时自动触发执行方法；</li><li>第三个参数是方法名，调用 del 对象.属性 时自动触发执行方法；</li><li>第四个参数是字符串，调用 对象.属性.<em>_doc</em>_ ，此参数是该属性的描述信息。</li></ul><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Goods(object):    def __init__(self):        # 原价        self.original_price = 100        # 折扣        self.discount = 0.8    def get_price(self):        new_price = self.original_price * self.discount        return new_price    def set_price(self, value):        """必须两个参数"""        self.original_price = value    def del_price(self):        del self.original_price    price = property(get_price, set_price, del_price, "book price")obj = Goods()print(obj.price)  # 获取商品价格，调用 get_priceobj.price = 200  # 修改商品原价，调用 set_priceprint(obj.price)print(Goods.price.__doc__)  # 自动获取第四个参数中设置的值：goods pricedel obj.price  # 删除商品原价，调用 del_price# 当前属性被删除之后再获取则报错# print(obj.price)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-应用"><a href="#4-应用" class="headerlink" title="4. 应用"></a>4. 应用</h3><ul><li>私有属性添加 getter 和 setter 方法</li></ul><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Goods(object):    def __init__(self):        # 原价        self.original_price = 100        # 折扣        self.discount = 0.8    def get_price(self):        new_price = self.original_price * self.discount        return new_price    def set_price(self, value):        self.original_price = valuebook = Goods()print(book.get_price())book.set_price(50)print(book.get_price())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用 property 升级 getter 和 setter 方法</li></ul><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Goods(object):    def __init__(self):        # 原价        self.__original_price = 100        # 折扣        self.__discount = 0.8    def get_price(self):        new_price = self.__original_price * self.__discount        return new_price    def set_price(self, value):        self.__original_price = value    price = property(get_price, set_price)book = Goods()print(book.price)book.price = 50print(book.price)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰器(Python)</title>
      <link href="/2020/03/25/28090.html"/>
      <url>/2020/03/25/28090.html</url>
      
        <content type="html"><![CDATA[<p>由于函数也是一个对象，而且函数对象可以被赋值给变量，通过变量也能调用该函数。函数对象有一个 __name__ 属性，可以得到函数的名字。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'2020-03-25'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>假设要增强 now 函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改 now 函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。本质上，decorator 是一个返回函数的高阶函数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">log</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'call %s():'</span> <span class="token operator">%</span> func<span class="token punctuation">.</span>__name__<span class="token punctuation">)</span>        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>观察上面的 log，因为它是一个 decorator，所以接受一个函数作为参数，并返回一个函数。借助 Python 的 @ 语法，把 decorator 置于函数的定义处：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">log</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># ...</span><span class="token decorator annotation punctuation">@log</span><span class="token keyword">def</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'2020-03-25'</span><span class="token punctuation">)</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># call now():  2020-03-25</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在调用 now() 函数，不仅会运行 now() 函数，还会在运行 now() 函数前打印一行日志。把 @log 放到 now() 函数的定义处，相当于执行了语句：now = log(now)</p><p>由于 log() 是一个 decorator，返回一个函数，所以，原来的 now() 函数仍然存在，只是现在同名的 now 变量指向了新的函数，于是调用 now() 将执行新函数，即在 log() 函数中返回的 wrapper() 函数。</p><p>wrapper() 函数的参数定义是 (*args, **kw)，因此，wrapper() 函数可以接受任意参数的调用。如果 decorator 本身需要传入参数，那就需要编写一个返回 decorator 的高阶函数，写出来会更复杂。比如，要自定义 log 的文本：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">log</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%s %s():'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>text<span class="token punctuation">,</span> func<span class="token punctuation">.</span>__name__<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span>        <span class="token keyword">return</span> wrapper    <span class="token keyword">return</span> decorator<span class="token decorator annotation punctuation">@log</span><span class="token punctuation">(</span><span class="token string">"execute"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'2020-03-25'</span><span class="token punctuation">)</span>    now<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># execute now()   2020-03-25</span>now<span class="token punctuation">.</span>__name__  <span class="token comment"># wrapper</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和两层嵌套的 decorator 相比，3层嵌套是这样的：now = log(‘execute’)(now)。</p><p>首先执行 log(‘execute’)，返回的是 decorator 函数，再调用返回的函数，参数是 now 函数，返回值最终是 wrapper 函数。</p><p>以上两种 decorator 的定义都没有问题，但还差最后一步。因为函数有 __name__ 等属性，但经过 decorator 装饰之后的函数，它们的 __name__ 已经从原来的 ‘now’ 变成了 ‘wrapper’。</p><p>因为返回的那个 wrapper() 函数名字就是 ‘wrapper’，所以，需要把原始函数的 __name__ 等属性复制到 wrapper() 函数中，否则，有些依赖函数签名的代码执行就会出错。</p><p>不需要编写 wrapper.__name__ = func.__name__，Python 内置的 functools.wraps 就可以解决，所以，一个完整的 decorator 的写法如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> functools<span class="token keyword">def</span> <span class="token function">log</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token decorator annotation punctuation">@functools<span class="token punctuation">.</span>wraps</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%s %s():'</span> <span class="token operator">%</span><span class="token punctuation">(</span>text<span class="token punctuation">,</span> func<span class="token punctuation">.</span>__name__<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span>        <span class="token keyword">return</span> wrapper    <span class="token keyword">return</span> decorator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>列表生成式(Python)</title>
      <link href="/2020/03/25/37733.html"/>
      <url>/2020/03/25/37733.html</url>
      
        <content type="html"><![CDATA[<p>列表生成式即 List Comprehensions，是 Python 内置的非常简单却强大的可以用来创建 list 的生成式。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">[</span> x<span class="token operator">*</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span> <span class="token punctuation">]</span> <span class="token comment"># 结果 [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>写列表生成式时，把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把 list 创建出来。for 循环后面还可以加上 if 判断：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">[</span> x<span class="token operator">*</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">if</span> x<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token comment"># 两层循环</span><span class="token punctuation">[</span> m<span class="token operator">+</span>n <span class="token keyword">for</span> m <span class="token keyword">in</span> <span class="token string">'ABC'</span> <span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token string">'XYZ'</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token punctuation">[</span> d <span class="token keyword">for</span> d <span class="token keyword">in</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>for 循环可以同时使用两个甚至多个变量，比如 dict 的 items() 可以同时迭代 key 和 value，因此，列表生成式也可以使用两个变量来生成 list：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">:</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'z'</span><span class="token punctuation">:</span> <span class="token string">'C'</span><span class="token punctuation">}</span><span class="token punctuation">[</span> k<span class="token operator">+</span><span class="token string">'='</span><span class="token operator">+</span>v <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">]</span><span class="token comment"># 将字符串变成小写</span>L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Hello'</span><span class="token punctuation">,</span> <span class="token string">'World'</span><span class="token punctuation">,</span> <span class="token string">'IBM'</span><span class="token punctuation">,</span> <span class="token string">"Apple"</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> s <span class="token keyword">in</span> L<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="/2020/03/24/6786.html"/>
      <url>/2020/03/24/6786.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、书写"><a href="#一、书写" class="headerlink" title="一、书写"></a>一、书写</h2><p>通常在文件开头写上：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/user/bin/env python3</span><span class="token comment"># _*_ coding: utf-8 _*_</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="二、关键字"><a href="#二、关键字" class="headerlink" title="二、关键字"></a>二、关键字</h2><p>Python3 查看 python 关键字</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> keyword<span class="token keyword">print</span><span class="token punctuation">(</span>keyword<span class="token punctuation">.</span>kwlist<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="三、链式比较"><a href="#三、链式比较" class="headerlink" title="三、链式比较"></a>三、链式比较</h2><p>Python 支持链式比较，如 3 &lt; 4 &lt; 5 这种就叫链式比较，相当于 3 &lt; 4 and 4 &lt; 5。</p><h2 id="四、条件"><a href="#四、条件" class="headerlink" title="四、条件"></a>四、条件</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>score<span class="token operator">=</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> score <span class="token operator">&lt;</span> <span class="token number">60</span><span class="token punctuation">:</span>        level <span class="token operator">=</span> <span class="token string">'D'</span>    <span class="token keyword">elif</span> <span class="token number">60</span> <span class="token operator">&lt;=</span> score <span class="token operator">&lt;</span> <span class="token number">80</span><span class="token punctuation">:</span>        level <span class="token operator">=</span> <span class="token string">'C'</span>    <span class="token keyword">elif</span> <span class="token number">80</span> <span class="token operator">&lt;=</span> score <span class="token operator">&lt;</span> <span class="token number">90</span><span class="token punctuation">:</span>        level <span class="token operator">=</span> <span class="token string">'B'</span>    <span class="token keyword">elif</span> score <span class="token operator">&gt;=</span> <span class="token number">90</span><span class="token punctuation">:</span>        level <span class="token operator">=</span> <span class="token string">'A'</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        level <span class="token operator">=</span> <span class="token string">'E'</span>    <span class="token keyword">return</span> leveltest<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token comment"># 条件成立时执行的语句 if condition else 条件不成立时执行的语句</span>score <span class="token operator">=</span> <span class="token number">50</span>level <span class="token operator">=</span> <span class="token string">'D'</span> <span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> score <span class="token operator">&lt;</span> <span class="token number">60</span> <span class="token keyword">else</span> <span class="token string">'C'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、循环"><a href="#五、循环" class="headerlink" title="五、循环"></a>五、循环</h2><p>当循环条件<strong>不再</strong>为真的时候，else 语句才会被执行。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">while</span> condition<span class="token punctuation">:</span><span class="token comment"># 条件成立时执行</span><span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment"># 条件不成立时执行</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> add<span class="token punctuation">:</span>    <span class="token comment"># 条件成立时执行</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token comment"># 条件不成立时执行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与 break 结合使用：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> ss<span class="token punctuation">:</span>        <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token string">','</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>  <span class="token comment"># 终止循环</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n执行 else 语句"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n执行循环体外语句"</span><span class="token punctuation">)</span>x <span class="token operator">=</span> <span class="token string">"abcdefghijl,asdf"</span>test<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token comment"># 输出：</span><span class="token comment"># abcdefghijl</span><span class="token comment"># 执行循环体外语句</span>x <span class="token operator">=</span> <span class="token string">"abcdefghijlasdf"</span>test<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token comment"># 输出：</span><span class="token comment"># abcdefghijlasdf</span><span class="token comment"># 执行 else 语句</span><span class="token comment"># 执行循环体外语句</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、元组"><a href="#六、元组" class="headerlink" title="六、元组"></a>六、元组</h2><p>所谓的元组无法修改值的本质是不能修改当前这个值的引用。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当前元组中的第一个元素在内存中已经保存了，元组中的索引指向了这个元素。因为当前的元组中嵌套了列表，也就是说索引所指向的这个值是一个列表类型，所以可以对当前这个列表中的元素进行修改，因为修改完之后还是列表类型。</p><h2 id="七、断言"><a href="#七、断言" class="headerlink" title="七、断言"></a>七、断言</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> <span class="token number">3</span><span class="token keyword">assert</span> x <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'x is not zero or negative'</span><span class="token keyword">assert</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'x is not an even number'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="八、is-关键字"><a href="#八、is-关键字" class="headerlink" title="八、is 关键字"></a>八、is 关键字</h2><p>身份运算符（is，is not），类似于 C 的指针比较。判断两个标识符是否引用自一个对象。</p><h2 id="九、函数参数"><a href="#九、函数参数" class="headerlink" title="九、函数参数"></a>九、函数参数</h2><p>调用函数时可以使用以下参数类型：</p><ol><li>位置参数</li><li>默认参数</li><li>可变参数（*args），接收的是一个 tuple</li><li>关键字参数（*kwargs），接收的是一个 dict</li></ol><p>这 4 种参数可以组合使用。注意定义参数的顺序必须是<strong>位置参数、默认参数、可变参数、命名关键字参数、关键字参数</strong>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> city<span class="token operator">=</span><span class="token string">'北京'</span><span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'name=</span><span class="token interpolation"><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span><span class="token string">, age=</span><span class="token interpolation"><span class="token punctuation">{</span>age<span class="token punctuation">}</span></span><span class="token string">, city=</span><span class="token interpolation"><span class="token punctuation">{</span>city<span class="token punctuation">}</span></span><span class="token string">, args=</span><span class="token interpolation"><span class="token punctuation">{</span>args<span class="token punctuation">}</span></span><span class="token string">, kwargs=</span><span class="token interpolation"><span class="token punctuation">{</span>kwargs<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>year <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2017</span><span class="token punctuation">,</span><span class="token number">2018</span><span class="token punctuation">]</span>detail <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'sex'</span><span class="token punctuation">:</span><span class="token string">'man'</span><span class="token punctuation">,</span><span class="token string">'interset'</span><span class="token punctuation">:</span><span class="token string">'coding'</span><span class="token punctuation">}</span>test<span class="token punctuation">(</span><span class="token string">'XXX'</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span>test<span class="token punctuation">(</span><span class="token string">'XXX'</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token string">'中国'</span><span class="token punctuation">,</span><span class="token operator">*</span>year<span class="token punctuation">,</span><span class="token operator">**</span>detail<span class="token punctuation">)</span><span class="token comment"># 输出：</span><span class="token comment"># name=XXX, age=20, city=北京, args=(), kwargs={}</span><span class="token comment"># name=XXX, age=20, city=中国, args=(2017, 2018), kwargs={'sex': 'man', 'interset': 'coding'}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十、异常"><a href="#十、异常" class="headerlink" title="十、异常"></a>十、异常</h2><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">raise</span> NameError<span class="token punctuation">(</span><span class="token string">"name error"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        a <span class="token operator">=</span> x <span class="token operator">/</span> y        <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token keyword">except</span> ZeroDivisionError <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"exception: </span><span class="token interpolation"><span class="token punctuation">{</span>e<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token keyword">except</span> NameError <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"exception: </span><span class="token interpolation"><span class="token punctuation">{</span>e<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token keyword">except</span> TypeError <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"exception: </span><span class="token interpolation"><span class="token punctuation">{</span>e<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token comment"># 如果没有异常，执行以下语句</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"no exception"</span><span class="token punctuation">)</span>    <span class="token keyword">finally</span><span class="token punctuation">:</span>        <span class="token comment"># 无论是否发生异常，都会执行</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"finally"</span><span class="token punctuation">)</span>        <span class="token comment"># 捕获多个异常</span>    <span class="token comment">#except(ZeroDivisionError, NameError, TypeError) as e:</span>    <span class="token comment">#    print(f"exception: {e}")</span>    <span class="token comment"># 捕获所有异常</span>    <span class="token comment">#except:</span>    <span class="token comment">#    print("exception")</span>    test<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>test<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyException</span><span class="token punctuation">(</span>Exception<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">'this is my exception'</span><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> MyException<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> MyException <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"my exception is: "</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>test<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十一、全局变量"><a href="#十一、全局变量" class="headerlink" title="十一、全局变量"></a>十一、全局变量</h2><p>函数中对于全局变量的修改：如果全局变量是不可变对象，修改时需要使用 global 声明；如果是可变对象，则不需要 global 声明。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">num <span class="token operator">=</span> <span class="token number">100</span>num_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">test_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> num    num <span class="token operator">=</span> <span class="token number">90</span><span class="token keyword">def</span> <span class="token function">test_2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    num_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>num_list<span class="token punctuation">)</span>test_1<span class="token punctuation">(</span><span class="token punctuation">)</span>test_2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>num_list<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十二、其他"><a href="#十二、其他" class="headerlink" title="十二、其他"></a>十二、其他</h2><h3 id="1-方法"><a href="#1-方法" class="headerlink" title="1. 方法"></a>1. 方法</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">str2hex</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token builtin">hex</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'0x'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">str_to_hex</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token builtin">hex</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'0x'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">def</span> <span class="token function">hex_to_str</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token builtin">chr</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token keyword">for</span> b <span class="token keyword">in</span> s<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">str_to_bin</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token builtin">bin</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'0b'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">bin_to_str</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token builtin">chr</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">for</span> b <span class="token keyword">in</span> s<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h3><p>Python 代码的执行由 Python 虚拟机（解释器主循环）控制。Python 在设计之初就考虑到在主循环中只能有一个线程执行，虽然 Python 解释器中可以“运行”多个线程，但是在任意时刻只有一个线程在解释器中运行。</p><p>Python 虚拟机的访问由全局解释器锁（Global Interpreter Lock, GIL）控制，这个锁能保证同一时刻只有一个线程运行。</p><p>在多线程环境中，Python 虚拟机按以下方式执行：</p><ol><li>设置 GIL</li><li>切换到一个线程运行</li><li>运行指定数量的字节码指令或线程主动让出控制（可以调用 time.sleep(0)）</li><li>把线程设置为睡眠状态</li><li>解锁GIL</li><li>再次重复以上所有步骤</li></ol><p>在调用外部代码（如 C/C++ 扩展函数）时，GIL 将被锁定，直到这个函数结束为止（由于在此期间没有运行 Python 的字节码，因此不会做线程切换），编写扩展的程序员可以主动解锁 GIL。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
